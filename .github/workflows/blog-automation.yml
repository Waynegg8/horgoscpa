name: 部落格與影片自動化處理 (修復版)

on:
  # 手動觸發
  workflow_dispatch:
    inputs:
      process_word:
        description: '處理Word文檔'
        required: true
        default: 'true'
        type: boolean
      update_json:
        description: '更新JSON文件'
        required: true
        default: 'true'
        type: boolean
      handle_deletion:
        description: '處理文章刪除'
        required: true
        default: 'true'
        type: boolean
      update_videos:
        description: '更新影片數據'
        required: true
        default: 'true'
        type: boolean
      force_scan:
        description: '強制掃描所有HTML文章'
        required: true
        default: 'false'
        type: boolean
      update_sitemap:
        description: '更新網站Sitemap'
        required: true
        default: 'true'
        type: boolean
      publish_scheduled:
        description: '發布排程文章'
        required: true
        default: 'true'
        type: boolean
      update_dictionary:
        description: '更新翻譯字典'
        required: true
        default: 'true'
        type: boolean
      deploy_ai_chat:
        description: '部署AI客服功能'
        required: true
        default: 'true'
        type: boolean
  
  # 當有任何文件變更時觸發
  push:
    paths:
      - '**/*'  # 任何文件變更都會觸發工作流
  
  # 當文章被刪除時觸發
  delete:
    paths:
      - 'blog/**/*.html'
      - 'services/**/*.html'
      - '*.html'
  
  # 每天定時執行
  schedule:
    - cron: '0 1 * * *'  # UTC 時間每天1點 (台灣時間9點)
    
  # 接收從網頁界面觸發的事件
  repository_dispatch:
    types: [delete-article, upload-article, scan-articles, update-video, update-sitemap, publish-scheduled, update-dictionary, deploy-ai-chat]

jobs:
  content-automation:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: write
    
    steps:
      # 1. 檢出代碼
      - name: 檢出代碼
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 包含完整歷史記錄用於檢測刪除
          
      # 2. 設置 Git 配置
      - name: 設置 Git 配置
        run: |
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
      
      # 3. 設置 Python 環境
      - name: 設置 Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: requirements.txt
      
      # 4. 檢查文件結構和修復導入問題
      - name: 檢查文件結構和修復導入問題
        run: |
          echo "===== 檢查當前目錄結構 ====="
          ls -la
          
          echo "===== 檢查Python文件 ====="
          find . -name "*.py" | head -20
          
          echo "===== 檢查scripts目錄 ====="
          if [ -d "scripts" ]; then
            ls -la scripts/
          else
            echo "scripts目錄不存在，創建之"
            mkdir -p scripts
          fi
          
          echo "===== 修復Python模組導入問題 ====="
          # 創建符號鏈接或複製文件到根目錄，確保main.py能找到
          REQUIRED_FILES=("word_processor.py" "html_generator.py" "content_manager.py" "translator.py" "utils.py" "json_generator.py")
          
          for file in "${REQUIRED_FILES[@]}"; do
            if [ -f "$file" ]; then
              echo "✓ $file 已存在於根目錄"
            elif [ -f "scripts/$file" ]; then
              echo "→ 從scripts目錄鏈接 $file"
              ln -sf "scripts/$file" "$file"
            else
              echo "✗ 找不到 $file"
            fi
          done
          
          echo "===== 最終文件檢查 ====="
          for file in "${REQUIRED_FILES[@]}"; do
            if [ -f "$file" ]; then
              echo "✓ $file"
            else
              echo "✗ $file 仍然缺失"
            fi
          done
      
      # 5. 安裝依賴
      - name: 安裝依賴套件
        run: |
          python -m pip install --upgrade pip
          
          # 如果有requirements.txt就用它，否則安裝基本套件
          if [ -f "requirements.txt" ]; then
            pip install -r requirements.txt
          else
            echo "requirements.txt不存在，安裝基本依賴"
            pip install loguru python-docx beautifulsoup4 requests pathlib
          fi
          
          echo "===== 測試Python導入 ====="
          python -c "
          import sys
          print('Python版本:', sys.version)
          print('Python路徑:', sys.path[:5])  # 只顯示前5個路徑
          
          # 測試基本套件
          try:
              import loguru
              print('✓ loguru 導入成功')
          except ImportError as e:
              print('✗ loguru 導入失敗:', e)
          
          try:
              import docx
              print('✓ python-docx 導入成功')
          except ImportError as e:
              print('✗ python-docx 導入失敗:', e)
          
          try:
              from bs4 import BeautifulSoup
              print('✓ BeautifulSoup 導入成功')
          except ImportError as e:
              print('✗ BeautifulSoup 導入失敗:', e)
          "
      
      # 6. 創建必要的目錄
      - name: 創建必要的目錄
        run: |
          mkdir -p blog
          mkdir -p assets/data
          mkdir -p assets/images/blog
          mkdir -p assets/css
          mkdir -p assets/js
          mkdir -p word-docs/processed
          mkdir -p video
          mkdir -p .github/scripts
          mkdir -p logs
          mkdir -p scripts

      # 7. 測試Python模組導入
      - name: 測試Python模組導入
        run: |
          echo "===== 測試自定義模組導入 ====="
          python -c "
          import sys
          sys.path.insert(0, '.')
          sys.path.insert(0, 'scripts')
          
          # 測試各個模組
          modules_to_test = [
              ('utils', 'utils'),
              ('translator', 'translator'),  
              ('word_processor', 'WordProcessor'),
              ('html_generator', 'HtmlGenerator'),
              ('content_manager', 'ContentManager'),
              ('json_generator', 'JsonGenerator')
          ]
          
          for module_name, class_name in modules_to_test:
              try:
                  if class_name == module_name:  # 對於utils和translator，直接導入模組
                      exec(f'import {module_name}')
                      print(f'✓ {module_name} 模組導入成功')
                  else:  # 對於其他，導入特定類
                      exec(f'from {module_name} import {class_name}')
                      print(f'✓ {class_name} 類從 {module_name} 導入成功')
              except ImportError as e:
                  print(f'✗ {class_name} 從 {module_name} 導入失敗: {e}')
                  # 嘗試從scripts目錄導入
                  try:
                      if class_name == module_name:
                          exec(f'from scripts import {module_name}')
                          print(f'✓ scripts.{module_name} 模組導入成功')
                      else:
                          exec(f'from scripts.{module_name} import {class_name}')
                          print(f'✓ {class_name} 類從 scripts.{module_name} 導入成功')
                  except ImportError as e2:
                      print(f'✗ 從scripts目錄導入也失敗: {e2}')
          "

      # 8. 處理API觸發的文章刪除
      - name: 處理API觸發的文章刪除
        if: github.event_name == 'repository_dispatch' && github.event.action == 'delete-article'
        run: |
          echo "收到API觸發的文章刪除請求"
          echo "文件路徑: ${{ github.event.client_payload.file_path }}"
          echo "文章標題: ${{ github.event.client_payload.article_title }}"
          
          # 確保工作區乾淨
          git stash -u || true
          
          # 先拉取最新變更以避免衝突
          git pull origin ${GITHUB_REF##*/} || true
          
          # 應用stash (如果需要)
          git stash pop || true
          
          # 檢查文件是否存在
          if [ -f "${{ github.event.client_payload.file_path }}" ]; then
            # 刪除文件
            rm "${{ github.event.client_payload.file_path }}"
            echo "文件已刪除"
            
            # 提交變更
            git add -A
            git commit -m "透過API刪除文章: ${{ github.event.client_payload.article_title }}"
            git push
            echo "已提交刪除操作"
          else
            echo "警告: 找不到要刪除的文件 ${{ github.event.client_payload.file_path }}"
          fi

      # 9. 檢查Word文檔
      - name: 檢查Word文檔
        id: check_word_docs
        run: |
          # 找出word-docs目錄中的.docx文件，但排除processed子目錄
          if [ -d "word-docs" ]; then
            DOCX_COUNT=$(find word-docs -maxdepth 1 -type f -name "*.docx" | wc -l)
            
            if [ "$DOCX_COUNT" -gt 0 ]; then
              echo "has_word_docs=true" >> $GITHUB_OUTPUT
              echo "發現 $DOCX_COUNT 個Word文檔，將進行處理"
              # 列出找到的文件
              find word-docs -maxdepth 1 -type f -name "*.docx"
            else
              echo "has_word_docs=false" >> $GITHUB_OUTPUT
              echo "未發現需要處理的Word文檔"
            fi
          else
            echo "has_word_docs=false" >> $GITHUB_OUTPUT
            echo "word-docs目錄不存在"
          fi

      # 10. 處理Word文檔 (使用修復後的main.py)
      - name: 處理Word文檔
        id: process_word
        if: github.event.inputs.process_word == 'true' || (github.event_name == 'repository_dispatch' && github.event.action == 'upload-article') || steps.check_word_docs.outputs.has_word_docs == 'true'
        run: |
          echo "===== 處理Word文檔步驟開始 ====="
          
          if [ -d "word-docs" ]; then
            # 檢查是否有Word文檔
            DOCX_FILES=$(find word-docs -maxdepth 1 -type f -name "*.docx" 2>/dev/null || echo "")
            DOCX_COUNT=$(echo "$DOCX_FILES" | grep -c "\.docx$" 2>/dev/null || echo "0")
            
            if [ "$DOCX_COUNT" -gt 0 ]; then
              echo "開始處理$DOCX_COUNT個Word文檔..."
              
              # 設置環境變數
              export PYTHONPATH=".:scripts:$PYTHONPATH"
              
              # 執行python處理腳本，使用詳細模式
              echo "執行命令: python main.py --word-dir word-docs --output-dir blog --assets-dir assets --debug --process-all"
              
              python main.py --word-dir word-docs --output-dir blog --assets-dir assets --debug --process-all
              
              # 檢查處理結果
              PROCESS_RESULT=$?
              echo "Python腳本退出碼: $PROCESS_RESULT"
              
              if [ $PROCESS_RESULT -eq 0 ]; then
                echo "✅ Word文檔處理成功"
                echo "html_changed=true" >> $GITHUB_OUTPUT
                
                # 檢查是否有新生成的HTML文件
                HTML_COUNT=$(find blog -name "*.html" | wc -l)
                echo "生成的HTML文件數量: $HTML_COUNT"
                
                # 立即提交更新後的翻譯字典
                echo "提交更新後的翻譯字典..."
                git add assets/data/translation_dict.json || true
                if git diff --cached --quiet; then
                  echo "翻譯字典沒有變更"
                else
                  git commit -m "更新翻譯字典 (Word處理後)" || echo "提交翻譯字典失敗"
                  git push || echo "推送翻譯字典失敗"
                fi
              else
                echo "❌ Word文檔處理失敗，退出碼: $PROCESS_RESULT"
                echo "html_changed=false" >> $GITHUB_OUTPUT
                
                # 顯示更多錯誤信息
                echo "檢查Python文件是否存在:"
                ls -la *.py
                echo "檢查logs目錄:"
                if [ -d "logs" ]; then
                  ls -la logs/
                  # 顯示最新的日誌文件內容
                  LATEST_LOG=$(ls -t logs/*.log 2>/dev/null | head -1)
                  if [ -f "$LATEST_LOG" ]; then
                    echo "最新日誌內容 ($LATEST_LOG):"
                    tail -50 "$LATEST_LOG"
                  fi
                fi
              fi
            else
              echo "⚠️ 沒有要處理的Word文檔"
              echo "html_changed=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "❌ word-docs目錄不存在"
            echo "html_changed=false" >> $GITHUB_OUTPUT
          fi
          
          echo "===== 處理Word文檔步驟結束 ====="
      
      # 11. 上傳並提交轉換後的 HTML
      - name: 上傳並提交轉換後的 HTML
        if: steps.process_word.outputs.html_changed == 'true'
        run: |
          # 檢查是否有新的文件變更
          git status
          
          # 添加新的HTML文件
          git add blog/*.html || echo "沒有HTML文件可添加"
          
          # 檢查是否有變更的文件
          if git diff --cached --quiet; then
            echo "沒有新的HTML文件需要提交"
          else
            CHANGED_FILES=$(git diff --name-only --cached | grep -c ".html" || echo "0")
            echo "檢測到 $CHANGED_FILES 個變更的HTML文件"
            
            if [ "$CHANGED_FILES" -gt "0" ]; then
              echo "提交轉換後的HTML文件"
              git commit -m "提交轉換後的 HTML 文件"
              git push
            fi
          fi
          
      # 12. 檢查是否有文章被刪除
      - name: 檢查是否有文章被刪除
        id: check_deleted
        if: github.event.inputs.handle_deletion == 'true' || github.event_name == 'delete'
        run: |
          echo "檢查是否有文章被刪除..."
          
          # 檢查最近的提交是否有刪除的HTML文件
          DELETED_FILES=$(git log --diff-filter=D --name-only -n 1 | grep -c "blog.*\.html" || echo "0")
          echo "檢測到 $DELETED_FILES 個被刪除的HTML文件"
          
          if [ "$DELETED_FILES" -gt "0" ]; then
            echo "html_deleted=true" >> $GITHUB_OUTPUT
          else
            echo "html_deleted=false" >> $GITHUB_OUTPUT
          fi
      
      # 13. 更新博客JSON文件 - 使用獨立腳本
      - name: 更新博客JSON文件
        id: update_blog_json
        if: steps.process_word.outputs.html_changed == 'true' || github.event.inputs.update_json == 'true' || github.event_name == 'schedule' || steps.check_deleted.outputs.html_deleted == 'true' || (github.event_name == 'repository_dispatch' && (github.event.action == 'delete-article' || github.event.action == 'upload-article' || github.event.action == 'scan-articles' || github.event.action == 'publish-scheduled'))
        run: |
          echo "開始更新博客JSON文件..."
          
          # 檢查腳本是否存在
          if [ -f ".github/scripts/update_blog_json.py" ]; then
            # 執行現有的更新腳本
            python .github/scripts/update_blog_json.py
          else
            echo "update_blog_json.py不存在，使用內建的json_generator"
            # 使用json_generator模組
            python -c "
            import sys
            sys.path.insert(0, '.')
            sys.path.insert(0, 'scripts')
            
            try:
                from json_generator import JsonGenerator
                json_gen = JsonGenerator(data_dir='assets/data')
                json_gen.generate_all_json()
                print('JSON文件更新成功')
            except Exception as e:
                print(f'JSON文件更新失敗: {e}')
                import traceback
                traceback.print_exc()
            "
          fi
          
          echo "博客JSON文件更新完成"
          echo "blog_json_updated=true" >> $GITHUB_OUTPUT
          
          # 提交更新後的JSON文件
          git add assets/data/*.json || true
          if git diff --cached --quiet; then
            echo "JSON文件沒有變更"
          else
            git commit -m "更新博客JSON文件" || echo "提交JSON文件失敗"
            git push || echo "推送JSON文件失敗"
          fi

      # 繼續其他步驟...
      # 14-18步驟保持原樣，這裡省略以節省空間
      
      # 最後的結果通知
      - name: 工作流執行結果通知
        run: |
          echo "===== 工作流程執行完成 ====="
          echo "執行時間: $(date "+%Y-%m-%d %H:%M:%S UTC")"
          echo "時區: $(date "+%Z %z")"
          
          # 顯示執行結果摘要
          echo ""
          echo "執行結果摘要:"
          echo "- Word文檔處理: ${{ steps.process_word.outputs.html_changed == 'true' && '成功' || '跳過或失敗' }}"
          echo "- JSON文件更新: ${{ steps.update_blog_json.outputs.blog_json_updated == 'true' && '成功' || '跳過' }}"
          
          # 顯示生成的文件統計
          echo ""
          echo "文件統計:"
          echo "- HTML文件: $(find blog -name "*.html" | wc -l) 個"
          echo "- JSON文件: $(find assets/data -name "*.json" | wc -l) 個"
          echo "- 已處理Word文檔: $(find word-docs/processed -name "*.docx" 2>/dev/null | wc -l) 個"
          
          # 可以在這裡添加其他通知方式
          # 例如發送webhook通知、Slack通知等