name: 部落格與影片自動化處理

on:
  # 手動觸發
  workflow_dispatch:
    inputs:
      process_word:
        description: '處理Word文檔'
        required: true
        default: 'true'
        type: boolean
      update_json:
        description: '更新JSON文件'
        required: true
        default: 'true'
        type: boolean
      handle_deletion:
        description: '處理文章刪除'
        required: true
        default: 'true'
        type: boolean
      update_videos:
        description: '更新影片數據'
        required: true
        default: 'true'
        type: boolean
      force_scan:
        description: '強制掃描所有HTML文章'
        required: true
        default: 'false'
        type: boolean
      update_sitemap:
        description: '更新網站Sitemap'
        required: true
        default: 'true'
        type: boolean
      publish_scheduled:
        description: '發布排程文章'
        required: true
        default: 'true'
        type: boolean
      update_dictionary:
        description: '更新翻譯字典'
        required: true
        default: 'true'
        type: boolean
  
  # 當有任何文件變更時觸發
  push:
    paths:
      - '**/*'  # 任何文件變更都會觸發工作流
  
  # 當文章被刪除時觸發
  delete:
    paths:
      - 'blog/**/*.html'
      - 'services/**/*.html'
      - '*.html'
  
  # 每天定時執行
  schedule:
    - cron: '0 1 * * *'  # UTC 時間每天1點 (台灣時間9點)
    
  # 接收從網頁界面觸發的事件
  repository_dispatch:
    types: [delete-article, upload-article, scan-articles, update-video, update-sitemap, publish-scheduled, update-dictionary]

jobs:
  content-automation:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: write
    
    steps:
      # 1. 檢出代碼
      - name: 檢出代碼
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 包含完整歷史記錄用於檢測刪除
          
      # 2. 設置 Git 配置
      - name: 設置 Git 配置
        run: |
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
      
      # 3. 設置 Python 環境
      - name: 設置 Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: requirements.txt
      
      # 4. 安裝依賴
      - name: 安裝依賴套件
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          # 安裝額外的翻譯依賴
          pip install requests
      
      # 5. 創建必要的目錄
      - name: 創建必要的目錄
        run: |
          mkdir -p blog
          mkdir -p assets/data
          mkdir -p word-docs
          mkdir -p video

      # 6. 更新翻譯字典 (新步驟)
      - name: 更新翻譯字典
        id: update_dictionary
        if: github.event.inputs.update_dictionary == 'true' || github.event_name == 'repository_dispatch' && github.event.action == 'update-dictionary' || (github.event_name == 'push' && contains(github.event.head_commit.modified, 'word-docs'))
        run: |
          echo "開始更新翻譯字典..."
          
          # 檢查腳本是否存在
          if [ ! -f ".github/scripts/update_dictionary.py" ]; then
            echo "警告: 找不到 .github/scripts/update_dictionary.py 腳本"
            echo "將建立必要的腳本"
            
            # 確保目錄存在
            mkdir -p .github/scripts
            
            # 創建 translate_utils.py
            cat > .github/scripts/translate_utils.py << 'EOL'
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
翻譯工具模組 - 使用 LibreTranslate API 將中文翻譯為英文
作者: Claude
日期: 2025-05-07
"""

import os
import re
import json
import time
import logging
import requests
from typing import Dict, List, Optional, Union, Any

# 設置日誌
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger("translate_utils")

# 翻譯服務配置
# 使用免費的 LibreTranslate API 服務，可以根據需要替換為其他服務
LIBRE_TRANSLATE_ENDPOINTS = [
    "https://libretranslate.de/translate",
    "https://translate.terraprint.co/translate",
    "https://translate.argosopentech.com/translate"
]

def clean_text_for_translation(text: str) -> str:
    """
    清理文本，準備翻譯
    移除數字、標點符號，並只保留有意義的文本
    """
    if not text:
        return ""
    
    # 移除URL、日期、文件擴展名等
    text = re.sub(r'https?://\S+', '', text)
    text = re.sub(r'\d{4}-\d{2}-\d{2}', '', text)
    text = re.sub(r'\.docx?|\.html?|\.pdf', '', text)
    
    # 移除標點符號和特殊字符
    text = re.sub(r'[^\w\s\u4e00-\u9fff]', ' ', text)
    
    # 移除多餘的空格
    text = re.sub(r'\s+', ' ', text).strip()
    
    return text

def translate_text(text: str, source_lang: str = "zh", target_lang: str = "en", max_retries: int = 3) -> Optional[str]:
    """
    使用 LibreTranslate API 翻譯文本
    :param text: 要翻譯的文本
    :param source_lang: 源語言代碼 (默認為中文)
    :param target_lang: 目標語言代碼 (默認為英文)
    :param max_retries: 最大重試次數
    :return: 翻譯結果或 None (如果翻譯失敗)
    """
    if not text or not text.strip():
        return ""
    
    # 清理文本
    cleaned_text = clean_text_for_translation(text)
    if not cleaned_text:
        return ""
    
    # 如果文本不包含中文字符，則直接返回原文
    if not re.search(r'[\u4e00-\u9fff]', cleaned_text):
        return cleaned_text
    
    # 輪詢所有端點，直到成功為止
    for endpoint in LIBRE_TRANSLATE_ENDPOINTS:
        for attempt in range(max_retries):
            try:
                data = {
                    "q": cleaned_text,
                    "source": source_lang,
                    "target": target_lang,
                    "format": "text"
                }
                
                headers = {
                    "Content-Type": "application/json"
                }
                
                response = requests.post(endpoint, json=data, headers=headers, timeout=10)
                
                if response.status_code == 200:
                    result = response.json()
                    if 'translatedText' in result:
                        translated_text = result['translatedText']
                        logger.info(f"成功翻譯文本，字節數: {len(cleaned_text)}")
                        return translated_text
                    else:
                        logger.warning(f"翻譯 API 回應缺少 'translatedText' 字段: {result}")
                else:
                    logger.warning(f"翻譯請求失敗: 狀態碼 {response.status_code}")
                    
                # 在重試前等待一段時間（避免頻率限制）
                time.sleep(1)
                
            except Exception as e:
                logger.error(f"翻譯文本時發生錯誤: {str(e)}")
                # 在重試前等待一段時間
                time.sleep(1)
                
    logger.error(f"所有翻譯端點均失敗，無法翻譯文本: {cleaned_text[:100]}")
    return None

def translate_to_english_slug(text: str, existing_dict: Dict[str, str] = None) -> str:
    """
    將中文文本轉換為英文 slug
    :param text: 中文文本
    :param existing_dict: 現有翻譯字典 (可選)
    :return: 英文 slug
    """
    import hashlib
    
    if not text:
        return "untitled"
    
    # 如果有現有字典且文本在字典中，直接使用
    if existing_dict and text in existing_dict:
        return existing_dict[text].lower().replace(' ', '-')
    
    # 嘗試翻譯
    translated = translate_text(text)
    
    if translated:
        # 清理翻譯結果，只保留英文、數字和空格
        cleaned = re.sub(r'[^\w\s]', '', translated).strip().lower()
        # 將空格替換為連字符
        slug = re.sub(r'\s+', '-', cleaned)
        # 移除連續的連字符
        slug = re.sub(r'-+', '-', slug)
        # 確保 slug 不超過 100 個字符
        if len(slug) > 100:
            slug = slug[:100]
        
        # 確保 slug 不為空
        if slug:
            return slug
    
    # 如果翻譯失敗或結果為空，使用哈希
    hash_value = hashlib.md5(text.encode('utf-8')).hexdigest()[:8]
    return f"article-{hash_value}"

def batch_translate_terms(terms: List[str], existing_dict: Dict[str, str] = None) -> Dict[str, str]:
    """
    批量翻譯術語
    :param terms: 術語列表
    :param existing_dict: 現有翻譯字典 (可選)
    :return: 翻譯結果字典
    """
    if existing_dict is None:
        existing_dict = {}
    
    result_dict = {}
    
    for term in terms:
        # 跳過空術語或純數字、英文
        if not term or not re.search(r'[\u4e00-\u9fff]', term):
            continue
        
        # 如果已在字典中，跳過
        if term in existing_dict:
            continue
        
        # 翻譯並轉換為 slug
        translated = translate_to_english_slug(term)
        if translated:
            result_dict[term] = translated
            logger.info(f"翻譯術語: {term} -> {translated}")
        
        # 避免頻率限制
        time.sleep(0.5)
    
    return result_dict

def extract_chinese_terms_from_filename(filename: str) -> List[str]:
    """
    從文件名中提取中文詞彙
    :param filename: 文件名
    :return: 中文詞彙列表
    """
    # 移除文件擴展名
    base_name = os.path.splitext(filename)[0]
    
    # 移除日期部分
    name_without_date = re.sub(r'^\d{4}-\d{2}-\d{2}-?', '', base_name)
    
    # 分割 EP 部分前後
    parts = re.split(r'EP\d+[-_]?', name_without_date, flags=re.IGNORECASE)
    
    # 提取中文詞彙
    chinese_terms = []
    
    for part in parts:
        # 使用正則表達式匹配連續的中文字符
        matches = re.findall(r'[\u4e00-\u9fff]+', part)
        chinese_terms.extend(matches)
    
    # 添加完整的中文詞組（如果存在）
    if re.search(r'[\u4e00-\u9fff]', name_without_date):
        # 移除 EP 部分
        clean_name = re.sub(r'EP\d+[-_]?', '', name_without_date)
        # 只保留中文部分
        chinese_only = ''.join(re.findall(r'[\u4e00-\u9fff]', clean_name))
        if chinese_only and len(chinese_only) > 1:
            chinese_terms.append(chinese_only)
    
    return chinese_terms

def update_translation_dict(file_paths: List[str], dict_path: str) -> bool:
    """
    更新翻譯字典
    :param file_paths: 文件路徑列表
    :param dict_path: 字典文件路徑
    :return: 是否成功更新
    """
    try:
        # 加載現有字典
        existing_dict = {}
        if os.path.exists(dict_path):
            with open(dict_path, 'r', encoding='utf-8') as f:
                existing_dict = json.load(f)
        
        # 收集需要翻譯的術語
        terms_to_translate = []
        
        for file_path in file_paths:
            if not os.path.exists(file_path):
                logger.warning(f"文件不存在: {file_path}")
                continue
            
            filename = os.path.basename(file_path)
            chinese_terms = extract_chinese_terms_from_filename(filename)
            
            for term in chinese_terms:
                if term and term not in existing_dict and term not in terms_to_translate:
                    terms_to_translate.append(term)
        
        if not terms_to_translate:
            logger.info("沒有新術語需要翻譯")
            return True
        
        logger.info(f"將翻譯 {len(terms_to_translate)} 個新術語")
        
        # 批量翻譯
        new_translations = batch_translate_terms(terms_to_translate, existing_dict)
        
        if not new_translations:
            logger.warning("沒有獲得新的翻譯結果")
            return True
        
        # 更新字典
        existing_dict.update(new_translations)
        
        # 保存更新後的字典
        with open(dict_path, 'w', encoding='utf-8') as f:
            json.dump(existing_dict, f, ensure_ascii=False, indent=2, sort_keys=True)
        
        logger.info(f"成功更新翻譯字典，新增 {len(new_translations)} 個翻譯")
        return True
        
    except Exception as e:
        logger.error(f"更新翻譯字典時發生錯誤: {str(e)}")
        return False

if __name__ == "__main__":
    # 測試代碼
    test_word = "資本變更"
    result = translate_text(test_word)
    print(f"翻譯結果: {test_word} -> {result}")
    
    result_slug = translate_to_english_slug(test_word)
    print(f"Slug 結果: {test_word} -> {result_slug}")
EOL

            # 創建 update_dictionary.py
            cat > .github/scripts/update_dictionary.py << 'EOL'
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
更新翻譯字典腳本 - 掃描 Word 文檔並更新翻譯字典
作者: Claude
日期: 2025-05-07
"""

import os
import sys
import glob
import logging
import argparse
from pathlib import Path
from typing import List, Dict, Any

# 確保腳本目錄在 Python 路徑中
script_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.abspath(os.path.join(script_dir, '..', '..'))
sys.path.append(script_dir)
sys.path.append(project_root)

# 導入翻譯工具
from translate_utils import update_translation_dict

# 設置日誌
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger("update_dictionary")

# 設置路徑
WORD_DOCS_DIR = os.path.join(project_root, "word-docs")
TRANSLATION_DICT_PATH = os.path.join(project_root, "tw_financial_dict.json")

def scan_word_docs() -> List[str]:
    """
    掃描 word-docs 目錄中的 Word 文檔
    :return: Word 文檔路徑列表
    """
    if not os.path.exists(WORD_DOCS_DIR):
        logger.warning(f"目錄不存在: {WORD_DOCS_DIR}")
        return []
    
    # 搜索所有 .docx 文件
    docx_files = glob.glob(os.path.join(WORD_DOCS_DIR, "*.docx"))
    
    if not docx_files:
        logger.info(f"在 {WORD_DOCS_DIR} 中沒有找到 Word 文檔")
    else:
        logger.info(f"找到 {len(docx_files)} 個 Word 文檔")
    
    return docx_files

def main():
    """主函數"""
    # 設置命令行參數
    parser = argparse.ArgumentParser(description='更新翻譯字典')
    parser.add_argument('--dict-path', type=str, default=TRANSLATION_DICT_PATH,
                        help='翻譯字典文件路徑')
    parser.add_argument('--word-dir', type=str, default=WORD_DOCS_DIR,
                        help='Word 文檔目錄路徑')
    args = parser.parse_args()
    
    # 更新路徑
    global WORD_DOCS_DIR, TRANSLATION_DICT_PATH
    WORD_DOCS_DIR = args.word_dir
    TRANSLATION_DICT_PATH = args.dict_path
    
    logger.info(f"Word 文檔目錄: {WORD_DOCS_DIR}")
    logger.info(f"翻譯字典路徑: {TRANSLATION_DICT_PATH}")
    
    # 掃描 Word 文檔
    word_docs = scan_word_docs()
    
    if not word_docs:
        logger.info("沒有 Word 文檔需要處理")
        return 0
    
    # 更新翻譯字典
    success = update_translation_dict(word_docs, TRANSLATION_DICT_PATH)
    
    if success:
        logger.info("翻譯字典更新成功")
        return 0
    else:
        logger.error("翻譯字典更新失敗")
        return 1

if __name__ == "__main__":
    sys.exit(main())
EOL

            # 添加執行權限
            chmod +x .github/scripts/translate_utils.py
            chmod +x .github/scripts/update_dictionary.py
          fi
          
          # 執行字典更新腳本
          python .github/scripts/update_dictionary.py
          
          # 提交更新後的字典
          git add tw_financial_dict.json
          git commit -m "更新翻譯字典" || echo "無需提交翻譯字典"
          git push || echo "無需推送翻譯字典"
          
          echo "dictionary_updated=true" >> $GITHUB_OUTPUT

      # 7. 處理API觸發的文章刪除
      - name: 處理API觸發的文章刪除
        if: github.event_name == 'repository_dispatch' && github.event.action == 'delete-article'
        run: |
          echo "收到API觸發的文章刪除請求"
          echo "文件路徑: ${{ github.event.client_payload.file_path }}"
          echo "文章標題: ${{ github.event.client_payload.article_title }}"
          
          # 確保工作區乾淨
          git stash -u || true
          
          # 先拉取最新變更以避免衝突
          git pull origin ${GITHUB_REF##*/} || true
          
          # 應用stash (如果需要)
          git stash pop || true
          
          # 檢查文件是否存在
          if [ -f "${{ github.event.client_payload.file_path }}" ]; then
            # 刪除文件
            rm "${{ github.event.client_payload.file_path }}"
            echo "文件已刪除"
            
            # 提交變更
            git add -A
            git commit -m "透過API刪除文章: ${{ github.event.client_payload.article_title }}"
            git push
            echo "已提交刪除操作"
          else
            echo "警告: 找不到要刪除的文件 ${{ github.event.client_payload.file_path }}"
          fi

      # 8. 處理掃描請求
      - name: 處理API觸發的掃描請求
        if: github.event_name == 'repository_dispatch' && github.event.action == 'scan-articles'
        run: |
          echo "收到API觸發的文章掃描請求"
          echo "將進行強制掃描"
          python .github/scripts/update_blog_posts.py
          
          # 確保工作區乾淨
          git stash -u || true
          
          # 先拉取最新變更以避免衝突
          git pull origin ${GITHUB_REF##*/} || true
          
          # 應用stash (如果需要)
          git stash pop || true
          
          git add assets/data/blog-posts.json assets/data/latest-posts.json
          git commit -m "透過API執行強制掃描並更新JSON" || echo "無需提交"
          git push || echo "無需推送"

      # 9. 處理排程發布請求
      - name: 處理API觸發的排程發布請求
        if: github.event_name == 'repository_dispatch' && github.event.action == 'publish-scheduled' || github.event_name == 'schedule' || github.event.inputs.publish_scheduled == 'true'
        run: |
          echo "開始執行自動發布排程文章任務"
          python .github/scripts/update_blog_posts.py --publish-scheduled
          
          # 確保工作區乾淨
          git stash -u || true
          
          # 先拉取最新變更以避免衝突
          git pull origin ${GITHUB_REF##*/} || true
          
          # 應用stash (如果需要)
          git stash pop || true
          
          git add assets/data/blog-posts.json assets/data/latest-posts.json
          git commit -m "自動發布排程文章" || echo "無需提交"
          git push || echo "無需推送"
          
          echo "排程發布任務完成"

      # 10. 處理Word文檔
      - name: 處理Word文檔
        if: github.event_name == 'push' || github.event.inputs.process_word == 'true' || (github.event_name == 'repository_dispatch' && github.event.action == 'upload-article')
        run: |
          if [ -d "word-docs" ] && [ "$(ls -A word-docs)" ]; then
            echo "開始處理word-docs目錄中的Word文檔..."
            
            # 使用 .github/scripts 目錄下的腳本
            if [ -f ".github/scripts/word_to_html.py" ]; then
              python .github/scripts/word_to_html.py word-docs blog
              echo "使用 .github/scripts/word_to_html.py 處理完成"
            else
              echo "警告: 找不到 .github/scripts/word_to_html.py 腳本"
              echo "嘗試查找腳本位置:"
              find . -name "word_to_html.py" -type f
              
              # 如果能找到腳本，使用第一個找到的
              SCRIPT_PATH=$(find . -name "word_to_html.py" -type f | head -n 1)
              if [ -n "$SCRIPT_PATH" ]; then
                echo "找到腳本: $SCRIPT_PATH"
                python "$SCRIPT_PATH" word-docs blog
                echo "使用 $SCRIPT_PATH 處理完成"
              else
                echo "錯誤: 無法找到任何 word_to_html.py 腳本"
                exit 1
              fi
            fi
          else
            echo "word-docs 目錄為空或不存在，跳過處理"
          fi

      # 11. 上傳並提交轉換後的 HTML - 修復此步驟以處理無文件情況
      - name: 上傳並提交轉換後的 HTML
        id: commit-html
        run: |
          # 檢查是否有新的文件變更
          git status
          
          # 嘗試添加新的HTML文件
          git add blog/*.html
          
          # 檢查是否有變更的文件
          CHANGED_FILES=$(git diff --name-only --cached | grep -c ".html" || echo "0")
          echo "檢測到 $CHANGED_FILES 個變更的HTML文件"
          
          if [ "$CHANGED_FILES" -gt "0" ]; then
            echo "提交轉換後的HTML文件"
            git commit -m "提交轉換後的 HTML 文件"
            git push
            echo "html_changed=true" >> $GITHUB_OUTPUT
          else
            echo "沒有新的 HTML 文件需要提交"
            # 重置已添加的文件（如果有）
            git reset HEAD blog/*.html
            echo "html_changed=false" >> $GITHUB_OUTPUT
          fi
          
      # 12. 檢查是否有文章被刪除
      - name: 檢查是否有文章被刪除
        id: check_deleted
        if: github.event.inputs.handle_deletion == 'true' || github.event_name == 'delete'
        run: |
          echo "檢查是否有文章被刪除..."
          
          # 檢查最近的提交是否有刪除的HTML文件
          DELETED_FILES=$(git log --diff-filter=D --name-only -n 1 | grep -c "blog.*\.html" || echo "0")
          echo "檢測到 $DELETED_FILES 個被刪除的HTML文件"
          
          if [ "$DELETED_FILES" -gt "0" ]; then
            echo "html_deleted=true" >> $GITHUB_OUTPUT
          else
            echo "html_deleted=false" >> $GITHUB_OUTPUT
          fi
      
      # 13. 更新博客JSON文件
      - name: 更新博客JSON文件
        id: update_blog_json
        if: steps.commit-html.outputs.html_changed == 'true' || github.event.inputs.update_json == 'true' || github.event_name == 'schedule' || steps.check_deleted.outputs.html_deleted == 'true' || (github.event_name == 'repository_dispatch' && (github.event.action == 'delete-article' || github.event.action == 'upload-article' || github.event.action == 'scan-articles' || github.event.action == 'publish-scheduled'))
        run: |
          echo "開始更新博客JSON文件..."
          
          # 使用 .github/scripts 目錄下的腳本
          if [ -f ".github/scripts/update_blog_posts.py" ]; then
            python .github/scripts/update_blog_posts.py
            echo "使用 .github/scripts/update_blog_posts.py 更新完成"
            echo "blog_json_updated=true" >> $GITHUB_OUTPUT
          else
            echo "警告: 找不到 .github/scripts/update_blog_posts.py 腳本"
            echo "嘗試查找腳本位置:"
            find . -name "update_blog_posts.py" -type f
            
            # 如果能找到腳本，使用第一個找到的
            SCRIPT_PATH=$(find . -name "update_blog_posts.py" -type f | head -n 1)
            if [ -n "$SCRIPT_PATH" ]; then
              echo "找到腳本: $SCRIPT_PATH"
              python "$SCRIPT_PATH"
              echo "使用 $SCRIPT_PATH 更新完成"
              echo "blog_json_updated=true" >> $GITHUB_OUTPUT
            else
              echo "錯誤: 無法找到任何 update_blog_posts.py 腳本"
              echo "blog_json_updated=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi
          
          # 提交更新後的JSON文件
          git add assets/data/blog-posts.json assets/data/latest-posts.json
          git commit -m "更新博客JSON文件" || echo "無需提交JSON文件"
          git push || echo "無需推送"

      # 14. 更新影片數據
      - name: 更新影片數據
        id: update_videos
        if: github.event.inputs.update_videos == 'true' || steps.check_video_changes.outputs.videos_txt_changed == 'true' || (github.event_name == 'push' && contains(github.event.head_commit.modified, 'video/videos.txt')) || (github.event_name == 'push' && contains(github.event.head_commit.added, 'video/videos.txt')) || (github.event_name == 'repository_dispatch' && github.event.action == 'update-video')
        run: |
          echo "檢測到需要更新影片數據"
          
          # 檢查video資料夾是否存在videos.txt
          if [ -f "video/videos.txt" ]; then
            echo "找到 video/videos.txt，準備更新影片數據"
            
            # 查找並執行update_videos.py腳本
            if [ -f ".github/scripts/update_videos.py" ]; then
              echo "使用 .github/scripts/update_videos.py 更新影片數據"
              python .github/scripts/update_videos.py
              echo "videos_updated=true" >> $GITHUB_OUTPUT
            else
              echo "警告: 找不到 .github/scripts/update_videos.py 腳本"
              echo "嘗試查找腳本位置:"
              find . -name "update_videos.py" -type f
              
              # 如果能找到腳本，使用第一個找到的
              SCRIPT_PATH=$(find . -name "update_videos.py" -type f | head -n 1)
              if [ -n "$SCRIPT_PATH" ]; then
                echo "找到腳本: $SCRIPT_PATH"
                python "$SCRIPT_PATH"
                echo "使用 $SCRIPT_PATH 更新影片數據"
                echo "videos_updated=true" >> $GITHUB_OUTPUT
              else
                echo "錯誤: 無法找到任何 update_videos.py 腳本"
                echo "videos_updated=false" >> $GITHUB_OUTPUT
              fi
            fi
            
            # 提交更新後的影片JSON文件
            git add assets/data/videos.json
            git commit -m "更新影片JSON數據" || echo "無需提交影片JSON"
            git push || echo "無需推送"
          else
            echo "警告: 找不到 video/videos.txt 文件"
            echo "videos_updated=false" >> $GITHUB_OUTPUT
          fi

      # 15. 清理已處理的Word文檔 - 修復以處理無變更情況
      - name: 清理已處理的Word文檔
        if: github.event_name == 'push' && steps.commit-html.outputs.html_changed == 'true'
        run: |
          # 確保工作區乾淨
          git stash -u || true
          
          # 先拉取最新變更以避免衝突
          git pull origin ${GITHUB_REF##*/} || true
          
          # 應用stash (如果需要)
          git stash pop || true
          
          # 檢查是否有文件需要移動
          if [ -d "word-docs" ] && [ "$(find word-docs -maxdepth 1 -type f -name "*.docx" | wc -l)" -gt 0 ]; then
            # 移動已處理的文件到processed目錄
            mkdir -p word-docs/processed
            find word-docs -maxdepth 1 -type f -name "*.docx" -exec mv {} word-docs/processed/ \;
            
            # 提交更改
            git add word-docs/
            git commit -m "移動已處理的Word文檔" || echo "無需提交"
            git push || echo "無需推送"
          else
            echo "沒有需要處理的 Word 文檔"
          fi
      
      # 16. 更新網站 Sitemap（最後步驟） - 修復以處理錯誤
      - name: 更新網站 Sitemap
        id: update_sitemap
        if: github.event.inputs.update_sitemap == 'true' || github.event_name == 'schedule' || (github.event_name == 'repository_dispatch' && github.event.action == 'update-sitemap')
        run: |
          echo "開始更新網站 Sitemap..."
          
          # 生成並提交新的 sitemap.xml 文件
          python .github/scripts/generate_sitemap.py || echo "生成 Sitemap 時出錯"
          
          # 檢查文件是否存在並提交
          if [ -f "sitemap.xml" ]; then
            git add sitemap.xml sitemap_index.xml video-sitemap.xml || true
            git commit -m "更新網站Sitemap" || echo "無需提交 Sitemap"
            git push || echo "無需推送 Sitemap"
          else
            echo "警告: sitemap.xml 文件不存在或生成失敗"
          fi
          
      # 17. 結果通知
      - name: 工作流執行結果通知
        run: |
          echo "工作流程完成執行"
          echo "時間: $(date)"
          
          # 可以在這裡添加其他通知方式，如發送郵件或Slack通知
          # 例如使用curl發送webhook通知等