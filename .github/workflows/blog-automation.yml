name: 部落格自動化處理

on:
  workflow_dispatch:
    inputs:
      process_word:
        description: '處理Word文檔'
        required: true
        default: 'true'
        type: boolean
      update_json:
        description: '更新JSON文件'
        required: true
        default: 'true'
        type: boolean
      force_process:
        description: '強制重新處理所有文件'
        required: false
        default: 'false'
        type: boolean
      debug_mode:
        description: '啟用調試模式'
        required: false
        default: 'false'
        type: boolean
  
  push:
    paths:
      - 'word-docs/**/*.docx'
      - 'scripts/**/*.py'
      - '.github/workflows/blog-automation.yml'
      - '.github/scripts/**/*.py'
  
  schedule:
    - cron: '0 1 * * *'

env:
  PYTHON_VERSION: '3.11'
  DEEPL_API_KEY: ${{ secrets.DEEPL_API_KEY }}

jobs:
  blog-automation:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: write
      pages: write
      id-token: write
    
    steps:
      - name: 檢出代碼
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: 設置Git配置
        run: |
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global core.autocrlf false
          git config --global core.filemode false
      
      - name: 設置Python環境
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: 安裝Python依賴
        run: |
          python -m pip install --upgrade pip setuptools wheel
          
          # 安裝requirements.txt中的依賴
          if [ -f "requirements.txt" ]; then
            echo "安裝requirements.txt中的依賴..."
            pip install -r requirements.txt
          else
            # 安裝基本依賴
            pip install loguru python-docx beautifulsoup4 requests jieba pathlib
          fi
          
          # 驗證關鍵模組安裝
          python -c "
          import sys
          required_modules = ['loguru', 'docx', 'bs4', 'requests', 'jieba']
          missing = []
          for module in required_modules:
              try:
                  __import__(module)
                  print(f'✓ {module}')
              except ImportError:
                  missing.append(module)
                  print(f'✗ {module}')
          
          if missing:
              print(f'缺少模組: {missing}')
              sys.exit(1)
          else:
              print('所有必要模組已安裝')
          "

      - name: 初始化項目環境
        run: |
          echo "=== 初始化項目環境 ==="
          
          # 確保必要目錄存在
          mkdir -p {blog,assets/{data,images/blog},word-docs/processed,video,logs}
          
          # 檢查核心Python文件是否存在
          echo "檢查核心文件..."
          
          # 檢查主要模組文件
          CORE_FILES=("scripts/word_processor.py" "scripts/html_generator.py" "scripts/content_manager.py" "scripts/json_generator.py" "scripts/translator.py" "scripts/utils.py")
          GITHUB_SCRIPTS=(".github/scripts/update_videos.py" ".github/scripts/generate_sitemap.py" ".github/scripts/move_processed_files.py" ".github/scripts/update_blog_json.py")
          
          MISSING_FILES=()
          
          for file in "${CORE_FILES[@]}"; do
            if [ -f "$file" ]; then
              echo "✓ $file"
            else
              echo "✗ $file (缺失)"
              MISSING_FILES+=("$file")
            fi
          done
          
          for file in "${GITHUB_SCRIPTS[@]}"; do
            if [ -f "$file" ]; then
              echo "✓ $file"
            else
              echo "✗ $file (缺失)"
              MISSING_FILES+=("$file")
            fi
          done
          
          if [ ${#MISSING_FILES[@]} -gt 0 ]; then
            echo "警告: 發現 ${#MISSING_FILES[@]} 個缺失文件"
            echo "缺失文件: ${MISSING_FILES[*]}"
            echo "將使用內建備用方案"
          else
            echo "所有核心文件檢查通過"
          fi
          
          # 初始化配置文件
          python3 << 'EOF'
          import json
          from pathlib import Path
          
          # 確保assets/data目錄存在
          assets_data = Path('assets/data')
          assets_data.mkdir(parents=True, exist_ok=True)
          
          # 創建基本配置文件
          configs = {
              'translation_dict.json': {
                  "translations": {
                      "稅務": "tax", "保險": "insurance", "會計": "accounting",
                      "企業": "business", "投資": "investment", "理財": "financial-planning",
                      "節稅": "tax-saving", "規劃": "planning", "申報": "filing",
                      "法規": "regulation", "個人": "personal", "公司": "corporate",
                      "所得稅": "income-tax", "營業稅": "business-tax", "遺產稅": "estate-tax",
                      "指南": "guide", "攻略": "tips", "解析": "analysis", "案例": "case-study"
                  },
                  "last_updated": None
              },
              'processed_files.json': {"files": []},
              'categories.json': {
                  "categories": [
                      {"slug": "tax", "name": "稅務相關", "count": 0},
                      {"slug": "insurance", "name": "保險規劃", "count": 0},
                      {"slug": "accounting", "name": "會計實務", "count": 0},
                      {"slug": "business", "name": "企業服務", "count": 0}
                  ]
              },
              'tags.json': {"tags": []},
              'keyword_dict.json': {
                  "categories": {
                      "tax": {"name": "稅務相關", "keywords": ["稅務", "稅法", "報稅", "節稅", "所得稅", "營業稅", "遺產稅", "贈與稅"]},
                      "insurance": {"name": "保險規劃", "keywords": ["保險", "保單", "受益人", "要保人", "人壽保險", "保險給付"]},
                      "accounting": {"name": "會計實務", "keywords": ["會計", "帳務", "財報", "審計", "記帳", "財務"]},
                      "business": {"name": "企業服務", "keywords": ["企業", "公司", "營運", "投資", "創業", "管理"]}
                  },
                  "tags": {
                      "planning": {"name": "規劃", "keywords": ["規劃", "策略", "方案"]},
                      "filing": {"name": "申報", "keywords": ["申報", "申請", "處理"]},
                      "regulation": {"name": "法規", "keywords": ["法規", "法律", "條文", "辦法"]}
                  }
              }
          }
          
          for filename, content in configs.items():
              file_path = assets_data / filename
              if not file_path.exists():
                  with open(file_path, 'w', encoding='utf-8') as f:
                      json.dump(content, f, ensure_ascii=False, indent=2)
                  print(f'創建配置文件: {filename}')
              else:
                  print(f'配置文件已存在: {filename}')
          
          print('項目環境初始化完成')
          EOF

      - name: 檢查Word文檔
        id: check-documents
        run: |
          echo "=== 檢查Word文檔 ==="
          
          if [ -d "word-docs" ]; then
            DOCX_COUNT=$(find word-docs -maxdepth 1 -name "*.docx" ! -name "~$*" 2>/dev/null | wc -l)
            DOC_COUNT=$(find word-docs -maxdepth 1 -name "*.doc" ! -name "~$*" 2>/dev/null | wc -l)
            TOTAL_COUNT=$((DOCX_COUNT + DOC_COUNT))
            
            echo "發現Word文檔："
            echo "  - .docx 文件: $DOCX_COUNT 個"
            echo "  - .doc 文件: $DOC_COUNT 個"
            echo "  - 總計: $TOTAL_COUNT 個"
            
            if [ "$TOTAL_COUNT" -gt 0 ]; then
              echo "has_docs=true" >> $GITHUB_OUTPUT
              echo "doc_count=$TOTAL_COUNT" >> $GITHUB_OUTPUT
              
              echo "文檔列表："
              find word-docs -maxdepth 1 \( -name "*.docx" -o -name "*.doc" \) ! -name "~$*" | sort | while read file; do
                echo "  - $(basename "$file")"
              done
            else
              echo "has_docs=false" >> $GITHUB_OUTPUT
              echo "doc_count=0" >> $GITHUB_OUTPUT
            fi
          else
            echo "word-docs 目錄不存在"
            echo "has_docs=false" >> $GITHUB_OUTPUT
            echo "doc_count=0" >> $GITHUB_OUTPUT
          fi

      - name: 處理Word文檔
        id: process-documents
        if: |
          (github.event.inputs.process_word == 'true' || github.event.inputs.process_word == '' || github.event_name != 'workflow_dispatch') &&
          (steps.check-documents.outputs.has_docs == 'true' || github.event.inputs.force_process == 'true')
        run: |
          echo "=== 開始處理Word文檔 ==="
          
          # 設置Python路徑
          export PYTHONPATH="$(pwd):$(pwd)/scripts:$(pwd)/.github/scripts:$PYTHONPATH"
          
          # 構建處理參數
          PROCESS_ARGS="--word-dir word-docs --output-dir blog --assets-dir assets"
          
          if [ "${{ github.event.inputs.force_process }}" = "true" ]; then
            PROCESS_ARGS="$PROCESS_ARGS --force --process-all"
            echo "啟用強制處理模式"
          fi
          
          if [ "${{ github.event.inputs.debug_mode }}" = "true" ]; then
            PROCESS_ARGS="$PROCESS_ARGS --debug"
            echo "啟用調試模式"
          fi
          
          # 嘗試使用主處理腳本
          PROCESSING_SUCCESS=false
          
          if [ -f "main.py" ]; then
            echo "嘗試使用主處理腳本: main.py"
            
            if timeout 600 python main.py $PROCESS_ARGS 2>&1; then
              echo "主處理腳本執行成功"
              PROCESSING_SUCCESS=true
            else
              echo "主處理腳本執行失敗或超時"
              PROCESSING_SUCCESS=false
            fi
          elif [ -f "process.py" ]; then
            echo "嘗試使用備用處理腳本: process.py"
            
            if timeout 600 python process.py $PROCESS_ARGS 2>&1; then
              echo "備用處理腳本執行成功"
              PROCESSING_SUCCESS=true
            else
              echo "備用處理腳本執行失敗"
              PROCESSING_SUCCESS=false
            fi
          else
            echo "未找到主要處理腳本，使用內建處理邏輯"
          fi
          
          # 內建智能處理邏輯
          if [ "$PROCESSING_SUCCESS" = "false" ]; then
            echo "執行內建Word文檔處理邏輯..."
            
            python3 << 'EOF'
          import os
          import json
          import re
          from pathlib import Path
          from datetime import datetime
          
          def extract_theme_from_title(title):
              """從標題提取主題關鍵詞，生成語義化URL"""
              
              # 財稅主題映射表
              theme_mapping = {
                  # 稅務相關
                  '所得稅': 'income-tax',
                  '營業稅': 'business-tax', 
                  '遺產稅': 'estate-tax',
                  '贈與稅': 'gift-tax',
                  '房屋稅': 'house-tax',
                  '地價稅': 'land-tax',
                  '印花稅': 'stamp-tax',
                  '綜合所得稅': 'income-tax',
                  '營所稅': 'corporate-tax',
                  '個人所得稅': 'personal-income-tax',
                  
                  # 保險相關
                  '人壽保險': 'life-insurance',
                  '保險規劃': 'insurance-planning',
                  '保險給付': 'insurance-benefit',
                  '保單': 'insurance-policy',
                  
                  # 會計相關  
                  '會計': 'accounting',
                  '記帳': 'bookkeeping',
                  '財務報表': 'financial-statement',
                  '成本控制': 'cost-control',
                  '審計': 'audit',
                  
                  # 企業相關
                  '公司設立': 'company-setup',
                  '企業營運': 'business-operation',
                  '投資': 'investment',
                  '理財': 'financial-planning',
                  
                  # 文檔類型
                  '指南': 'guide',
                  '攻略': 'tips',
                  '解析': 'analysis',
                  '案例': 'case-study',
                  '注意事項': 'considerations',
                  '實務': 'practice',
                  '流程': 'process',
                  '申報': 'filing'
              }
              
              # 提取關鍵詞
              keywords = []
              title_lower = title.lower()
              
              # 按重要性排序匹配
              matched_terms = []
              for zh_term, en_term in theme_mapping.items():
                  if zh_term in title:
                      matched_terms.append((len(zh_term), zh_term, en_term))
              
              # 按詞長度排序，優先選擇較長的專業詞彙
              matched_terms.sort(reverse=True)
              
              # 選擇前3個最重要的關鍵詞
              for _, zh_term, en_term in matched_terms[:3]:
                  if en_term not in keywords:
                      keywords.append(en_term)
              
              # 如果關鍵詞不足，添加通用關鍵詞
              if len(keywords) < 2:
                  if any(tax in title for tax in ['稅', '報稅', '扣繳']):
                      keywords.append('tax')
                  elif any(acc in title for acc in ['會計', '帳務', '財務']):
                      keywords.append('accounting')
                  elif any(ins in title for ins in ['保險', '保單']):
                      keywords.append('insurance')
                  else:
                      keywords.append('business')
              
              return keywords[:3]  # 限制最多3個關鍵詞
          
          def generate_semantic_url(date_str, title):
              """生成語義化URL"""
              
              # 提取主題關鍵詞
              theme_keywords = extract_theme_from_title(title)
              
              # 構建URL
              url_parts = [date_str] + theme_keywords
              url = '-'.join(url_parts)
              
              # 確保URL長度合理（小於60字符）
              if len(url) > 60:
                  # 保留日期和前兩個關鍵詞
                  url = '-'.join([date_str] + theme_keywords[:2])
              
              return url
          
          def process_word_documents():
              """處理Word文檔並生成HTML"""
              word_dir = Path('word-docs')
              blog_dir = Path('blog')
              blog_dir.mkdir(exist_ok=True)
              
              processed_count = 0
              processed_files = []
              
              if not word_dir.exists():
                  print("word-docs 目錄不存在")
                  return 0, []
              
              # 處理所有Word文檔
              for doc_file in word_dir.glob('*.docx'):
                  if doc_file.name.startswith('~$'):
                      continue
                  
                  try:
                      print(f"處理文檔: {doc_file.name}")
                      
                      # 解析文件名
                      filename = doc_file.stem
                      
                      # 嘗試解析日期和標題
                      date_match = re.match(r'(\d{4}-\d{2}-\d{2})-(.+)', filename)
                      if date_match:
                          date_str, title = date_match.groups()
                          
                          # 驗證日期格式
                          try:
                              datetime.strptime(date_str, '%Y-%m-%d')
                          except ValueError:
                              print(f"無效日期格式: {date_str}")
                              continue
                              
                      else:
                          print(f"無法解析文件名格式: {filename}")
                          # 使用當前日期
                          date_str = datetime.now().strftime('%Y-%m-%d')
                          title = filename
                      
                      # 生成語義化URL
                      url_slug = generate_semantic_url(date_str, title)
                      html_filename = f'{url_slug}.html'
                      html_path = blog_dir / html_filename
                      
                      # 檢查文件是否已存在
                      if html_path.exists():
                          print(f"HTML文件已存在: {html_filename}")
                          processed_files.append(str(doc_file))
                          continue
                      
                      # 判斷主要分類
                      if any(term in title for term in ['稅', '報稅', '所得稅', '營業稅']):
                          category = 'tax'
                          category_name = '稅務相關'
                      elif any(term in title for term in ['保險', '保單']):
                          category = 'insurance'
                          category_name = '保險規劃'
                      elif any(term in title for term in ['會計', '帳務', '財務']):
                          category = 'accounting'
                          category_name = '會計實務'
                      else:
                          category = 'business'
                          category_name = '企業服務'
                      
                      # 生成標籤
                      tags = []
                      theme_keywords = extract_theme_from_title(title)
                      for keyword in theme_keywords:
                          tag_name = keyword.replace('-', ' ').title()
                          tags.append(f'<a class="article-tag" href="/blog.html?tag={keyword}">{tag_name}</a>')
                      
                      tags_html = '\n          '.join(tags) if tags else ''
                      
                      # 創建HTML內容（使用改進的模板）
                      html_content = f'''<!DOCTYPE html>
          <html lang="zh-TW">
          <head>
          <meta charset="utf-8"/>
          <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
          <meta name="description" content="{title} - 霍爾果斯會計師事務所專業服務，提供{category_name}相關諮詢"/>
          <meta name="keywords" content="{category_name}, 霍爾果斯, 會計師, 稅務, 保險, 企業服務"/>
          <meta name="date" content="{date_str}"/>
          <meta name="main-category" content="{category_name}"/>
          <meta name="main-category-code" content="{category}"/>
          <meta name="original-filename" content="{doc_file.name}"/>
          <title>{title} | 霍爾果斯會計師事務所</title>
          <link rel="canonical" href="https://www.horgoscpa.com/blog/{html_filename}"/>
          </head>
          <body>
          <article class="article-card">
          <div class="article-meta">
          <div class="article-date">
          <span class="material-symbols-rounded">calendar_month</span>
          {date_str}
          </div>
          <div class="article-category">
          <span class="material-symbols-rounded">sell</span>
          {category_name}
          </div>
          </div>
          <h1 class="article-title">{title}</h1>
          <div class="article-body">
          <p>本文檔正在處理中，完整內容即將推出。我們的專業團隊正在為您準備最詳細的{category_name}指導。</p>
          <p>如需立即諮詢相關服務，請聯繫霍爾果斯會計師事務所，我們將為您提供專業的解決方案。</p>
          <div class="contact-info">
          <h3>聯繫我們</h3>
          <p>電話：(02) 1234-5678</p>
          <p>Email：info@horgoscpa.com</p>
          </div>
          </div>
          <div class="article-footer">
          <div class="article-tags">
          {tags_html}
          </div>
          </div>
          </article>
          </body>
          </html>'''
                      
                      # 寫入HTML文件
                      with open(html_path, 'w', encoding='utf-8') as f:
                          f.write(html_content)
                      
                      print(f"生成HTML: {doc_file.name} → {html_filename}")
                      processed_count += 1
                      processed_files.append(str(doc_file))
                      
                  except Exception as e:
                      print(f"處理文件 {doc_file.name} 時出錯: {e}")
                      continue
              
              return processed_count, processed_files
          
          try:
              print("開始處理Word文檔...")
              processed_count, processed_files = process_word_documents()
              
              print(f"處理完成，共處理 {processed_count} 個文檔")
              
              # 更新處理記錄
              processed_data = {'files': processed_files}
              processed_files_path = Path('assets/data/processed_files.json')
              
              # 讀取並合併現有記錄
              if processed_files_path.exists():
                  try:
                      with open(processed_files_path, 'r', encoding='utf-8') as f:
                          existing_data = json.load(f)
                          if 'files' in existing_data:
                              all_files = list(set(existing_data['files'] + processed_files))
                              processed_data = {'files': all_files}
                  except Exception as e:
                      print(f"讀取現有處理記錄失敗: {e}")
              
              # 保存處理記錄
              with open(processed_files_path, 'w', encoding='utf-8') as f:
                  json.dump(processed_data, f, ensure_ascii=False, indent=2)
              
              print("Word文檔處理完成")
              
          except Exception as e:
              print(f"Word文檔處理失敗: {e}")
              import traceback
              traceback.print_exc()
          EOF
          fi
          
          # 檢查處理結果
          HTML_COUNT=$(find blog -name "*.html" 2>/dev/null | wc -l)
          
          if [ "$HTML_COUNT" -gt 0 ]; then
            echo "docs_processed=true" >> $GITHUB_OUTPUT
            echo "html_count=$HTML_COUNT" >> $GITHUB_OUTPUT
            echo "✓ 成功處理，共生成 $HTML_COUNT 個HTML文件"
          else
            echo "docs_processed=false" >> $GITHUB_OUTPUT
            echo "html_count=0" >> $GITHUB_OUTPUT
            echo "⚠ 警告：沒有生成HTML文件"
          fi

      - name: 更新影片數據
        id: update-video-data
        run: |
          echo "=== 更新影片數據 ==="
          
          if [ -f ".github/scripts/update_videos.py" ]; then
            echo "執行影片數據更新腳本..."
            export PYTHONPATH="$(pwd):$(pwd)/scripts:$PYTHONPATH"
            
            if python .github/scripts/update_videos.py; then
              echo "影片數據更新成功"
            else
              echo "影片數據更新失敗，使用基本方案"
            fi
          else
            echo "創建基本影片數據..."
          fi
          
          # 確保影片數據文件存在
          python3 << 'EOF'
          import json
          from pathlib import Path
          
          videos_file = Path('assets/data/videos.json')
          if not videos_file.exists():
              videos_data = {
                  "videos": [],
                  "pagination": {
                      "total": 0,
                      "totalPages": 1,
                      "itemsPerPage": 6
                  }
              }
              with open(videos_file, 'w', encoding='utf-8') as f:
                  json.dump(videos_data, f, ensure_ascii=False, indent=2)
              print("創建基本影片數據文件")
          else:
              print("影片數據文件已存在")
          EOF
          
          echo "video_updated=true" >> $GITHUB_OUTPUT

      - name: 生成JSON數據
        id: generate-json-data
        if: |
          steps.process-documents.outputs.docs_processed == 'true' || 
          github.event.inputs.update_json == 'true' || 
          github.event.inputs.update_json == '' ||
          github.event_name != 'workflow_dispatch'
        run: |
          echo "=== 生成JSON數據 ==="
          
          export PYTHONPATH="$(pwd):$(pwd)/scripts:$(pwd)/.github/scripts:$PYTHONPATH"
          
          # 嘗試使用專用JSON生成器
          if [ -f ".github/scripts/update_blog_json.py" ]; then
            echo "使用專用JSON生成器..."
            if python .github/scripts/update_blog_json.py; then
              echo "專用JSON生成器執行成功"
            else
              echo "專用JSON生成器執行失敗，使用內建方案"
            fi
          elif [ -f "scripts/json_generator.py" ]; then
            echo "使用核心JSON生成器..."
            python3 << 'EOF'
          import sys
          sys.path.insert(0, './scripts')
          
          try:
              from json_generator import JsonGenerator
              generator = JsonGenerator('assets/data')
              result = generator.generate_all_json()
              print('核心JSON生成器執行成功')
          except Exception as e:
              print(f'核心JSON生成器執行失敗: {e}')
          EOF
          else
            echo "使用內建JSON生成邏輯..."
          fi
          
          # 內建JSON生成邏輯
          python3 << 'EOF'
          import json
          import re
          from pathlib import Path
          from datetime import datetime
          from collections import defaultdict
          
          def generate_blog_data():
              """生成完整的博客數據"""
              
              blog_dir = Path('blog')
              posts = []
              
              if not blog_dir.exists():
                  print("blog目錄不存在")
                  return
              
              # 掃描所有HTML文件
              html_files = list(blog_dir.glob('*.html'))
              print(f"發現 {len(html_files)} 個HTML文件")
              
              for html_file in html_files:
                  try:
                      # 從HTML文件提取信息
                      with open(html_file, 'r', encoding='utf-8') as f:
                          content = f.read()
                      
                      # 使用正則表達式提取meta信息
                      title_match = re.search(r'<title>([^|]+)', content)
                      date_match = re.search(r'<meta name="date" content="([^"]+)"', content)
                      desc_match = re.search(r'<meta name="description" content="([^"]+)"', content)
                      category_match = re.search(r'<meta name="main-category-code" content="([^"]+)"', content)
                      category_name_match = re.search(r'<meta name="main-category" content="([^"]+)"', content)
                      
                      # 提取基本信息
                      title = title_match.group(1).strip() if title_match else html_file.stem
                      date_str = date_match.group(1) if date_match else datetime.now().strftime('%Y-%m-%d')
                      description = desc_match.group(1) if desc_match else f"{title} 的詳細說明"
                      category = category_match.group(1) if category_match else 'business'
                      category_name = category_name_match.group(1) if category_name_match else '企業服務'
                      
                      # 從HTML中提取標籤
                      tags = []
                      tag_matches = re.findall(r'<a class="article-tag" href="[^"]*tag=([^"]+)"[^>]*>([^<]+)</a>', content)
                      for tag_slug, tag_name in tag_matches:
                          tags.append({"slug": tag_slug, "name": tag_name})
                      
                      # 構建文章數據
                      post = {
                          "title": title,
                          "url": f"/blog/{html_file.name}",
                          "date": date_str,
                          "summary": description,
                          "category": category,
                          "category_name": category_name,
                          "tags": tags,
                          "image": "/assets/images/blog/default.jpg",
                          "is_series": False
                      }
                      
                      posts.append(post)
                      
                  except Exception as e:
                      print(f"處理HTML文件 {html_file} 時出錯: {e}")
              
              # 按日期排序
              posts.sort(key=lambda x: x['date'], reverse=True)
              
              # 統計分類和標籤
              category_counts = defaultdict(int)
              tag_counts = defaultdict(int)
              
              for post in posts:
                  category_counts[post['category']] += 1
                  for tag in post['tags']:
                      tag_counts[tag['slug']] += 1
              
              # 生成分類數據
              categories = [
                  {"slug": "tax", "name": "稅務相關", "count": category_counts.get('tax', 0)},
                  {"slug": "insurance", "name": "保險規劃", "count": category_counts.get('insurance', 0)},
                  {"slug": "accounting", "name": "會計實務", "count": category_counts.get('accounting', 0)},
                  {"slug": "business", "name": "企業服務", "count": category_counts.get('business', 0)}
              ]
              
              # 生成標籤數據
              tags_data = []
              for tag_slug, count in tag_counts.items():
                  tag_name = tag_slug.replace('-', ' ').title()
                  tags_data.append({"slug": tag_slug, "name": tag_name, "count": count})
              
              # 生成完整博客數據
              blog_data = {
                  "posts": posts,
                  "pagination": {
                      "total_posts": len(posts),
                      "total_pages": max(1, (len(posts) + 9) // 10),
                      "items_per_page": 10
                  },
                  "categories": categories,
                  "tags": tags_data,
                  "series": {},
                  "series_list": [],
                  "generated_time": datetime.now().isoformat()
              }
              
              # 保存各種JSON文件
              assets_data = Path('assets/data')
              assets_data.mkdir(parents=True, exist_ok=True)
              
              json_files = {
                  'blog_posts.json': {"posts": posts},
                  'blog-posts.json': {"posts": posts},
                  'blog-index.json': blog_data,
                  'latest-posts.json': posts[:3],
                  'series.json': {"series": {}, "series_list": []},
                  'categories.json': {"categories": categories},
                  'tags.json': {"tags": tags_data}
              }
              
              for filename, data in json_files.items():
                  file_path = assets_data / filename
                  with open(file_path, 'w', encoding='utf-8') as f:
                      json.dump(data, f, ensure_ascii=False, indent=2)
                  print(f"生成JSON文件: {filename}")
              
              print(f"JSON數據生成完成，共處理 {len(posts)} 篇文章")
              return len(posts)
          
          try:
              post_count = generate_blog_data()
              print(f"JSON數據生成成功，共 {post_count} 篇文章")
          except Exception as e:
              print(f"JSON數據生成失敗: {e}")
              import traceback
              traceback.print_exc()
          EOF
          
          echo "json_updated=true" >> $GITHUB_OUTPUT

      - name: 生成網站地圖
        id: generate-sitemap
        if: steps.generate-json-data.outputs.json_updated == 'true'
        run: |
          echo "=== 生成網站地圖 ==="
          
          if [ -f ".github/scripts/generate_sitemap.py" ]; then
            echo "使用專用網站地圖生成器..."
            export PYTHONPATH="$(pwd):$(pwd)/scripts:$PYTHONPATH"
            
            if python .github/scripts/generate_sitemap.py; then
              echo "專用網站地圖生成器執行成功"
            else
              echo "專用網站地圖生成器執行失敗，使用內建方案"
            fi
          else
            echo "使用內建網站地圖生成邏輯..."
          fi
          
          # 內建網站地圖生成
          python3 << 'EOF'
          from datetime import datetime
          from pathlib import Path
          import json
          
          def generate_sitemap():
              """生成網站地圖"""
              
              today = datetime.now().strftime('%Y-%m-%d')
              
              # 基本sitemap結構
              sitemap_content = f'''<?xml version="1.0" encoding="UTF-8"?>
          <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
            <url>
              <loc>https://www.horgoscpa.com/</loc>
              <lastmod>{today}</lastmod>
              <changefreq>daily</changefreq>
              <priority>1.0</priority>
            </url>
            <url>
              <loc>https://www.horgoscpa.com/blog.html</loc>
              <lastmod>{today}</lastmod>
              <changefreq>daily</changefreq>
              <priority>0.9</priority>
            </url>
            <url>
              <loc>https://www.horgoscpa.com/services.html</loc>
              <lastmod>{today}</lastmod>
              <changefreq>monthly</changefreq>
              <priority>0.9</priority>
            </url>
            <url>
              <loc>https://www.horgoscpa.com/contact.html</loc>
              <lastmod>{today}</lastmod>
              <changefreq>monthly</changefreq>
              <priority>0.8</priority>
            </url>'''
              
              # 添加博客文章
              blog_dir = Path('blog')
              if blog_dir.exists():
                  for html_file in blog_dir.glob('*.html'):
                      sitemap_content += f'''
            <url>
              <loc>https://www.horgoscpa.com/blog/{html_file.name}</loc>
              <lastmod>{today}</lastmod>
              <changefreq>weekly</changefreq>
              <priority>0.8</priority>
            </url>'''
              
              sitemap_content += '''
          </urlset>'''
              
              # 保存sitemap
              with open('sitemap.xml', 'w', encoding='utf-8') as f:
                  f.write(sitemap_content)
              
              print('網站地圖生成完成')
              
              # 統計信息
              url_count = sitemap_content.count('<url>')
              print(f'包含 {url_count} 個URL')
              
              return True
          
          try:
              generate_sitemap()
          except Exception as e:
              print(f'網站地圖生成失敗: {e}')
              import traceback
              traceback.print_exc()
          EOF
          
          echo "sitemap_generated=true" >> $GITHUB_OUTPUT

      - name: 移動已處理文檔
        id: move-processed-files
        if: steps.process-documents.outputs.docs_processed == 'true'
        run: |
          echo "=== 移動已處理的Word文檔 ==="
          
          # 確保目錄存在
          mkdir -p word-docs/processed
          
          if [ -f ".github/scripts/move_processed_files.py" ]; then
            echo "使用專用文件移動腳本..."
            export PYTHONPATH="$(pwd):$(pwd)/scripts:$PYTHONPATH"
            
            if python .github/scripts/move_processed_files.py; then
              echo "專用文件移動腳本執行成功"
            else
              echo "專用文件移動腳本執行失敗，使用內建方案"
            fi
          else
            echo "使用內建文件移動邏輯..."
          fi
          
          # 內建文件移動邏輯
          python3 << 'EOF'
          import json
          import shutil
          from pathlib import Path
          
          def move_processed_files():
              """移動已處理的Word文檔"""
              
              try:
                  # 讀取已處理文件記錄
                  processed_files_path = Path('assets/data/processed_files.json')
                  processed_files = {'files': []}
                  
                  if processed_files_path.exists():
                      with open(processed_files_path, 'r', encoding='utf-8') as f:
                          processed_files = json.load(f)
                  
                  if not processed_files.get('files'):
                      print('沒有已處理的文件需要移動')
                      return 0
                  
                  # 移動文件
                  word_dir = Path('word-docs')
                  processed_dir = Path('word-docs/processed')
                  processed_dir.mkdir(exist_ok=True)
                  
                  moved_count = 0
                  
                  for file_path_str in processed_files['files']:
                      file_path = Path(file_path_str)
                      
                      if file_path.exists() and file_path.parent == word_dir:
                          dest_path = processed_dir / file_path.name
                          
                          try:
                              if not dest_path.exists():
                                  shutil.move(str(file_path), str(dest_path))
                                  print(f'移動文件: {file_path.name}')
                                  moved_count += 1
                              else:
                                  # 如果目標已存在，刪除源文件
                                  file_path.unlink()
                                  print(f'刪除重複文件: {file_path.name}')
                                  moved_count += 1
                          except Exception as e:
                              print(f'移動文件失敗 {file_path.name}: {e}')
                  
                  print(f'共移動 {moved_count} 個文件')
                  return moved_count
                  
              except Exception as e:
                  print(f'移動文件過程出錯: {e}')
                  return 0
          
          moved_count = move_processed_files()
          print(f'文件移動完成，共處理 {moved_count} 個文件')
          EOF
          
          echo "files_moved=true" >> $GITHUB_OUTPUT

      - name: 提交所有更改
        if: |
          steps.process-documents.outputs.docs_processed == 'true' || 
          steps.generate-json-data.outputs.json_updated == 'true' ||
          steps.generate-sitemap.outputs.sitemap_generated == 'true' ||
          steps.move-processed-files.outputs.files_moved == 'true'
        run: |
          echo "=== 提交所有更改 ==="
          
          # 檢查Git狀態
          echo "檢查Git狀態..."
          git status --porcelain
          
          # 添加所有更改
          git add -A
          
          # 檢查是否有更改需要提交
          if git diff --cached --quiet; then
            echo "沒有更改需要提交"
          else
            # 構建提交信息
            TIMESTAMP=$(date +'%Y-%m-%d %H:%M:%S')
            COMMIT_MSG="自動化處理更新 [$TIMESTAMP]"
            
            # 添加詳細信息
            CHANGES=()
            
            if [ "${{ steps.process-documents.outputs.docs_processed }}" = "true" ]; then
              HTML_COUNT="${{ steps.process-documents.outputs.html_count }}"
              CHANGES+=("處理Word文檔(${HTML_COUNT}個)")
            fi
            
            if [ "${{ steps.generate-json-data.outputs.json_updated }}" = "true" ]; then
              CHANGES+=("更新JSON數據")
            fi
            
            if [ "${{ steps.generate-sitemap.outputs.sitemap_generated }}" = "true" ]; then
              CHANGES+=("生成網站地圖")
            fi
            
            if [ "${{ steps.move-processed-files.outputs.files_moved }}" = "true" ]; then
              CHANGES+=("移動已處理文檔")
            fi
            
            # 組合提交信息
            if [ ${#CHANGES[@]} -gt 0 ]; then
              IFS=', '
              COMMIT_MSG="${COMMIT_MSG} - ${CHANGES[*]}"
            fi
            
            echo "提交信息: $COMMIT_MSG"
            
            # 提交更改
            git commit -m "$COMMIT_MSG"
            
            # 推送更改（帶重試機制）
            echo "推送更改到遠程倉庫..."
            MAX_RETRIES=3
            RETRY_COUNT=0
            
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if git push origin ${{ github.ref_name }}; then
                echo "✓ 成功推送更改"
                break
              else
                RETRY_COUNT=$((RETRY_COUNT + 1))
                echo "✗ 推送失敗，第 $RETRY_COUNT 次重試..."
                
                if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
                  echo "推送失敗，已達最大重試次數"
                  exit 1
                else
                  echo "等待5秒後重試..."
                  sleep 5
                  
                  # 嘗試拉取最新更改
                  git pull --rebase origin ${{ github.ref_name }} || true
                fi
              fi
            done
          fi

      - name: 輸出執行摘要
        if: always()
        run: |
          echo "=================================================="
          echo "           自動化處理執行摘要"
          echo "=================================================="
          echo "執行時間: $(date +'%Y-%m-%d %H:%M:%S')"
          echo "觸發方式: ${{ github.event_name }}"
          echo "執行分支: ${{ github.ref_name }}"
          
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo ""
            echo "手動觸發參數:"
            echo "  ├─ 處理Word文檔: ${{ github.event.inputs.process_word || 'true' }}"
            echo "  ├─ 更新JSON文件: ${{ github.event.inputs.update_json || 'true' }}"
            echo "  ├─ 強制處理: ${{ github.event.inputs.force_process || 'false' }}"
            echo "  └─ 調試模式: ${{ github.event.inputs.debug_mode || 'false' }}"
          fi
          
          echo ""
          echo "處理結果:"
          echo "  ├─ 文檔檢查: ${{ steps.check-documents.outputs.has_docs == 'true' && '✓' || '✗' }} (發現 ${{ steps.check-documents.outputs.doc_count || '0' }} 個)"
          echo "  ├─ 文檔處理: ${{ steps.process-documents.outputs.docs_processed == 'true' && '✓' || '✗' }} (生成 ${{ steps.process-documents.outputs.html_count || '0' }} 個HTML)"
          echo "  ├─ 影片數據: ${{ steps.update-video-data.outputs.video_updated == 'true' && '✓' || '✗' }}"
          echo "  ├─ JSON生成: ${{ steps.generate-json-data.outputs.json_updated == 'true' && '✓' || '✗' }}"
          echo "  ├─ 網站地圖: ${{ steps.generate-sitemap.outputs.sitemap_generated == 'true' && '✓' || '✗' }}"
          echo "  └─ 文件移動: ${{ steps.move-processed-files.outputs.files_moved == 'true' && '✓' || '✗' }}"
          
          echo ""
          echo "文件統計:"
          echo "  ├─ HTML文件: $(find blog -name "*.html" 2>/dev/null | wc -l) 個"
          echo "  ├─ JSON文件: $(find assets/data -name "*.json" 2>/dev/null | wc -l) 個"
          echo "  ├─ 待處理Word文檔: $(find word-docs -maxdepth 1 -name "*.docx" ! -name "~$*" 2>/dev/null | wc -l) 個"
          echo "  └─ 已處理Word文檔: $(find word-docs/processed -name "*.docx" 2>/dev/null | wc -l) 個"
          
          echo ""
          echo "系統狀態:"
          echo "  ├─ 磁盤使用: $(df -h . | tail -1 | awk '{print $5}') (已使用)"
          echo "  ├─ 內存使用: $(free -h | grep Mem: | awk '{print $3"/"$2}')"
          echo "  └─ 執行時長: $SECONDS 秒"
          
          echo ""
          echo "=================================================="

      - name: 清理臨時文件
        if: always()
        run: |
          echo "=== 清理臨時文件 ==="
          
          # 清理Python緩存
          find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
          find . -name "*.pyc" -delete 2>/dev/null || true
          find . -name "*.pyo" -delete 2>/dev/null || true
          
          # 清理Word臨時文件
          find . -name "~$*.docx" -delete 2>/dev/null || true
          find . -name "~$*.doc" -delete 2>/dev/null || true
          
          # 清理系統臨時文件
          find /tmp -name "tmp*" -user $(whoami) -delete 2>/dev/null || true
          
          # 清理舊日誌文件（保留最近7天）
          if [ -d "logs" ]; then
            find logs -name "*.log" -mtime +7 -delete 2>/dev/null || true
            echo "清理舊日誌文件完成"
          fi
          
          # 顯示清理後的磁盤使用情況
          echo "清理後磁盤使用情況: $(df -h . | tail -1 | awk '{print $5}')"
          
          echo "臨時文件清理完成"