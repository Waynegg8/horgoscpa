# Cron Job #3：資料庫備份

**執行時間：** 每天凌晨 03:00  
**Cron 表達式：** `0 3 * * *`  
**檔案位置：** `/worker/src/cron/backup.ts`  
**最後更新：** 2025年10月27日

---

## 功能概述

每天自動備份 Cloudflare D1 資料庫到 R2 物件儲存，保留最近 30 天的備份。

---

## 執行邏輯

```typescript
export async function backupDatabase(env) {
  const today = new Date();
  const dateStr = today.toISOString().split('T')[0]; // YYYY-MM-DD
  
  // 1. 匯出所有表格資料為 SQL
  const tables = [
    'Users', 'Clients', 'TimeLogs', 'ActiveTasks', 
    'ActiveTaskStages', 'ClientServices', 'SOPDocuments',
    'ModulePermissions', 'Holidays', 'LeaveTypes',
    'OvertimeRates', 'AnnualLeaveRules', 'OtherLeaveRules',
    'ServiceFrequencyTypes', 'CompensatoryLeaveBalance'
  ];
  
  let sqlDump = `-- Database Backup: ${dateStr}\n\n`;
  
  for (const table of tables) {
    const rows = await env.DB.prepare(`SELECT * FROM ${table}`).all();
    
    for (const row of rows.results) {
      const columns = Object.keys(row).join(', ');
      const values = Object.values(row)
        .map(v => typeof v === 'string' ? `'${v}'` : v)
        .join(', ');
      
      sqlDump += `INSERT INTO ${table} (${columns}) VALUES (${values});\n`;
    }
  }
  
  // 2. 上傳到 R2
  const backupKey = `backups/db_${dateStr}.sql`;
  await env.R2_BUCKET.put(backupKey, sqlDump);
  
  // 3. 清理 30 天前的備份
  const thirtyDaysAgo = new Date(today);
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
  const oldBackupKey = `backups/db_${thirtyDaysAgo.toISOString().split('T')[0]}.sql`;
  
  await env.R2_BUCKET.delete(oldBackupKey);
  
  return { 
    message: `備份已儲存至 ${backupKey}`,
    size: new Blob([sqlDump]).size
  };
}
```

---

## 備份策略

### 保留政策
- **每日備份**：保留最近 30 天
- **格式**：SQL 格式
- **儲存位置**：R2 Bucket (`backups/` 目錄)

### 恢復流程
1. 從 R2 下載備份檔案
2. 執行 SQL 語句重建資料表
3. 驗證資料完整性

---

## 相關文檔

- [架構設計](../架構設計.md)
- [資料庫設計](../資料庫設計.md)

---

**最後更新：** 2025年10月27日



**執行時間：** 每天凌晨 03:00  
**Cron 表達式：** `0 3 * * *`  
**檔案位置：** `/worker/src/cron/backup.ts`  
**最後更新：** 2025年10月27日

---

## 功能概述

每天自動備份 Cloudflare D1 資料庫到 R2 物件儲存，保留最近 30 天的備份。

---

## 執行邏輯

```typescript
export async function backupDatabase(env) {
  const today = new Date();
  const dateStr = today.toISOString().split('T')[0]; // YYYY-MM-DD
  
  // 1. 匯出所有表格資料為 SQL
  const tables = [
    'Users', 'Clients', 'TimeLogs', 'ActiveTasks', 
    'ActiveTaskStages', 'ClientServices', 'SOPDocuments',
    'ModulePermissions', 'Holidays', 'LeaveTypes',
    'OvertimeRates', 'AnnualLeaveRules', 'OtherLeaveRules',
    'ServiceFrequencyTypes', 'CompensatoryLeaveBalance'
  ];
  
  let sqlDump = `-- Database Backup: ${dateStr}\n\n`;
  
  for (const table of tables) {
    const rows = await env.DB.prepare(`SELECT * FROM ${table}`).all();
    
    for (const row of rows.results) {
      const columns = Object.keys(row).join(', ');
      const values = Object.values(row)
        .map(v => typeof v === 'string' ? `'${v}'` : v)
        .join(', ');
      
      sqlDump += `INSERT INTO ${table} (${columns}) VALUES (${values});\n`;
    }
  }
  
  // 2. 上傳到 R2
  const backupKey = `backups/db_${dateStr}.sql`;
  await env.R2_BUCKET.put(backupKey, sqlDump);
  
  // 3. 清理 30 天前的備份
  const thirtyDaysAgo = new Date(today);
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
  const oldBackupKey = `backups/db_${thirtyDaysAgo.toISOString().split('T')[0]}.sql`;
  
  await env.R2_BUCKET.delete(oldBackupKey);
  
  return { 
    message: `備份已儲存至 ${backupKey}`,
    size: new Blob([sqlDump]).size
  };
}
```

---

## 備份策略

### 保留政策
- **每日備份**：保留最近 30 天
- **格式**：SQL 格式
- **儲存位置**：R2 Bucket (`backups/` 目錄)

### 恢復流程
1. 從 R2 下載備份檔案
2. 執行 SQL 語句重建資料表
3. 驗證資料完整性

---

## 相關文檔

- [架構設計](../架構設計.md)
- [資料庫設計](../資料庫設計.md)

---

**最後更新：** 2025年10月27日



