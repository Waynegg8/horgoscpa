# 03 - 資料庫備份 (Database Backup)

**Cron Job名稱：** Database Backup  
**執行頻率：** 每天凌晨 3:00 AM  
**Cron表達式：** `0 3 * * *`  
**最後更新：** 2025年10月27日

---

## 功能概述

每日自動將 Cloudflare D1 資料庫完整匯出為 SQL 檔案，並上傳至 R2 儲存桶，作為災難恢復機制。

**目的：**
- 防止資料遺失
- 提供時間點恢復能力
- 符合資料保護規範

---

## 執行邏輯

### 步驟 1：匯出資料庫

```typescript
import { D1Database, R2Bucket } from '@cloudflare/workers-types';

async function exportDatabase(db: D1Database): Promise<string> {
  const tables = [
    'Users', 'Clients', 'TimeLogs', 'ActiveTasks', 'ActiveTaskStages',
    'LeaveApplications', 'LeaveBalances', 'LeaveTypes', 'Holidays',
    'OvertimeRates', 'ServiceTemplates', 'ClientServices',
    'TaskTemplates', 'TaskStageTemplates', 'SOPDocuments',
    'KnowledgeBase', 'ModulePermissions', 'SystemSettings'
  ];
  
  let sqlDump = '';
  
  // 添加文件頭
  sqlDump += `-- Database Backup\n`;
  sqlDump += `-- Generated: ${new Date().toISOString()}\n`;
  sqlDump += `-- Source: Cloudflare D1\n\n`;
  
  // 匯出每個表格
  for (const table of tables) {
    sqlDump += `\n-- Table: ${table}\n`;
    sqlDump += await exportTable(db, table);
  }
  
  return sqlDump;
}
```

---

### 步驟 2：匯出單個表格

```typescript
async function exportTable(db: D1Database, tableName: string): Promise<string> {
  // 獲取表結構
  const schema = await db.prepare(`
    SELECT sql FROM sqlite_master 
    WHERE type='table' AND name=?
  `).bind(tableName).first();
  
  if (!schema) {
    return `-- Table ${tableName} not found\n`;
  }
  
  let sql = `DROP TABLE IF EXISTS ${tableName};\n`;
  sql += `${schema.sql};\n\n`;
  
  // 獲取所有資料
  const rows = await db.prepare(`SELECT * FROM ${tableName}`).all();
  
  if (rows.results.length === 0) {
    return sql + `-- No data in ${tableName}\n`;
  }
  
  // 生成 INSERT 語句
  const columns = Object.keys(rows.results[0]);
  sql += `INSERT INTO ${tableName} (${columns.join(', ')}) VALUES\n`;
  
  const values = rows.results.map(row => {
    const vals = columns.map(col => {
      const val = row[col];
      if (val === null) return 'NULL';
      if (typeof val === 'string') return `'${val.replace(/'/g, "''")}'`;
      return val;
    });
    return `  (${vals.join(', ')})`;
  });
  
  sql += values.join(',\n');
  sql += ';\n';
  
  return sql;
}
```

---

### 步驟 3：上傳至 R2

```typescript
async function uploadToR2(
  r2: R2Bucket,
  sqlDump: string,
  timestamp: Date
): Promise<string> {
  const year = timestamp.getFullYear();
  const month = (timestamp.getMonth() + 1).toString().padStart(2, '0');
  const day = timestamp.getDate().toString().padStart(2, '0');
  
  const filename = `backups/${year}/${month}/db_${year}-${month}-${day}.sql`;
  
  // 上傳到 R2
  await r2.put(filename, sqlDump, {
    httpMetadata: {
      contentType: 'application/sql',
    },
    customMetadata: {
      timestamp: timestamp.toISOString(),
      size: sqlDump.length.toString()
    }
  });
  
  console.log(`✓ Backup uploaded: ${filename} (${(sqlDump.length / 1024 / 1024).toFixed(2)} MB)`);
  
  return filename;
}
```

**R2 儲存結構：**
```
backups/
├── 2024/
│   ├── 01/
│   │   ├── db_2024-01-01.sql
│   │   ├── db_2024-01-02.sql
│   │   └── ...
│   ├── 02/
│   └── ...
└── 2025/
    └── ...
```

---

### 步驟 4：清理舊備份

```typescript
async function cleanupOldBackups(r2: R2Bucket, retentionDays: number = 30): Promise<void> {
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - retentionDays);
  
  // 列出所有備份
  const list = await r2.list({ prefix: 'backups/' });
  
  let deletedCount = 0;
  
  for (const object of list.objects) {
    // 從檔案名取得日期：backups/2024/01/db_2024-01-01.sql
    const match = object.key.match(/db_(\d{4}-\d{2}-\d{2})\.sql$/);
    if (!match) continue;
    
    const fileDate = new Date(match[1]);
    
    if (fileDate < cutoffDate) {
      await r2.delete(object.key);
      console.log(`✓ Deleted old backup: ${object.key}`);
      deletedCount++;
    }
  }
  
  console.log(`Cleaned up ${deletedCount} old backups (retention: ${retentionDays} days)`);
}
```

---

## 完整執行流程

```typescript
export async function databaseBackup(env: Env): Promise<Response> {
  const startTime = Date.now();
  
  try {
    console.log('Starting database backup...');
    
    // 1. 匯出資料庫
    const sqlDump = await exportDatabase(env.DB);
    
    // 2. 壓縮（可選）
    const compressed = await compress(sqlDump);
    
    // 3. 上傳到 R2
    const filename = await uploadToR2(env.BACKUP_BUCKET, compressed, new Date());
    
    // 4. 清理舊備份
    await cleanupOldBackups(env.BACKUP_BUCKET, 30);
    
    // 5. 記錄成功
    const duration = Date.now() - startTime;
    const metrics = {
      filename,
      size: compressed.length,
      duration,
      timestamp: new Date().toISOString()
    };
    
    await env.DB.prepare(`
      INSERT INTO AuditLogs (action, details, created_at)
      VALUES ('database_backup', ?, datetime('now'))
    `).bind(JSON.stringify(metrics)).run();
    
    console.log(`Backup completed in ${duration}ms`);
    
    return new Response(JSON.stringify({ success: true, ...metrics }), {
      headers: { 'Content-Type': 'application/json' }
    });
    
  } catch (error) {
    console.error('Backup failed:', error);
    
    // 記錄失敗
    await env.DB.prepare(`
      INSERT INTO AuditLogs (action, details, created_at)
      VALUES ('database_backup_failed', ?, datetime('now'))
    `).bind(error.message).run();
    
    return new Response(JSON.stringify({ success: false, error: error.message }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}
```

---

## 資料壓縮（可選）

```typescript
import { gzip } from 'pako';  // 或使用其他壓縮庫

async function compress(data: string): Promise<Uint8Array> {
  const encoder = new TextEncoder();
  const bytes = encoder.encode(data);
  const compressed = gzip(bytes);
  
  console.log(`Original: ${(bytes.length / 1024 / 1024).toFixed(2)} MB`);
  console.log(`Compressed: ${(compressed.length / 1024 / 1024).toFixed(2)} MB`);
  console.log(`Ratio: ${((1 - compressed.length / bytes.length) * 100).toFixed(1)}%`);
  
  return compressed;
}
```

**壓縮效果：**
- SQL 文件通常可壓縮 70-80%
- 10MB SQL → 2-3MB gzip
- 節省 R2 儲存成本

---

## 恢復資料

### 手動恢復

```bash
# 1. 從 R2 下載備份
wrangler r2 object get BUCKET_NAME/backups/2024/01/db_2024-01-01.sql --file=backup.sql

# 2. 解壓縮（如果有壓縮）
gunzip backup.sql.gz

# 3. 匯入到 D1
wrangler d1 execute DB_NAME --file=backup.sql
```

### 自動恢復（API）

```typescript
app.post('/api/v1/admin/restore-backup', requireAdmin, async (c) => {
  const { filename } = await c.req.json();
  
  // 從 R2 下載
  const backup = await c.env.BACKUP_BUCKET.get(filename);
  if (!backup) {
    return c.json({ success: false, error: 'Backup not found' }, 404);
  }
  
  const sqlContent = await backup.text();
  
  // 執行 SQL（需要分批執行）
  const statements = sqlContent.split(';\n').filter(s => s.trim());
  
  for (const stmt of statements) {
    await c.env.DB.prepare(stmt).run();
  }
  
  return c.json({ success: true, restored: statements.length });
});
```

---

## 監控與告警

### 備份失敗告警

```typescript
if (backupFailed) {
  await sendAlert({
    to: 'admin@firm.com',
    subject: '🚨 資料庫備份失敗',
    body: `
      時間：${new Date().toISOString()}
      錯誤：${error.message}
      
      請立即檢查備份系統。
    `
  });
}
```

### 備份成功通知（每週）

```typescript
// 每週一發送上週備份報告
if (today.getDay() === 1) {
  const lastWeekBackups = await listBackupsLastWeek();
  
  await sendReport({
    to: 'admin@firm.com',
    subject: '📊 每週備份報告',
    body: `
      上週成功備份：${lastWeekBackups.length} 次
      平均大小：${avgSize} MB
      總儲存：${totalSize} MB
    `
  });
}
```

---

## 效能優化

### 增量備份（進階）

```typescript
// 只備份有變更的表格
const lastBackupTime = await getLastBackupTime();

for (const table of tables) {
  const hasChanges = await db.prepare(`
    SELECT COUNT(*) as count FROM ${table}
    WHERE updated_at > ?
  `).bind(lastBackupTime).first();
  
  if (hasChanges.count > 0) {
    await exportTable(db, table);
  } else {
    console.log(`Skipping ${table} (no changes)`);
  }
}
```

---

## 安全性考量

### 加密備份（建議）

```typescript
import { encrypt } from './crypto';

// 加密 SQL 內容
const encrypted = await encrypt(sqlDump, env.BACKUP_ENCRYPTION_KEY);

await r2.put(filename, encrypted, {
  customMetadata: {
    encrypted: 'true',
    algorithm: 'AES-256-GCM'
  }
});
```

### 訪問控制

```typescript
// R2 Bucket 設定
// - 私有訪問（不公開）
// - 只有 Worker 可訪問
// - 管理員 API 需要驗證
```

---

## 相關文檔

- [部署指南：環境設定](../部署指南/環境設定.md)
- [Cloudflare R2 文檔](https://developers.cloudflare.com/r2/)

---

**最後更新：** 2025年10月27日  
**文檔版本：** 2.0（模塊化重組版）

