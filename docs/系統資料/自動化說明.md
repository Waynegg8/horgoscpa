# 自動化說明

**系統自動執行的任務**

---

## ⏰ 定時任務（Cron Jobs）

### 1. 任務自動生成
**執行時間：** 每月 1 日 00:00

**功能：**
```
1. 查詢所有客戶服務（ClientServices）
2. 檢查 trigger_months 是否包含當前月份
3. 根據任務模板自動生成任務
4. 設定到期日期
5. 分配給負責員工
```

---

### 2. 逾期任務檢測
**執行時間：** 每天 09:00

**功能：**
```
1. 查詢所有未完成的任務
2. 檢查 due_date 是否已過
3. 標記為逾期
4. （可選）發送提醒通知
```

---

### 3. 特休年初更新（累積制）
**執行時間：** 每年 1月1日 00:00  
**Cron表達式：** `0 0 1 1 *`

**功能：**
```
1. 計算每位員工今年應得特休（依年資）
2. 累積去年剩餘特休（不歸零）⭐
3. 創建今年度特休餘額記錄
4. 記錄執行狀態到 CronJobExecutions 表
5. 如果失敗，通知管理員
```

**冪等性保護：**
- 使用 CronJobExecutions 表記錄執行狀態
- 同一日期只允許執行一次（UNIQUE索引）
- 支援手動觸發補救

**詳細實作：** [假期管理-完整規格.md](../開發指南/假期管理-完整規格.md) 第482行

---

### 4. 補休到期轉換
**執行時間：** 每月 1日 00:00（處理上月到期補休）  
**Cron表達式：** `0 0 1 * *`

**功能：**
```
1. 查詢上月最後一天到期的補休
2. 計算未使用時數
3. 按原始費率轉換為加班費
4. 記錄到薪資系統（當月薪資）
5. 更新補休狀態為 'converted'
6. 通知員工
```

**詳細實作：** [工時管理-完整規格.md](../開發指南/工時管理-完整規格.md) 第554行

---

### 5. 工時填寫提醒
**執行時間：** 每天 08:30（週一到週五）  
**Cron表達式：** `30 8 * * 1-5`

**功能：**
```
1. 檢查所有員工昨天是否有填工時
2. 如果沒填，創建兩筆提醒：
   - 通知該員工本人（「您昨天的工時尚未填寫」）
   - 通知管理員（「員工A的11/26工時尚未填寫」）
3. 在儀表板顯示提醒
4. 自動消失：一旦填寫工時，提醒立即移除 ⭐
```

**排除條件：**
- 週末不檢查（週六日可能不上班）
- 國定假日不檢查
- 已有請假記錄的日期不檢查
- 已有提醒的日期不重複創建

**詳細實作：**
```typescript
// Cron Job: 每天 08:30 執行（週一到週五）
async function checkMissingTimesheets() {
  const yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);
  const yesterdayStr = yesterday.toISOString().split('T')[0];
  
  // ⭐ 檢查是否為工作日（考慮補班日）
  const dayOfWeek = yesterday.getDay();
  
  // 先查詢是否有特殊日期設定
  const holiday = await db.prepare(`
    SELECT is_national_holiday, is_makeup_workday 
    FROM Holidays 
    WHERE holiday_date = ?
  `).bind(yesterdayStr).first();
  
  // 判斷是否應該檢查工時
  let shouldCheck = true;
  
  if (dayOfWeek === 0 || dayOfWeek === 6) {
    // 週末：預設不檢查
    shouldCheck = false;
    
    // 但如果是補班日，要檢查 ⭐
    if (holiday?.is_makeup_workday) {
      shouldCheck = true;
    }
  }
  
  // 如果是國定假日（且非補班日），不檢查
  if (holiday?.is_national_holiday && !holiday?.is_makeup_workday) {
    shouldCheck = false;
  }
  
  if (!shouldCheck) {
    return;  // 不檢查工時
  }
  
  // 查詢所有員工
  const users = await db.prepare(`
    SELECT user_id, name FROM Users WHERE is_deleted = 0
  `).all();
  
  const missingUsers = [];
  
  for (const user of users.results) {
    // 檢查昨天是否有工時記錄
    const timelog = await db.prepare(`
      SELECT * FROM TimeLogs
      WHERE user_id = ? AND work_date = ? AND is_deleted = 0
    `).bind(user.user_id, yesterdayStr).first();
    
    // 檢查是否有請假記錄
    const leave = await db.prepare(`
      SELECT * FROM LeaveApplications
      WHERE user_id = ? 
        AND start_date <= ? 
        AND end_date >= ?
        AND is_deleted = 0
    `).bind(user.user_id, yesterdayStr, yesterdayStr).first();
    
    if (!timelog && !leave) {
      missingUsers.push(user);
      
      // 1. 通知員工本人（檢查是否已有提醒，避免重複）
      const existingNotif = await db.prepare(`
        SELECT * FROM Notifications
        WHERE user_id = ? 
          AND type = 'missing_timesheet' 
          AND related_date = ?
          AND is_deleted = 0
          AND is_read = 0
      `).bind(user.user_id, yesterdayStr).first();
      
      if (!existingNotif) {
        await db.prepare(`
          INSERT INTO Notifications (
            user_id, type, message, related_date, action_url, auto_dismiss
          ) VALUES (?, 'missing_timesheet', ?, ?, ?, 1)
        `).bind(
          user.user_id,
          `提醒：${yesterdayStr} 工時尚未填寫`,
          yesterdayStr,
          `/timesheets/new?date=${yesterdayStr}`,
          1  // auto_dismiss=1：填寫後自動消失
        ).run();
      }
    }
  }
  
  // 2. 通知管理員（彙總所有缺填的員工）
  if (missingUsers.length > 0) {
    const admins = await db.prepare(`
      SELECT user_id FROM Users WHERE is_admin = 1 AND is_deleted = 0
    `).all();
    
    for (const admin of admins.results) {
      for (const missingUser of missingUsers) {
        // 檢查是否已有提醒
        const existingNotif = await db.prepare(`
          SELECT * FROM Notifications
          WHERE user_id = ? 
            AND type = 'missing_timesheet' 
            AND related_date = ?
            AND related_user_id = ?
            AND is_deleted = 0
            AND is_read = 0
        `).bind(admin.user_id, yesterdayStr, missingUser.user_id).first();
        
        if (!existingNotif) {
          await db.prepare(`
            INSERT INTO Notifications (
              user_id, type, message, related_date, related_user_id, action_url, auto_dismiss
            ) VALUES (?, 'missing_timesheet', ?, ?, ?, ?, 1)
          `).bind(
            admin.user_id,
            `${missingUser.name} 的 ${yesterdayStr} 工時尚未填寫`,
            yesterdayStr,
            missingUser.user_id,
            `/admin/timesheets?user_id=${missingUser.user_id}&date=${yesterdayStr}`,
            1  // auto_dismiss=1：該員工填寫後，管理員的提醒也自動消失
          ).run();
        }
      }
    }
  }
  
  console.log(`工時檢查完成：${missingUsers.length} 位員工缺填 ${yesterdayStr}`);
}

// ⭐ 自動消失邏輯：員工填寫工時後觸發
async function onTimeLogCreated(userId: number, workDate: string) {
  // 移除該員工的提醒
  await db.prepare(`
    UPDATE Notifications
    SET is_deleted = 1,
        dismissed_at = datetime('now')
    WHERE user_id = ?
      AND type = 'missing_timesheet'
      AND related_date = ?
      AND auto_dismiss = 1
      AND is_deleted = 0
  `).bind(userId, workDate).run();
  
  // 移除管理員關於該員工的提醒
  await db.prepare(`
    UPDATE Notifications
    SET is_deleted = 1,
        dismissed_at = datetime('now')
    WHERE type = 'missing_timesheet'
      AND related_date = ?
      AND related_user_id = ?
      AND auto_dismiss = 1
      AND is_deleted = 0
  `).bind(workDate, userId).run();
}

/**
 * ⚠️ 通知狀態機說明（簡化版）：
 * 
 * 狀態定義：
 * - is_deleted = 0：通知顯示在儀表板（需要處理）
 * - is_deleted = 1：通知已移除（問題已解決）
 * 
 * 沒有「已讀未讀」概念，只有「顯示/移除」：
 * - 打開儀表板就能看到所有通知（不需標記已讀）
 * - 問題解決後，通知自動消失（不需手動關閉）
 * - 保持介面簡潔，專注於待處理事項
 * 
 * 範例：
 * 1. 員工11/26未填工時 → 11/27 08:30 創建通知
 * 2. 員工看到通知，點擊「填寫工時」
 * 3. 填寫完成 → 通知自動移除（is_deleted=1）
 * 4. 下次打開儀表板，通知已消失 ✅
 */
```

---

### 6. 資料庫備份
**執行時間：** 每天 02:00  
**Cron表達式：** `0 2 * * *`

**功能：**
```
1. 備份 D1 資料庫
2. 上傳到 Cloudflare R2 儲存
3. 保留最近10年的備份（需求聖經要求）
4. 記錄備份狀態
```

---

### 7. 失敗Cron Job自動重試 ⭐ 新增
**執行時間：** 每小時一次  
**Cron表達式：** `0 * * * *`

**功能：**
```
1. 查詢最近7天內失敗的Cron Job
2. 自動重新執行
3. 如果重試成功，更新狀態
4. 如果重試3次仍失敗，通知管理員並停止重試
```

**詳細實作：**
```typescript
// Cron Job: 每小時執行一次
async function retryFailedCronJobs() {
  // 1. 查詢失敗的任務（最近7天，且重試次數<3）
  const failedJobs = await db.prepare(`
    SELECT 
      job_name,
      execution_date,
      COUNT(*) as retry_count
    FROM CronJobExecutions
    WHERE status = 'failed'
      AND execution_date >= date('now', '-7 days')
    GROUP BY job_name, execution_date
    HAVING COUNT(*) < 3  -- 最多重試3次
  `).all();
  
  for (const job of failedJobs.results) {
    console.log(`重試失敗任務：${job.job_name} (${job.execution_date})，第${job.retry_count + 1}次嘗試`);
    
    try {
      // 2. 重新執行對應的Cron Job
      let result;
      
      switch (job.job_name) {
        case 'annual_leave_update':
          result = await annualLeaveYearEndProcessing(job.execution_date);
          break;
        
        case 'monthly_task_generation':
          result = await generateMonthlyTasks();
          break;
        
        case 'comp_leave_conversion':
          result = await convertExpiredCompLeave();
          break;
        
        default:
          console.warn(`未知的任務名稱：${job.job_name}`);
          continue;
      }
      
      // 3. 如果成功，記錄成功狀態
      console.log(`✓ 重試成功：${job.job_name}`);
      
      // 通知管理員
      await sendAdminNotification({
        type: 'cron_retry_success',
        message: `定時任務重試成功：${job.job_name} (${job.execution_date})`
      });
      
    } catch (error) {
      // 4. 重試失敗，記錄新的失敗記錄
      console.error(`✗ 重試失敗：${job.job_name}`, error);
      
      await db.prepare(`
        INSERT INTO CronJobExecutions (
          job_name, execution_date, status, error_message
        ) VALUES (?, ?, 'failed', ?)
      `).bind(job.job_name, job.execution_date, `重試失敗: ${error.message}`).run();
      
      // 5. 如果已重試3次，通知管理員放棄
      if (job.retry_count + 1 >= 3) {
        await sendAdminNotification({
          type: 'cron_retry_exhausted',
          message: `定時任務重試3次仍失敗：${job.job_name} (${job.execution_date})，請手動處理`,
          action_url: `/admin/cron/history?job_name=${job.job_name}`,
          priority: 'high'
        });
      }
    }
  }
}
```

**重試策略：**
```
第1次失敗（0:00）→ 1小時後重試（1:00）
第2次失敗（1:00）→ 1小時後重試（2:00）
第3次失敗（2:00）→ 放棄，通知管理員
```

---

## ⚙️ Cron Job 配置

### Cloudflare Workers Cron 配置（wrangler.toml）

```toml
# wrangler.toml

name = "horgoscpa-api"
compatibility_date = "2024-01-01"

[triggers]
crons = [
  "0 0 1 1 *",      # 每年1月1日 00:00 - 特休更新
  "0 0 1 * *",      # 每月1日 00:00 - 任務生成 + 補休轉換
  "30 8 * * 1-5",   # 週一到週五 08:30 - 工時提醒
  "0 2 * * *",      # 每天 02:00 - 資料庫備份
  "0 * * * *"       # ⭐ 每小時 - 重試失敗的Cron Job
]

[[d1_databases]]
binding = "DB"
database_name = "horgoscpa"
database_id = "your-database-id"

[[r2_buckets]]
binding = "BACKUP"
bucket_name = "horgoscpa-backups"
```

### Cron Handler 入口（src/cron/index.ts）

```typescript
export async function handleCron(event: ScheduledEvent, env: Env) {
  const cron = event.cron;  // Cron 表達式
  const now = new Date();
  
  try {
    // 每年1月1日 00:00 - 特休更新
    if (cron === "0 0 1 1 *") {
      await annualLeaveYearEndProcessing(env.DB);
    }
    
    // 每月1日 00:00 - 任務生成 + 補休轉換
    if (cron === "0 0 1 * *") {
      await generateMonthlyTasks(env.DB);
      await convertExpiredCompLeave(env.DB);
    }
    
    // 週一到週五 08:30 - 工時提醒
    if (cron === "30 8 * * 1-5") {
      await checkMissingTimesheets(env.DB);
    }
    
    // 每天 02:00 - 資料庫備份
    if (cron === "0 2 * * *") {
      await backupDatabase(env.DB, env.BACKUP);
    }
    
    // ⭐ 每小時 - 重試失敗的Cron Job
    if (cron === "0 * * * *") {
      await retryFailedCronJobs(env.DB);
    }
    
    console.log(`Cron job completed: ${cron}`);
  } catch (error) {
    console.error(`Cron job failed: ${cron}`, error);
    
    // 記錄失敗到 CronJobExecutions（如果是已知任務）
    // 通知管理員
  }
}
```

---

## 🔧 執行記錄與監控

### 所有Cron Job都應該：

1. **記錄執行狀態**
   ```typescript
   await db.prepare(`
     INSERT INTO CronJobExecutions (job_name, execution_date, status, affected_users)
     VALUES (?, ?, ?, ?)
   `).bind(jobName, date, 'success', count).run();
   ```

2. **冪等性檢查**
   ```typescript
   const executed = await db.prepare(`
     SELECT * FROM CronJobExecutions
     WHERE job_name = ? AND execution_date = ? AND status = 'success'
   `).bind(jobName, date).first();
   
   if (executed) return;  // 已執行，跳過
   ```

3. **失敗通知**
   ```typescript
   await sendAdminNotification({
     type: 'cron_failed',
     message: `${jobName} 執行失敗：${error.message}`
   });
   ```

4. **支援手動觸發**
   ```typescript
   // POST /api/v1/admin/cron/execute
   // 可以補救執行失敗的任務
   ```

---

**實現細節：** 使用 Cloudflare Workers Cron Triggers

