# 系統設計說明：服務與計費結構

## 📋 數據結構關係

### 1. ClientServices（客戶服務）
客戶訂閱的主服務，例如："記帳服務包"

**重要欄位：**
- `client_service_id` - 服務ID
- `service_id` - 服務類型（記帳、稅務、顧問等）
- `status` - 狀態（使用中、暫停、已取消等）
- `start_date` - 開始日期
- ~~`service_cycle`~~ - **已廢棄** 不再使用

**年度總額計算：**
- `year_total` = SUM(ServiceBillingSchedule.billing_amount) WHERE client_service_id = x
- 即：所有月份收費的總和

---

### 2. ServiceComponents（服務組成部分）
主服務包含的具體子服務，每個可以獨立配置提供頻率

**重要欄位：**
- `component_id` - 組成部分ID
- `client_service_id` - 所屬主服務
- `service_id` - 服務類型
- `component_name` - 例如："月度記帳"、"營業稅申報"
- `delivery_frequency` - 提供頻率（monthly, bi-monthly, quarterly, yearly, one-time）
- `auto_generate_task` - 是否自動生成任務
- `advance_days` - 提前幾天生成任務

**範例：**
```
客戶訂閱"記帳服務包" (ClientServices)
  ├─ 月度記帳 (ServiceComponent, frequency: monthly)
  ├─ 營業稅申報 (ServiceComponent, frequency: bi-monthly)
  └─ 營所稅申報 (ServiceComponent, frequency: yearly)
```

---

### 3. ServiceBillingSchedule（收費明細）
記錄每個月的收費金額

**重要欄位：**
- `schedule_id` - 明細ID
- `client_service_id` - 所屬服務
- `billing_month` - 月份（1-12）
- `billing_amount` - 該月收費金額
- `payment_due_days` - 付款期限（天數）

**範例：**
```
客戶服務ID 123 的收費明細：
  - 1月: $2,000
  - 2月: $2,000
  - 3月: $5,000 (含季度稅務申報)
  - ...
  - 年度總額 = $30,000
```

---

### 4. TaskTemplateStages（任務模板階段）
定義每個獨立任務的詳細配置

**重要欄位：**
- `stage_id` - 階段ID
- `template_id` - 所屬模板
- `stage_name` - 任務名稱
- `stage_order` - 順序
- `estimated_hours` - 預估工時
- `due_date_rule` - 期限規則（end_of_month, specific_day, next_month_day, days_after_start）
- `due_date_value` - 日期/天數值
- `advance_days` - 提前生成天數

**範例：**
```
"月度記帳服務"模板的任務：
  1. 收集憑證 (每月5日到期, 3天前生成)
  2. 整理分類 (每月10日到期, 3天前生成)
  3. 帳務錄入 (每月20日到期, 5天前生成)
  4. 核對調整 (每月28日到期, 3天前生成)
  5. 產出報表 (月底到期, 3天前生成)
```

---

## 🔄 工作流程

### 服務配置流程：

1. **建立客戶服務** → ClientServices
2. **配置服務內容** → ServiceComponents（可選擇模板或手動配置）
3. **設定收費明細** → ServiceBillingSchedule
4. **自動生成任務** → 系統根據 ServiceComponents 和 TaskTemplateStages 配置自動生成 ActiveTasks

### 任務生成邏輯：

```
每天執行自動任務生成：
  FOR EACH ServiceComponent WHERE auto_generate_task = 1:
    IF 當前日期 >= (任務執行日 - advance_days):
      根據 delivery_frequency 判斷是否該生成
      根據 task_template_id 取得模板階段
      FOR EACH TaskTemplateStage:
        生成一個 ActiveTask
          - task_name = stage_name
          - due_date = 根據 due_date_rule 計算
          - estimated_hours = stage.estimated_hours
```

---

## 💰 年度總額計算

### 正確的計算方式：

```sql
SELECT 
  SUM(billing_amount) as year_total
FROM ServiceBillingSchedule
WHERE client_service_id = ?
```

### 前端顯示：
- 客戶服務列表中的"年度總額"欄位
- 從 ServiceBillingSchedule 所有月份的總和計算
- 即使不同月份金額不同（例如某些月份有額外服務）也能正確反映

---

## ⚠️ 重要變更說明

### service_cycle 字段已廢棄

**原因：**
- 不同的子服務可能有不同的提供頻率
- 例如：月度記帳（monthly）+ 營業稅申報（bi-monthly）+ 營所稅申報（yearly）
- 單一的 service_cycle 無法表達這種複雜結構

**新設計：**
- ClientServices 不再需要 service_cycle
- 每個 ServiceComponent 有自己的 delivery_frequency
- 更靈活、更精確

**數據遷移：**
- service_cycle 字段保留在數據庫中（SQLite不支持刪除列）
- 前端和後端 API 已經不再使用此字段
- 舊數據不受影響

---

## 📊 數據一致性檢查

### 確保數據完整性：

1. 每個活躍的 ClientServices 應該至少有一個 ServiceComponent
2. 每個 ServiceComponent 如果啟用 auto_generate_task，應該關聯一個有效的 TaskTemplate
3. ServiceBillingSchedule 的月份收費總和應該等於顯示的年度總額

### 驗證查詢：

```sql
-- 檢查缺少ServiceComponents的客戶服務
SELECT cs.* 
FROM ClientServices cs
LEFT JOIN ServiceComponents sc ON cs.client_service_id = sc.client_service_id
WHERE cs.status = 'active' 
  AND sc.component_id IS NULL;

-- 驗證年度總額計算
SELECT 
  cs.client_service_id,
  cs.service_name,
  SUM(sbs.billing_amount) as calculated_total,
  -- 與前端顯示比對
FROM ClientServices cs
LEFT JOIN ServiceBillingSchedule sbs ON cs.client_service_id = sbs.client_service_id
GROUP BY cs.client_service_id;
```

---

## 🎯 總結

### 核心設計原則：

1. **分層結構** - ClientServices → ServiceComponents → Tasks
2. **靈活配置** - 每個組成部分獨立配置提供頻率和任務期限
3. **精確計費** - 按月設定收費，支持不同月份不同金額
4. **自動化** - 系統自動生成任務，減少手動操作

### 優勢：

- ✅ 支持複雜的服務組合
- ✅ 精確的成本和收入追蹤
- ✅ 自動化任務生成
- ✅ 靈活的期限管理
- ✅ 清晰的數據結構

---

**文檔版本：** 1.0  
**最後更新：** 2025-11-01  
**維護者：** 系統開發團隊

