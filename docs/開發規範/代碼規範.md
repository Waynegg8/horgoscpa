# 代碼規範

**最後更新：** 2025年10月27日  
**適用範圍：** 所有後端（Workers）和前端（Vue.js）代碼

---

## 1. TypeScript 代碼規範

### 1.1 類型定義

**始終使用明確的類型：**
```typescript
✅ 正確：
const userId: number = 123;
const userName: string = 'John';
const isActive: boolean = true;

function calculateTotal(items: CartItem[]): number {
  return items.reduce((sum, item) => sum + item.price, 0);
}

❌ 錯誤：
const userId = 123;  // 缺少類型
function calculateTotal(items) { ... }  // 缺少類型
```

**介面 vs 類型別名：**
```typescript
// 優先使用 interface（可擴展）
✅ interface User {
  user_id: number;
  name: string;
  email?: string;  // 可選屬性
}

// 擴展介面
✅ interface AdminUser extends User {
  permissions: string[];
}

// 使用 type 於聯合類型、交集類型
✅ type Status = 'pending' | 'active' | 'inactive';
✅ type ID = string | number;
```

---

### 1.2 函數規範

**函數簽名必須包含類型：**
```typescript
✅ 正確：
async function getUser(userId: number): Promise<User | null> {
  const result = await db.query(...);
  return result;
}

// 箭頭函數
const calculateWeightedHours = (hours: number, rate: number): number => {
  return hours * rate;
};

❌ 錯誤：
async function getUser(userId) {  // 缺少參數類型
  return await db.query(...);  // 缺少返回類型
}
```

**參數解構必須包含類型：**
```typescript
✅ 正確：
function createClient({ 
  company_name, 
  contact_person 
}: {
  company_name: string;
  contact_person: string;
}) {
  // ...
}

// 或使用介面
interface CreateClientParams {
  company_name: string;
  contact_person: string;
}

function createClient({ company_name, contact_person }: CreateClientParams) {
  // ...
}
```

---

### 1.3 Null 和 Undefined 處理

**明確標示可能為 null/undefined：**
```typescript
✅ 正確：
function findUser(id: number): User | null {
  // 可能返回 null
}

function getConfig(key: string): string | undefined {
  // 可能返回 undefined
}

// 使用可選鏈
const email = user?.contact?.email ?? 'no-email@example.com';

❌ 錯誤：
function findUser(id: number): User {
  // 實際可能返回 null，但類型不正確
  return db.query(...) || null;
}
```

---

## 2. 命名規範

### 2.1 變數和函數命名

**變數：camelCase**
```typescript
✅ const userId = 123;
✅ const companyName = 'ABC Corp';
✅ const isActiveUser = true;
✅ const hasPermission = false;

❌ const user_id = 123;      // 不使用 snake_case
❌ const UserName = 'John';   // 不使用 PascalCase
❌ const COMPANY_ID = 456;    // 不使用 UPPER_CASE（除非是常數）
```

**函數：camelCase，使用動詞開頭**
```typescript
✅ function getUser(id: number) { ... }
✅ function createClient(data: ClientData) { ... }
✅ function calculateTotal(items: Item[]) { ... }
✅ function isValidEmail(email: string): boolean { ... }
✅ function hasPermission(userId: number, module: string): boolean { ... }

❌ function user(id: number) { ... }          // 缺少動詞
❌ function GetUser(id: number) { ... }       // 不使用 PascalCase
❌ function get_user(id: number) { ... }      // 不使用 snake_case
```

**布林值：使用 is/has/can 前綴**
```typescript
✅ const isActive = true;
✅ const hasPermission = checkPermission();
✅ const canEdit = user.role === 'admin';
✅ const isLoading = ref(false);

❌ const active = true;       // 不清楚是狀態還是動作
❌ const permission = true;   // 不清楚含義
```

---

### 2.2 類別和介面命名

**類別：PascalCase，使用名詞**
```typescript
✅ class UserService { ... }
✅ class ClientRepository { ... }
✅ class PermissionMiddleware { ... }
✅ class AppError extends Error { ... }

❌ class userService { ... }      // 不使用 camelCase
❌ class User_Repository { ... }  // 不使用 snake_case
```

**介面：PascalCase**
```typescript
✅ interface User { ... }
✅ interface CreateClientRequest { ... }
✅ interface ApiResponse<T> { ... }

// 可選：使用 I 前綴（專案統一即可）
✅ interface IUser { ... }
✅ interface IClientService { ... }
```

---

### 2.3 常數命名

**常數：UPPER_SNAKE_CASE**
```typescript
✅ const MAX_LOGIN_ATTEMPTS = 5;
✅ const API_BASE_URL = 'https://api.example.com';
✅ const DEFAULT_PAGE_SIZE = 50;
✅ const ALLOWED_FILE_TYPES = ['pdf', 'docx', 'xlsx'];

❌ const maxLoginAttempts = 5;     // 常數應使用大寫
❌ const apiBaseUrl = '...';       // 常數應使用大寫
```

**列舉：PascalCase**
```typescript
✅ enum UserRole {
  Admin = 'admin',
  Employee = 'employee'
}

✅ enum TaskStatus {
  Pending = 'pending',
  InProgress = 'in_progress',
  Completed = 'completed'
}
```

---

## 3. 代碼組織

### 3.1 檔案組織

**每個檔案只負責一個主要功能：**
```
✅ userRepository.ts       -- 只包含 UserRepository 類別
✅ clientService.ts        -- 只包含 ClientService 類別
✅ authMiddleware.ts       -- 只包含認證中間件

❌ utils.ts                -- 包含各種不相關的工具函數
❌ helpers.ts              -- 過於籠統
```

**檔案內部結構順序：**
```typescript
// 1. Imports（按類別分組）
import { Context } from 'hono';                    // 外部套件
import { UserService } from '../services/user';   // 專案內部
import type { User, CreateUserRequest } from '../types';  // 類型

// 2. 類型定義
interface LocalConfig {
  timeout: number;
}

// 3. 常數
const DEFAULT_TIMEOUT = 5000;

// 4. 主要類別或函數
export class UserController {
  // ...
}

// 5. 輔助函數（如需要）
function validateEmail(email: string): boolean {
  // ...
}
```

---

### 3.2 Repository 層規範

**只負責資料存取，不包含業務邏輯：**
```typescript
✅ 正確：
export class ClientRepository {
  constructor(private db: D1Database) {}

  // 單純的 CRUD 操作
  async findById(clientId: string): Promise<Client | null> {
    const result = await this.db
      .prepare('SELECT * FROM Clients WHERE client_id = ? AND is_deleted = 0')
      .bind(clientId)
      .first();
    return result as Client | null;
  }

  async create(data: CreateClientData): Promise<Client> {
    const result = await this.db
      .prepare(`
        INSERT INTO Clients (client_id, company_name, contact_person, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?)
      `)
      .bind(data.client_id, data.company_name, data.contact_person, new Date().toISOString(), new Date().toISOString())
      .run();
    
    return await this.findById(data.client_id);
  }
}

❌ 錯誤（包含業務邏輯）：
async create(data: CreateClientData): Promise<Client> {
  // ❌ 業務邏輯（驗證）應該在 Service 層
  if (!this.isValidEmail(data.email)) {
    throw new Error('Invalid email');
  }
  
  // ❌ 業務邏輯（計算）應該在 Service 層
  const rating = this.calculateInitialRating(data);
  
  // Repository 只負責資料存取
  return await this.db.insert(...);
}
```

---

### 3.3 Service 層規範

**只負責業務邏輯，不直接操作資料庫：**
```typescript
✅ 正確：
export class ClientService {
  constructor(private clientRepo: ClientRepository) {}

  async createClient(data: CreateClientRequest): Promise<Client> {
    // 業務邏輯：驗證
    this.validateClientData(data);
    
    // 業務邏輯：檢查重複
    const existing = await this.clientRepo.findByTaxId(data.client_id);
    if (existing) {
      throw new AppError('CLIENT_EXISTS', '客戶已存在', 409);
    }
    
    // 業務邏輯：資料轉換
    const clientData = {
      ...data,
      status: 'active',
      created_at: new Date().toISOString()
    };
    
    // 委派給 Repository
    return await this.clientRepo.create(clientData);
  }

  private validateClientData(data: CreateClientRequest): void {
    if (!data.company_name || data.company_name.length < 2) {
      throw new AppError('VALIDATION_ERROR', '公司名稱至少需要2個字元', 400);
    }
  }
}

❌ 錯誤（直接操作資料庫）：
async createClient(data: CreateClientRequest): Promise<Client> {
  // ❌ Service 不應該直接操作資料庫
  const result = await this.db.prepare('INSERT INTO ...').run();
}
```

---

### 3.4 Route 層規範

**只負責路由、參數解析和回應格式化：**
```typescript
✅ 正確：
import { Hono } from 'hono';
import { ClientService } from '../services/client';
import { requireAuth, requirePermission } from '../middlewares/auth';

const app = new Hono();

app.post('/api/v1/clients',
  requireAuth,
  requirePermission('client_management'),
  async (c) => {
    try {
      // 1. 解析請求
      const body = await c.req.json();
      
      // 2. 委派給 Service
      const clientService = new ClientService(c.env.DB);
      const client = await clientService.createClient(body);
      
      // 3. 格式化回應
      return c.json({
        success: true,
        data: client
      }, 201);
    } catch (error) {
      // 4. 錯誤處理
      if (error instanceof AppError) {
        return c.json({
          success: false,
          error: {
            code: error.code,
            message: error.message
          }
        }, error.statusCode);
      }
      
      return c.json({
        success: false,
        error: { code: 'SERVER_ERROR', message: '伺服器錯誤' }
      }, 500);
    }
  }
);

❌ 錯誤（包含業務邏輯）：
app.post('/api/v1/clients', async (c) => {
  const body = await c.req.json();
  
  // ❌ 不應該在 Route 層驗證業務邏輯
  if (body.company_name.length < 2) {
    return c.json({ error: '名稱太短' }, 400);
  }
  
  // ❌ 不應該在 Route 層直接操作資料庫
  const result = await c.env.DB.prepare('INSERT INTO ...').run();
  
  return c.json({ success: true });
});
```

---

## 4. 錯誤處理

### 4.1 自訂錯誤類別

**使用統一的錯誤類別：**
```typescript
export class AppError extends Error {
  constructor(
    public code: string,
    public message: string,
    public statusCode: number = 500,
    public details?: any
  ) {
    super(message);
    this.name = 'AppError';
  }
}

// 使用
throw new AppError(
  'VALIDATION_ERROR',
  '請求參數驗證失敗',
  400,
  { field: 'email', issue: '格式不正確' }
);
```

**常用錯誤代碼：**
```typescript
// 客戶端錯誤（4xx）
'VALIDATION_ERROR'      // 400 - 參數驗證失敗
'UNAUTHORIZED'          // 401 - 未登入
'FORBIDDEN'             // 403 - 無權限
'NOT_FOUND'             // 404 - 資源不存在
'CONFLICT'              // 409 - 資源衝突
'UNPROCESSABLE'         // 422 - 業務邏輯驗證失敗

// 伺服器錯誤（5xx）
'DATABASE_ERROR'        // 500 - 資料庫錯誤
'SERVER_ERROR'          // 500 - 伺服器錯誤
```

---

### 4.2 錯誤處理模式

**Repository 層：捕獲並重新拋出**
```typescript
async findById(id: number): Promise<User | null> {
  try {
    const result = await this.db.prepare(...).first();
    return result as User | null;
  } catch (error) {
    throw new AppError(
      'DATABASE_ERROR',
      '資料庫查詢失敗',
      500,
      { originalError: error }
    );
  }
}
```

**Service 層：業務邏輯驗證**
```typescript
async deleteClient(clientId: string): Promise<void> {
  const client = await this.clientRepo.findById(clientId);
  
  if (!client) {
    throw new AppError('NOT_FOUND', '客戶不存在', 404);
  }
  
  // 檢查是否有關聯資料
  const hasServices = await this.clientRepo.hasActiveServices(clientId);
  if (hasServices) {
    throw new AppError(
      'UNPROCESSABLE',
      '無法刪除：客戶仍有進行中的服務',
      422
    );
  }
  
  await this.clientRepo.softDelete(clientId);
}
```

**Route 層：統一錯誤回應**
```typescript
app.delete('/api/v1/clients/:id', async (c) => {
  try {
    const clientId = c.req.param('id');
    await clientService.deleteClient(clientId);
    return c.json({ success: true }, 204);
  } catch (error) {
    if (error instanceof AppError) {
      return c.json({
        success: false,
        error: {
          code: error.code,
          message: error.message,
          details: error.details
        }
      }, error.statusCode);
    }
    
    // 未預期的錯誤
    console.error('Unexpected error:', error);
    return c.json({
      success: false,
      error: {
        code: 'SERVER_ERROR',
        message: '伺服器發生錯誤'
      }
    }, 500);
  }
});
```

---

## 5. 前端代碼規範（Vue 3）

### 5.1 組件結構

**使用 Composition API（script setup）：**
```vue
<script setup lang="ts">
// ✅ 推薦順序

// 1. Imports
import { ref, computed, onMounted } from 'vue';
import { useRouter } from 'vue-router';
import { useClientStore } from '@/stores/client';
import StyledButton from '@/components/common/StyledButton.vue';

// 2. Props 定義
interface Props {
  clientId: string;
  mode?: 'view' | 'edit';
}

const props = withDefaults(defineProps<Props>(), {
  mode: 'view'
});

// 3. Emits 定義
const emit = defineEmits<{
  save: [clientId: string];
  cancel: [];
}>();

// 4. Router & Store
const router = useRouter();
const clientStore = useClientStore();

// 5. Reactive State
const isLoading = ref(false);
const form = ref({
  company_name: '',
  contact_person: ''
});

// 6. Computed Properties
const isValid = computed(() => {
  return form.value.company_name.length > 0;
});

// 7. Methods
const handleSave = async () => {
  isLoading.value = true;
  try {
    await clientStore.updateClient(props.clientId, form.value);
    emit('save', props.clientId);
  } catch (error) {
    console.error('Save failed:', error);
  } finally {
    isLoading.value = false;
  }
};

const handleCancel = () => {
  emit('cancel');
};

// 8. Lifecycle Hooks
onMounted(async () => {
  const client = await clientStore.getClient(props.clientId);
  if (client) {
    form.value = { ...client };
  }
});
</script>

<template>
  <div class="client-form">
    <input v-model="form.company_name" type="text" />
    <StyledButton @click="handleSave" :disabled="!isValid || isLoading">
      儲存
    </StyledButton>
    <StyledButton @click="handleCancel" variant="secondary">
      取消
    </StyledButton>
  </div>
</template>

<style scoped>
/* 優先使用 Tailwind，僅在必要時使用 scoped style */
</style>
```

---

### 5.2 Composables 規範

**Composable 命名：use + 名詞**
```typescript
// composables/useAuth.ts
export function useAuth() {
  const isLoggedIn = ref(false);
  const currentUser = ref<User | null>(null);
  
  const login = async (username: string, password: string) => {
    // ...
  };
  
  const logout = async () => {
    // ...
  };
  
  // 返回響應式狀態和方法
  return {
    isLoggedIn: readonly(isLoggedIn),
    currentUser: readonly(currentUser),
    login,
    logout
  };
}

// 使用
const { isLoggedIn, currentUser, login } = useAuth();
```

---

### 5.3 Store 規範（Pinia）

**Store 結構：**
```typescript
// stores/client.ts
import { defineStore } from 'pinia';
import { clientApi } from '@/api/client.api';

export const useClientStore = defineStore('client', () => {
  // 1. State
  const clients = ref<Client[]>([]);
  const currentClient = ref<Client | null>(null);
  const isLoading = ref(false);
  
  // 2. Getters
  const activeClients = computed(() => {
    return clients.value.filter(c => c.status === 'active');
  });
  
  // 3. Actions
  async function fetchClients() {
    isLoading.value = true;
    try {
      const response = await clientApi.getClients();
      clients.value = response.data;
    } catch (error) {
      console.error('Failed to fetch clients:', error);
      throw error;
    } finally {
      isLoading.value = false;
    }
  }
  
  async function updateClient(id: string, data: Partial<Client>) {
    const response = await clientApi.updateClient(id, data);
    // 更新本地狀態
    const index = clients.value.findIndex(c => c.client_id === id);
    if (index !== -1) {
      clients.value[index] = response.data;
    }
    return response.data;
  }
  
  // 4. Return
  return {
    // State
    clients: readonly(clients),
    currentClient: readonly(currentClient),
    isLoading: readonly(isLoading),
    
    // Getters
    activeClients,
    
    // Actions
    fetchClients,
    updateClient
  };
});
```

---

## 6. 註解規範

### 6.1 何時需要註解

**需要註解的情況：**
```typescript
✅ 複雜的業務邏輯
/**
 * 計算加權工時
 * 根據加班類型和時段，套用不同的加班費率
 * 例如：平日 18:00-22:00 為 1.34 倍，22:00 之後為 1.67 倍
 */
function calculateWeightedHours(hours: number, workType: string): number {
  // ...
}

✅ 非直觀的實作
// 使用 setTimeout 而非 setInterval，避免累積執行延遲
setTimeout(() => {
  this.checkStatus();
}, 1000);

✅ 暫時的解決方案或技術債務
// TODO: 改用批量查詢以提升效能
// FIXME: 此處邏輯有 edge case 未處理
// HACK: 臨時解決方案，待 API 升級後移除
```

**不需要註解的情況：**
```typescript
❌ 不需要（顯而易見）：
// 獲取用戶 ID
const userId = user.id;

// 檢查是否為管理員
if (user.role === 'admin') {
  // ...
}

✅ 應該透過好的命名來表達：
const isAdmin = user.role === 'admin';
if (isAdmin) {
  // ...
}
```

---

### 6.2 JSDoc 註解

**公開 API 和複雜函數應該使用 JSDoc：**
```typescript
/**
 * 創建新客戶
 * @param data - 客戶資料
 * @returns 創建的客戶物件
 * @throws {AppError} VALIDATION_ERROR - 當資料驗證失敗時
 * @throws {AppError} CLIENT_EXISTS - 當客戶已存在時
 * 
 * @example
 * ```typescript
 * const client = await createClient({
 *   client_id: '12345678',
 *   company_name: '仟鑽企業'
 * });
 * ```
 */
async function createClient(data: CreateClientRequest): Promise<Client> {
  // ...
}
```

---

## 7. 測試規範

### 7.1 測試檔案組織

```
tests/
├── unit/                 # 單元測試
│   ├── services/
│   │   └── client.service.test.ts
│   ├── repositories/
│   │   └── client.repository.test.ts
│   └── utils/
│       └── date.util.test.ts
├── integration/          # 整合測試
│   └── api/
│       └── clients.api.test.ts
└── e2e/                  # 端到端測試
    └── scenarios/
        └── client-management.test.ts
```

---

### 7.2 測試命名

**測試描述應該清楚說明預期行為：**
```typescript
describe('ClientService', () => {
  describe('createClient', () => {
    it('應該成功創建客戶當資料有效時', async () => {
      // ...
    });
    
    it('應該拋出 VALIDATION_ERROR 當公司名稱為空時', async () => {
      // ...
    });
    
    it('應該拋出 CLIENT_EXISTS 當統編已存在時', async () => {
      // ...
    });
  });
});
```

---

## 8. 效能最佳化

### 8.1 資料庫查詢

**使用 JOIN 而非多次查詢：**
```typescript
✅ 正確（使用 JOIN）：
const clients = await db.prepare(`
  SELECT 
    c.*,
    u.name as assignee_name
  FROM Clients c
  LEFT JOIN Users u ON c.assignee_user_id = u.user_id
  WHERE c.is_deleted = 0
`).all();

❌ 錯誤（N+1 問題）：
const clients = await db.prepare('SELECT * FROM Clients').all();
for (const client of clients) {
  const assignee = await db.prepare(
    'SELECT name FROM Users WHERE user_id = ?'
  ).bind(client.assignee_user_id).first();
  client.assignee_name = assignee.name;
}
```

**使用索引：**
```sql
-- 為常用查詢欄位建立索引
CREATE INDEX idx_clients_status ON Clients(status);
CREATE INDEX idx_time_logs_user_date ON TimeLogs(user_id, work_date);
```

---

### 8.2 前端效能

**使用 computed 快取計算結果：**
```typescript
✅ 正確：
const filteredClients = computed(() => {
  return clients.value.filter(c => c.status === 'active');
});

❌ 錯誤（每次渲染都重新計算）：
const getFilteredClients = () => {
  return clients.value.filter(c => c.status === 'active');
};
```

**列表渲染使用 key：**
```vue
✅ 正確：
<div v-for="client in clients" :key="client.client_id">
  {{ client.company_name }}
</div>

❌ 錯誤：
<div v-for="(client, index) in clients" :key="index">
  {{ client.company_name }}
</div>
```

---

## 9. 安全規範

### 9.1 SQL 注入防護

**始終使用參數化查詢：**
```typescript
✅ 正確：
const user = await db.prepare(
  'SELECT * FROM Users WHERE username = ?'
).bind(username).first();

❌ 錯誤：
const user = await db.prepare(
  `SELECT * FROM Users WHERE username = '${username}'`
).first();
```

---

### 9.2 XSS 防護

**不使用 v-html（除非必要且已清理）：**
```vue
❌ 危險：
<div v-html="userInput"></div>

✅ 安全：
<div>{{ userInput }}</div>

✅ 必要時使用清理函式：
<div v-html="sanitizeHtml(userInput)"></div>
```

---

## 10. 相關文檔

- [專案開發規格總覽](../AI開發指南/專案開發規格總覽.md)
- [API 標準規範](./API標準規範.md)
- [前端開發規範](./前端開發規範.md)
- [後端開發規範](./後端開發規範.md)

---

**最後更新：** 2025年10月27日  
**文檔版本：** 1.0

