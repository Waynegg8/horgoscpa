# 響應式狀態管理

**最後更新：** 2025年10月27日

---

## ref vs reactive

### 使用 ref（推薦）

```typescript
// ✅ 基本類型
const count = ref(0);
const message = ref('Hello');

// ✅ 物件
const user = ref<User | null>(null);
const form = ref<Partial<Client>>({
  company_name: '',
  contact_person: ''
});

// 訪問需要 .value
count.value++;
user.value = { id: 1, name: 'John' };
```

### 使用 reactive

```typescript
// ✅ 僅用於複雜物件
const state = reactive({
  count: 0,
  user: null as User | null,
  isLoading: false
});

// 直接訪問屬性
state.count++;
state.user = { id: 1, name: 'John' };
```

### 選擇指南

| 場景 | 使用 | 原因 |
|------|------|------|
| 基本類型 | `ref` | reactive 不支援 |
| 單一物件 | `ref` | 可整個替換 |
| 複雜物件 | `reactive` | 無需 .value |
| 需要解構 | `ref` | reactive 解構失去響應性 |

---

## Computed vs Methods

### 使用 Computed（有快取）

```typescript
// ✅ 快取計算結果
const filteredClients = computed(() => {
  return clients.value.filter(c => c.status === 'active');
});

// 只在 clients 改變時重新計算
<div v-for="client in filteredClients" :key="client.id">
  {{ client.name }}
</div>
```

### 避免 Methods

```typescript
// ❌ 每次渲染都執行
const getFilteredClients = () => {
  return clients.value.filter(c => c.status === 'active');
};
```

---

## Watchers

### 基本 Watch

```typescript
// 監聽單一值
watch(() => props.clientId, async (newId) => {
  await loadClient(newId);
});

// 監聽多個值
watch([() => props.clientId, () => props.mode], ([id, mode]) => {
  // ...
});

// 深度監聽
watch(() => form.value, (newForm) => {
  validateForm(newForm);
}, { deep: true });
```

---

## 檢查清單

- [ ] 優先使用 ref
- [ ] 使用 computed 而非 methods
- [ ] Watchers 有明確目的
- [ ] 深度監聽僅在必要時使用

---

**相關：** [Props與Emits](./Props與Emits.md) | [生命週期](./生命週期.md)

