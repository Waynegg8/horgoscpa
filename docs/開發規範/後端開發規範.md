# 後端開發規範

**適用範圍：** Cloudflare Workers + Hono 後端開發  
**最後更新：** 2025年10月27日

---

## 📋 目錄
- [架構分層](#架構分層)
- [Route 層](#route-層)
- [Service 層](#service-層)
- [Repository 層](#repository-層)
- [錯誤處理](#錯誤處理)

---

## 架構分層

### 三層架構
```
Routes (路由層)
  ↓ 接收請求、驗證權限
Service (業務邏輯層)
  ↓ 處理業務邏輯、協調資源
Repository (資料存取層)
  ↓ 執行資料庫操作
Database (資料庫)
```

### 分層職責

| 層級 | 職責 | 禁止事項 |
|------|------|---------|
| **Routes** | 接收請求、驗證權限、調用 Service | ❌ 不寫業務邏輯、不直接訪問資料庫 |
| **Service** | 業務邏輯、資料驗證、協調多個 Repository | ❌ 不直接寫 SQL |
| **Repository** | 執行 SQL、資料轉換 | ❌ 不寫業務邏輯 |

---

## Route 層

### 標準 Route 結構
```typescript
import { Hono } from 'hono';
import { authMiddleware, requireAdmin } from '../middleware/auth';
import { ClientService } from '../services/ClientService';

const app = new Hono();
const clientService = new ClientService();

// GET 列表
app.get('/api/v1/clients', 
  authMiddleware,
  async (c) => {
    const user = c.get('user');
    const query = c.req.query();
    
    const result = await clientService.getClients(query, user);
    
    return c.json(successResponse(result.data, result.pagination));
  }
);

// POST 新增
app.post('/api/v1/clients',
  authMiddleware,
  requireAdmin,
  async (c) => {
    const user = c.get('user');
    const input = await c.req.json();
    
    const client = await clientService.createClient(input, user.user_id);
    
    return c.json(successResponse({
      client_id: client.client_id,
      message: '客戶新增成功'
    }), 201);
  }
);

export default app;
```

### Route 層職責
```typescript
// ✅ 應該做
- 接收請求參數
- 驗證權限（使用 middleware）
- 調用 Service 層
- 返回響應

// ❌ 不應該做
- 寫業務邏輯
- 直接訪問資料庫
- 直接寫 SQL
```

---

## Service 層

### 標準 Service 結構
```typescript
import { ClientRepository } from '../repositories/ClientRepository';
import { ValidationError, ConflictError } from '../errors';

export class ClientService {
  private repository: ClientRepository;
  
  constructor(db) {
    this.repository = new ClientRepository(db);
  }
  
  async createClient(data, userId) {
    // 1. 驗證必填欄位
    this.validateRequired(data, ['client_id', 'company_name', 'assignee_user_id']);
    
    // 2. 驗證欄位格式
    if (!this.isValidClientId(data.client_id)) {
      throw new ValidationError('統一編號必須為 8 位數字');
    }
    
    // 3. 檢查唯一性
    const existing = await this.repository.findByClientId(data.client_id);
    if (existing) {
      throw new ConflictError('統一編號已存在');
    }
    
    // 4. 插入資料
    const client = await this.repository.create({
      ...data,
      created_by: userId,
      created_at: new Date(),
      is_deleted: 0
    });
    
    // 5. 記錄審計日誌（若需要）
    await this.auditLog.log({
      user_id: userId,
      action: 'CREATE',
      table_name: 'Clients',
      record_id: client.client_id
    });
    
    return client;
  }
  
  async getClients(filters, user) {
    // 權限控制
    if (!user.is_admin) {
      filters.assignee_user_id = user.user_id;
    }
    
    return await this.repository.findAll(filters);
  }
  
  // 驗證方法
  private validateRequired(data, fields) {
    for (const field of fields) {
      if (!data[field]) {
        throw new ValidationError(`${field} 為必填欄位`);
      }
    }
  }
  
  private isValidClientId(clientId) {
    return /^\d{8}$/.test(clientId);
  }
}
```

### Service 層職責
```typescript
// ✅ 應該做
- 驗證業務規則
- 檢查唯一性
- 協調多個 Repository
- 記錄審計日誌
- 拋出業務異常

// ❌ 不應該做
- 直接寫 SQL
- 處理 HTTP 請求/響應
- 返回 HTTP 狀態碼
```

---

## Repository 層

### 標準 Repository 結構
```typescript
export class ClientRepository {
  private db;
  private tableName = 'Clients';
  private primaryKey = 'client_id';
  
  constructor(db) {
    this.db = db;
  }
  
  async findAll(filters = {}) {
    let query = `SELECT * FROM ${this.tableName} WHERE is_deleted = 0`;
    const params = [];
    
    if (filters.assignee_user_id) {
      query += ' AND assignee_user_id = ?';
      params.push(filters.assignee_user_id);
    }
    
    if (filters.company_name) {
      query += ' AND company_name LIKE ?';
      params.push(`%${filters.company_name}%`);
    }
    
    query += ' ORDER BY created_at DESC LIMIT ? OFFSET ?';
    params.push(filters.limit || 50, filters.offset || 0);
    
    const result = await this.db.prepare(query).bind(...params).all();
    return result.results;
  }
  
  async findById(id) {
    return await this.db.prepare(
      `SELECT * FROM ${this.tableName} WHERE ${this.primaryKey} = ? AND is_deleted = 0`
    ).bind(id).first();
  }
  
  async findByClientId(clientId) {
    return await this.db.prepare(
      'SELECT * FROM Clients WHERE client_id = ? AND is_deleted = 0'
    ).bind(clientId).first();
  }
  
  async create(data) {
    const fields = Object.keys(data);
    const placeholders = fields.map(() => '?').join(', ');
    const values = Object.values(data);
    
    const result = await this.db.prepare(`
      INSERT INTO ${this.tableName} (${fields.join(', ')})
      VALUES (${placeholders})
    `).bind(...values).run();
    
    return await this.findById(result.meta.last_row_id || data[this.primaryKey]);
  }
  
  async update(id, data) {
    const fields = Object.keys(data);
    const setClause = fields.map(f => `${f} = ?`).join(', ');
    const values = [...Object.values(data), id];
    
    await this.db.prepare(`
      UPDATE ${this.tableName}
      SET ${setClause}, updated_at = CURRENT_TIMESTAMP
      WHERE ${this.primaryKey} = ?
    `).bind(...values).run();
    
    return await this.findById(id);
  }
  
  async softDelete(id, userId) {
    await this.db.prepare(`
      UPDATE ${this.tableName}
      SET is_deleted = 1,
          deleted_at = CURRENT_TIMESTAMP,
          deleted_by = ?
      WHERE ${this.primaryKey} = ?
    `).bind(userId, id).run();
  }
}
```

### Repository 層職責
```typescript
// ✅ 應該做
- 執行 SQL 查詢
- 使用參數化查詢（防 SQL 注入）
- 自動過濾 is_deleted = 0
- 返回資料物件

// ❌ 不應該做
- 驗證業務規則
- 拋出業務異常
- 處理權限檢查
```

---

## 錯誤處理

### 自定義錯誤類別
```typescript
// errors/index.ts
export class ValidationError extends Error {
  statusCode = 422;
  code = 'VALIDATION_ERROR';
  
  constructor(message: string) {
    super(message);
    this.name = 'ValidationError';
  }
}

export class NotFoundError extends Error {
  statusCode = 404;
  code = 'RESOURCE_NOT_FOUND';
  
  constructor(message: string) {
    super(message);
    this.name = 'NotFoundError';
  }
}

export class ConflictError extends Error {
  statusCode = 409;
  code = 'RESOURCE_CONFLICT';
  
  constructor(message: string) {
    super(message);
    this.name = 'ConflictError';
  }
}

export class ForbiddenError extends Error {
  statusCode = 403;
  code = 'FORBIDDEN';
  
  constructor(message: string) {
    super(message);
    this.name = 'ForbiddenError';
  }
}
```

### 統一錯誤處理 Middleware
```typescript
app.onError((err, c) => {
  console.error('Error:', err);
  
  // 已知錯誤類型
  if (err.statusCode) {
    return c.json(
      errorResponse(err.code, err.message),
      err.statusCode
    );
  }
  
  // 未知錯誤
  return c.json(
    errorResponse('INTERNAL_ERROR', '伺服器內部錯誤'),
    500
  );
});
```

### Service 層錯誤處理
```typescript
async createClient(data, userId) {
  // 驗證失敗 → 拋出 ValidationError
  if (!this.isValidClientId(data.client_id)) {
    throw new ValidationError('統一編號必須為 8 位數字');
  }
  
  // 資源衝突 → 拋出 ConflictError
  const existing = await this.repository.findByClientId(data.client_id);
  if (existing) {
    throw new ConflictError('統一編號已存在');
  }
  
  // 資源不存在 → 拋出 NotFoundError
  const user = await this.userRepository.findById(userId);
  if (!user) {
    throw new NotFoundError('使用者不存在');
  }
  
  // 權限不足 → 拋出 ForbiddenError
  if (!user.is_admin) {
    throw new ForbiddenError('僅管理員可執行此操作');
  }
}
```

---

## Middleware 設計

### authMiddleware（認證）
```typescript
export const authMiddleware = async (c, next) => {
  const token = c.req.cookie('auth_token');
  
  if (!token) {
    return c.json(errorResponse('UNAUTHORIZED', '請先登入'), 401);
  }
  
  try {
    const payload = await verifyJWT(token, c.env.JWT_SECRET);
    const user = await c.env.DB.prepare(
      'SELECT * FROM Users WHERE user_id = ? AND is_deleted = 0'
    ).bind(payload.user_id).first();
    
    if (!user) {
      return c.json(errorResponse('UNAUTHORIZED', '請先登入'), 401);
    }
    
    c.set('user', user);
    await next();
  } catch (error) {
    return c.json(errorResponse('UNAUTHORIZED', '請先登入'), 401);
  }
};
```

### requireAdmin（管理員檢查）
```typescript
export const requireAdmin = async (c, next) => {
  const user = c.get('user');
  
  if (!user.is_admin) {
    return c.json(errorResponse('FORBIDDEN', '僅管理員可訪問'), 403);
  }
  
  await next();
};
```

### checkPermission（模塊權限檢查）
```typescript
export function checkPermission(moduleName: string) {
  return async (c, next) => {
    const user = c.get('user');
    
    // 管理員跳過檢查
    if (user.is_admin) {
      await next();
      return;
    }
    
    // 查詢權限
    const permission = await c.env.DB.prepare(`
      SELECT can_access FROM ModulePermissions
      WHERE (user_id = ? OR user_id IS NULL) AND module_name = ?
      ORDER BY user_id DESC NULLS LAST
      LIMIT 1
    `).bind(user.user_id, moduleName).first();
    
    if (!permission || !permission.can_access) {
      return c.json(
        errorResponse('INSUFFICIENT_PERMISSIONS', '模塊權限未開啟'),
        403
      );
    }
    
    await next();
  };
}
```

---

## 最佳實踐

### ✅ 必須遵守
1. 清晰的分層架構（Routes → Services → Repositories）
2. 使用參數化查詢（防 SQL 注入）
3. 所有查詢自動過濾 `is_deleted = 0`
4. 使用自定義錯誤類別
5. 實現軟刪除（不實際刪除資料）
6. 記錄審計日誌（重要操作）
7. 統一響應格式

### ❌ 禁止事項
1. Route 層不寫業務邏輯
2. Service 層不直接寫 SQL
3. 不使用字串拼接 SQL
4. 不在程式碼中硬編碼業務規則
5. 不跳過權限檢查

---

## 完整範例

### 項目結構
```
src/
├── routes/
│   ├── clients.routes.js
│   ├── auth.routes.js
│   └── index.js
├── services/
│   ├── ClientService.service.js
│   ├── AuthService.service.js
│   └── index.js
├── repositories/
│   ├── ClientRepository.repository.js
│   ├── UserRepository.repository.js
│   └── index.js
├── middleware/
│   ├── auth.middleware.js
│   ├── permission.middleware.js
│   └── index.js
├── errors/
│   └── index.js
└── utils/
    ├── response.js
    └── validation.js
```

### 完整實現範例
```typescript
// routes/clients.routes.js
import { Hono } from 'hono';
import { authMiddleware, requireAdmin } from '../middleware/auth';
import { ClientService } from '../services/ClientService';

const app = new Hono();

app.post('/api/v1/clients',
  authMiddleware,
  requireAdmin,
  async (c) => {
    const service = new ClientService(c.env.DB);
    const user = c.get('user');
    const input = await c.req.json();
    
    try {
      const client = await service.createClient(input, user.user_id);
      return c.json(successResponse(client), 201);
    } catch (error) {
      // 錯誤由全局 error handler 處理
      throw error;
    }
  }
);

export default app;
```

```typescript
// services/ClientService.service.js
import { ClientRepository } from '../repositories/ClientRepository';
import { ValidationError, ConflictError } from '../errors';

export class ClientService {
  constructor(db) {
    this.repository = new ClientRepository(db);
  }
  
  async createClient(data, userId) {
    // 驗證
    this.validateClientData(data);
    
    // 檢查唯一性
    const exists = await this.repository.findByClientId(data.client_id);
    if (exists) {
      throw new ConflictError('統一編號已存在');
    }
    
    // 創建
    return await this.repository.create({
      ...data,
      created_by: userId
    });
  }
  
  private validateClientData(data) {
    if (!data.client_id || !/^\d{8}$/.test(data.client_id)) {
      throw new ValidationError('統一編號必須為 8 位數字');
    }
    
    if (!data.company_name) {
      throw new ValidationError('公司名稱為必填');
    }
  }
}
```

```typescript
// repositories/ClientRepository.repository.js
export class ClientRepository {
  constructor(db) {
    this.db = db;
  }
  
  async findAll(filters = {}) {
    let query = 'SELECT * FROM Clients WHERE is_deleted = 0';
    const params = [];
    
    if (filters.assignee_user_id) {
      query += ' AND assignee_user_id = ?';
      params.push(filters.assignee_user_id);
    }
    
    const result = await this.db.prepare(query).bind(...params).all();
    return result.results;
  }
  
  async findByClientId(clientId) {
    return await this.db.prepare(
      'SELECT * FROM Clients WHERE client_id = ? AND is_deleted = 0'
    ).bind(clientId).first();
  }
  
  async create(data) {
    const result = await this.db.prepare(`
      INSERT INTO Clients (
        client_id, company_name, assignee_user_id, created_by, created_at
      )
      VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)
    `).bind(
      data.client_id,
      data.company_name,
      data.assignee_user_id,
      data.created_by
    ).run();
    
    return await this.findByClientId(data.client_id);
  }
}
```

---

## 🔗 相關文檔

- [API 共用規範](../API規格/API共用規範.md)
- [共用業務邏輯](../技術規格/共用業務邏輯.md)
- [命名與格式規範](./命名與格式規範.md)

---

**最後更新：** 2025年10月27日  
**本文檔合併了後端開發下的所有子文檔（3個）**

