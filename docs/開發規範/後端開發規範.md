# 後端開發規範

**最後更新：** 2025年10月27日  
**適用範圍：** Cloudflare Workers API 後端開發

---

## 目錄

1. [專案架構](#1-專案架構)
2. [分層架構規範](#2-分層架構規範)
3. [API 設計規範](#3-api-設計規範)
4. [資料庫操作規範](#4-資料庫操作規範)
5. [認證與授權](#5-認證與授權)
6. [錯誤處理](#6-錯誤處理)
7. [環境配置](#7-環境配置)
8. [測試規範](#8-測試規範)
9. [部署規範](#9-部署規範)

---

## 1. 專案架構

### 1.1 目錄結構

```
timesheet-api/
├── src/
│   ├── config/              -- 配置文件
│   │   ├── database.ts
│   │   ├── auth.ts
│   │   └── constants.ts
│   │
│   ├── middlewares/         -- 中間件
│   │   ├── auth.ts          -- 認證中間件
│   │   ├── permission.ts    -- 權限檢查
│   │   ├── validation.ts    -- 請求驗證
│   │   ├── ratelimit.ts     -- 速率限制
│   │   └── audit.ts         -- 審計日誌
│   │
│   ├── repositories/        -- 資料存取層
│   │   ├── base.repository.ts
│   │   ├── user.repository.ts
│   │   ├── client.repository.ts
│   │   ├── timelog.repository.ts
│   │   └── task.repository.ts
│   │
│   ├── services/            -- 業務邏輯層
│   │   ├── auth.service.ts
│   │   ├── client.service.ts
│   │   ├── timesheet.service.ts
│   │   ├── leave.service.ts
│   │   └── task.service.ts
│   │
│   ├── routes/              -- API 路由
│   │   ├── auth.routes.ts
│   │   ├── clients.routes.ts
│   │   ├── timesheets.routes.ts
│   │   └── tasks.routes.ts
│   │
│   ├── types/               -- TypeScript 類型定義
│   │   ├── api.ts
│   │   ├── database.ts
│   │   └── auth.ts
│   │
│   ├── utils/               -- 工具函數
│   │   ├── password.ts
│   │   ├── token.ts
│   │   ├── date.ts
│   │   └── validation.ts
│   │
│   ├── errors/              -- 自訂錯誤類別
│   │   └── AppError.ts
│   │
│   └── index.ts             -- 主入口文件
│
├── migrations/              -- 資料庫遷移文件
│   ├── 0001_create_users.sql
│   ├── 0002_create_clients.sql
│   └── ...
│
├── tests/                   -- 測試文件
│   ├── unit/
│   ├── integration/
│   └── e2e/
│
├── wrangler.toml            -- Cloudflare Workers 配置
├── package.json
└── tsconfig.json
```

---

## 2. 分層架構規範

### 2.1 Repository 層（資料存取層）

**職責：** 只負責資料庫操作，不包含業務邏輯

**命名規範：** `{Resource}Repository`

**範例：**

```typescript
// src/repositories/client.repository.ts
import type { D1Database } from '@cloudflare/workers-types';
import type { Client, CreateClientData, UpdateClientData } from '@/types/client';
import { AppError } from '@/errors/AppError';

export class ClientRepository {
  constructor(private db: D1Database) {}

  /**
   * 根據 ID 查詢客戶
   */
  async findById(clientId: string): Promise<Client | null> {
    try {
      const result = await this.db
        .prepare(`
          SELECT * FROM Clients 
          WHERE client_id = ? AND is_deleted = 0
        `)
        .bind(clientId)
        .first();
      
      return result as Client | null;
    } catch (error) {
      throw new AppError(
        'DATABASE_ERROR',
        '查詢客戶失敗',
        500,
        { clientId, originalError: error }
      );
    }
  }

  /**
   * 查詢所有客戶（分頁）
   */
  async findAll(
    page: number = 1,
    limit: number = 50,
    filters?: {
      status?: string;
      search?: string;
    }
  ): Promise<{ clients: Client[]; total: number }> {
    try {
      // 構建查詢條件
      let whereClause = 'WHERE is_deleted = 0';
      const params: any[] = [];

      if (filters?.status) {
        whereClause += ' AND status = ?';
        params.push(filters.status);
      }

      if (filters?.search) {
        whereClause += ' AND (company_name LIKE ? OR contact_person LIKE ?)';
        params.push(`%${filters.search}%`, `%${filters.search}%`);
      }

      // 查詢總數
      const countResult = await this.db
        .prepare(`SELECT COUNT(*) as total FROM Clients ${whereClause}`)
        .bind(...params)
        .first();
      
      const total = (countResult as any).total;

      // 查詢資料
      const offset = (page - 1) * limit;
      const clients = await this.db
        .prepare(`
          SELECT * FROM Clients 
          ${whereClause}
          ORDER BY created_at DESC
          LIMIT ? OFFSET ?
        `)
        .bind(...params, limit, offset)
        .all();

      return {
        clients: clients.results as Client[],
        total
      };
    } catch (error) {
      throw new AppError(
        'DATABASE_ERROR',
        '查詢客戶列表失敗',
        500,
        { originalError: error }
      );
    }
  }

  /**
   * 創建客戶
   */
  async create(data: CreateClientData, userId: number): Promise<Client> {
    try {
      const now = new Date().toISOString();
      
      await this.db
        .prepare(`
          INSERT INTO Clients (
            client_id, company_name, contact_person, phone, email,
            status, created_at, updated_at, created_by, updated_by
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `)
        .bind(
          data.client_id,
          data.company_name,
          data.contact_person || null,
          data.phone || null,
          data.email || null,
          data.status || 'active',
          now,
          now,
          userId,
          userId
        )
        .run();

      // 返回創建的客戶
      const client = await this.findById(data.client_id);
      if (!client) {
        throw new AppError('CREATE_FAILED', '創建客戶後無法查詢', 500);
      }
      
      return client;
    } catch (error) {
      if (error instanceof AppError) throw error;
      
      // 檢查是否為重複鍵錯誤
      if ((error as any).message?.includes('UNIQUE')) {
        throw new AppError(
          'CLIENT_EXISTS',
          '客戶已存在',
          409,
          { client_id: data.client_id }
        );
      }
      
      throw new AppError(
        'DATABASE_ERROR',
        '創建客戶失敗',
        500,
        { originalError: error }
      );
    }
  }

  /**
   * 更新客戶
   */
  async update(
    clientId: string,
    data: UpdateClientData,
    userId: number
  ): Promise<Client> {
    try {
      // 構建更新語句
      const updateFields: string[] = [];
      const params: any[] = [];

      if (data.company_name !== undefined) {
        updateFields.push('company_name = ?');
        params.push(data.company_name);
      }

      if (data.contact_person !== undefined) {
        updateFields.push('contact_person = ?');
        params.push(data.contact_person);
      }

      if (data.phone !== undefined) {
        updateFields.push('phone = ?');
        params.push(data.phone);
      }

      if (data.email !== undefined) {
        updateFields.push('email = ?');
        params.push(data.email);
      }

      if (data.status !== undefined) {
        updateFields.push('status = ?');
        params.push(data.status);
      }

      // 添加審計欄位
      updateFields.push('updated_at = ?', 'updated_by = ?');
      params.push(new Date().toISOString(), userId);

      // 添加 WHERE 條件
      params.push(clientId);

      await this.db
        .prepare(`
          UPDATE Clients 
          SET ${updateFields.join(', ')}
          WHERE client_id = ? AND is_deleted = 0
        `)
        .bind(...params)
        .run();

      // 返回更新後的客戶
      const client = await this.findById(clientId);
      if (!client) {
        throw new AppError('NOT_FOUND', '客戶不存在', 404);
      }
      
      return client;
    } catch (error) {
      if (error instanceof AppError) throw error;
      
      throw new AppError(
        'DATABASE_ERROR',
        '更新客戶失敗',
        500,
        { originalError: error }
      );
    }
  }

  /**
   * 軟刪除客戶
   */
  async softDelete(clientId: string, userId: number): Promise<void> {
    try {
      const now = new Date().toISOString();
      
      await this.db
        .prepare(`
          UPDATE Clients 
          SET is_deleted = 1, deleted_at = ?, deleted_by = ?
          WHERE client_id = ? AND is_deleted = 0
        `)
        .bind(now, userId, clientId)
        .run();
    } catch (error) {
      throw new AppError(
        'DATABASE_ERROR',
        '刪除客戶失敗',
        500,
        { originalError: error }
      );
    }
  }

  /**
   * 檢查客戶是否有活躍的服務
   */
  async hasActiveServices(clientId: string): Promise<boolean> {
    try {
      const result = await this.db
        .prepare(`
          SELECT COUNT(*) as count 
          FROM ClientServices 
          WHERE client_id = ? AND is_active = 1
        `)
        .bind(clientId)
        .first();
      
      return (result as any).count > 0;
    } catch (error) {
      throw new AppError(
        'DATABASE_ERROR',
        '檢查客戶服務失敗',
        500,
        { originalError: error }
      );
    }
  }
}
```

**Repository 層規範：**
- ✅ 只包含 SQL 查詢
- ✅ 使用參數化查詢（防 SQL 注入）
- ✅ 拋出 AppError（統一錯誤格式）
- ✅ 不包含業務邏輯驗證
- ✅ 方法命名清晰（findById, findAll, create, update, softDelete）

---

### 2.2 Service 層（業務邏輯層）

**職責：** 處理業務邏輯、驗證、資料轉換

**命名規範：** `{Resource}Service`

**範例：**

```typescript
// src/services/client.service.ts
import { ClientRepository } from '@/repositories/client.repository';
import type { CreateClientRequest, UpdateClientRequest, Client } from '@/types/client';
import { AppError } from '@/errors/AppError';
import { validateEmail } from '@/utils/validation';

export class ClientService {
  constructor(private clientRepo: ClientRepository) {}

  /**
   * 獲取客戶詳情
   */
  async getClient(clientId: string): Promise<Client> {
    const client = await this.clientRepo.findById(clientId);
    
    if (!client) {
      throw new AppError('NOT_FOUND', '客戶不存在', 404, { clientId });
    }
    
    return client;
  }

  /**
   * 獲取客戶列表
   */
  async getClients(
    page: number = 1,
    limit: number = 50,
    filters?: {
      status?: string;
      search?: string;
    }
  ) {
    // 驗證分頁參數
    if (page < 1) {
      throw new AppError('VALIDATION_ERROR', '頁碼必須大於 0', 400);
    }
    
    if (limit < 1 || limit > 100) {
      throw new AppError('VALIDATION_ERROR', '每頁筆數必須在 1-100 之間', 400);
    }

    // 驗證 status 參數
    if (filters?.status) {
      const validStatuses = ['active', 'inactive', 'suspended'];
      if (!validStatuses.includes(filters.status)) {
        throw new AppError(
          'VALIDATION_ERROR',
          `狀態必須是 ${validStatuses.join(', ')} 之一`,
          400
        );
      }
    }

    return await this.clientRepo.findAll(page, limit, filters);
  }

  /**
   * 創建客戶
   */
  async createClient(data: CreateClientRequest, userId: number): Promise<Client> {
    // 業務邏輯驗證
    this.validateClientData(data);

    // 檢查客戶是否已存在
    const existing = await this.clientRepo.findById(data.client_id);
    if (existing) {
      throw new AppError(
        'CLIENT_EXISTS',
        '客戶已存在',
        409,
        { client_id: data.client_id }
      );
    }

    // 資料轉換
    const clientData = {
      ...data,
      status: data.status || 'active'
    };

    // 委派給 Repository
    return await this.clientRepo.create(clientData, userId);
  }

  /**
   * 更新客戶
   */
  async updateClient(
    clientId: string,
    data: UpdateClientRequest,
    userId: number
  ): Promise<Client> {
    // 檢查客戶是否存在
    await this.getClient(clientId);

    // 業務邏輯驗證（僅驗證提供的欄位）
    if (data.company_name !== undefined) {
      if (!data.company_name || data.company_name.length < 2) {
        throw new AppError(
          'VALIDATION_ERROR',
          '公司名稱至少需要 2 個字元',
          400
        );
      }
    }

    if (data.email !== undefined && data.email) {
      if (!validateEmail(data.email)) {
        throw new AppError('VALIDATION_ERROR', 'Email 格式不正確', 400);
      }
    }

    return await this.clientRepo.update(clientId, data, userId);
  }

  /**
   * 刪除客戶
   */
  async deleteClient(clientId: string, userId: number): Promise<void> {
    // 檢查客戶是否存在
    await this.getClient(clientId);

    // 業務邏輯檢查：是否有活躍的服務
    const hasServices = await this.clientRepo.hasActiveServices(clientId);
    if (hasServices) {
      throw new AppError(
        'UNPROCESSABLE',
        '無法刪除：客戶仍有進行中的服務',
        422,
        { clientId }
      );
    }

    await this.clientRepo.softDelete(clientId, userId);
  }

  /**
   * 驗證客戶資料
   */
  private validateClientData(data: CreateClientRequest): void {
    // 必填欄位驗證
    if (!data.client_id || data.client_id.length !== 8) {
      throw new AppError(
        'VALIDATION_ERROR',
        '統一編號必須是 8 位數字',
        400
      );
    }

    if (!data.company_name || data.company_name.length < 2) {
      throw new AppError(
        'VALIDATION_ERROR',
        '公司名稱至少需要 2 個字元',
        400
      );
    }

    // Email 格式驗證
    if (data.email && !validateEmail(data.email)) {
      throw new AppError('VALIDATION_ERROR', 'Email 格式不正確', 400);
    }

    // 電話格式驗證（簡單檢查）
    if (data.phone && data.phone.length < 8) {
      throw new AppError('VALIDATION_ERROR', '電話號碼格式不正確', 400);
    }
  }
}
```

**Service 層規範：**
- ✅ 包含業務邏輯驗證
- ✅ 包含資料轉換
- ✅ 檢查業務規則（如：刪除前檢查關聯）
- ✅ 不直接操作資料庫（委派給 Repository）
- ✅ 拋出有意義的業務錯誤

---

### 2.3 Route 層（API 路由層）

**職責：** 處理 HTTP 請求、路由、回應格式化

**命名規範：** `{resource}.routes.ts`

**範例：**

```typescript
// src/routes/clients.routes.ts
import { Hono } from 'hono';
import { ClientService } from '@/services/client.service';
import { ClientRepository } from '@/repositories/client.repository';
import { requireAuth, requirePermission } from '@/middlewares/auth';
import { AppError } from '@/errors/AppError';
import type { Context } from 'hono';

const app = new Hono();

/**
 * 獲取客戶列表
 */
app.get('/',
  requireAuth,
  requirePermission('client_management'),
  async (c: Context) => {
    try {
      // 1. 解析請求參數
      const page = Number(c.req.query('page')) || 1;
      const limit = Number(c.req.query('limit')) || 50;
      const status = c.req.query('status');
      const search = c.req.query('search');

      // 2. 初始化 Service
      const clientRepo = new ClientRepository(c.env.DB);
      const clientService = new ClientService(clientRepo);

      // 3. 執行業務邏輯
      const result = await clientService.getClients(page, limit, {
        status,
        search
      });

      // 4. 格式化回應
      return c.json({
        success: true,
        data: result.clients,
        meta: {
          page,
          limit,
          total: result.total,
          total_pages: Math.ceil(result.total / limit)
        }
      }, 200);
    } catch (error) {
      return handleError(c, error);
    }
  }
);

/**
 * 獲取單一客戶
 */
app.get('/:id',
  requireAuth,
  requirePermission('client_management'),
  async (c: Context) => {
    try {
      const clientId = c.req.param('id');

      const clientRepo = new ClientRepository(c.env.DB);
      const clientService = new ClientService(clientRepo);

      const client = await clientService.getClient(clientId);

      return c.json({
        success: true,
        data: client
      }, 200);
    } catch (error) {
      return handleError(c, error);
    }
  }
);

/**
 * 創建客戶
 */
app.post('/',
  requireAuth,
  requirePermission('client_management'),
  async (c: Context) => {
    try {
      // 1. 解析請求 Body
      const body = await c.req.json();

      // 2. 獲取當前用戶 ID
      const userId = c.get('userId');

      // 3. 執行業務邏輯
      const clientRepo = new ClientRepository(c.env.DB);
      const clientService = new ClientService(clientRepo);

      const client = await clientService.createClient(body, userId);

      // 4. 返回創建結果
      return c.json({
        success: true,
        data: client
      }, 201);
    } catch (error) {
      return handleError(c, error);
    }
  }
);

/**
 * 更新客戶
 */
app.put('/:id',
  requireAuth,
  requirePermission('client_management'),
  async (c: Context) => {
    try {
      const clientId = c.req.param('id');
      const body = await c.req.json();
      const userId = c.get('userId');

      const clientRepo = new ClientRepository(c.env.DB);
      const clientService = new ClientService(clientRepo);

      const client = await clientService.updateClient(clientId, body, userId);

      return c.json({
        success: true,
        data: client
      }, 200);
    } catch (error) {
      return handleError(c, error);
    }
  }
);

/**
 * 刪除客戶
 */
app.delete('/:id',
  requireAuth,
  requirePermission('client_management'),
  async (c: Context) => {
    try {
      const clientId = c.req.param('id');
      const userId = c.get('userId');

      const clientRepo = new ClientRepository(c.env.DB);
      const clientService = new ClientService(clientRepo);

      await clientService.deleteClient(clientId, userId);

      return c.body(null, 204);
    } catch (error) {
      return handleError(c, error);
    }
  }
);

/**
 * 統一錯誤處理
 */
function handleError(c: Context, error: unknown) {
  if (error instanceof AppError) {
    return c.json({
      success: false,
      error: {
        code: error.code,
        message: error.message,
        details: error.details
      }
    }, error.statusCode);
  }

  // 未預期的錯誤
  console.error('Unexpected error:', error);
  return c.json({
    success: false,
    error: {
      code: 'SERVER_ERROR',
      message: '伺服器發生錯誤'
    }
  }, 500);
}

export default app;
```

**Route 層規範：**
- ✅ 只負責 HTTP 相關邏輯
- ✅ 解析請求參數
- ✅ 委派給 Service 處理業務邏輯
- ✅ 格式化回應
- ✅ 統一錯誤處理
- ✅ 使用中間件進行認證和權限檢查

---

## 3. API 設計規範

### 3.1 端點命名

遵循 RESTful 標準：

```
GET    /api/v1/clients              -- 獲取列表
GET    /api/v1/clients/:id          -- 獲取單一
POST   /api/v1/clients              -- 創建
PUT    /api/v1/clients/:id          -- 完整更新
PATCH  /api/v1/clients/:id          -- 部分更新
DELETE /api/v1/clients/:id          -- 刪除

GET    /api/v1/clients/:id/services -- 子資源
```

詳細規範請參考：[API 標準規範](../API設計/00-API標準規範.md)

---

### 3.2 回應格式

**成功回應：**

```typescript
{
  success: true,
  data: { ... },
  meta: { page, limit, total }  // 分頁資訊（可選）
}
```

**錯誤回應：**

```typescript
{
  success: false,
  error: {
    code: 'ERROR_CODE',
    message: '錯誤訊息',
    details: { ... }  // 詳細資訊（可選）
  }
}
```

---

## 4. 資料庫操作規範

### 4.1 參數化查詢

**必須使用參數化查詢（防 SQL 注入）：**

```typescript
✅ 正確：
const result = await db.prepare(
  'SELECT * FROM Users WHERE user_id = ?'
).bind(userId).first();

❌ 錯誤（SQL 注入風險）：
const result = await db.prepare(
  `SELECT * FROM Users WHERE user_id = ${userId}`
).first();
```

---

### 4.2 事務處理

```typescript
// Cloudflare D1 事務
const result = await db.batch([
  db.prepare('INSERT INTO Clients (...) VALUES (...)').bind(...),
  db.prepare('INSERT INTO ClientServices (...) VALUES (...)').bind(...)
]);
```

---

### 4.3 錯誤處理

```typescript
try {
  const result = await db.prepare(...).run();
} catch (error) {
  // 檢查特定錯誤類型
  if ((error as any).message?.includes('UNIQUE')) {
    throw new AppError('CONFLICT', '資源已存在', 409);
  }
  
  throw new AppError('DATABASE_ERROR', '資料庫操作失敗', 500, { originalError: error });
}
```

---

## 5. 認證與授權

### 5.1 認證中間件

```typescript
// src/middlewares/auth.ts
import { Context, Next } from 'hono';
import { verifyToken } from '@/utils/token';
import { AppError } from '@/errors/AppError';

export const requireAuth = async (c: Context, next: Next) => {
  const authHeader = c.req.header('Authorization');
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    throw new AppError('UNAUTHORIZED', '未提供認證令牌', 401);
  }

  const token = authHeader.replace('Bearer ', '');
  
  try {
    const payload = await verifyToken(token, c.env.JWT_SECRET);
    
    // 將用戶資訊存入 context
    c.set('userId', payload.userId);
    c.set('isAdmin', payload.isAdmin);
    
    await next();
  } catch (error) {
    throw new AppError('UNAUTHORIZED', '認證令牌無效或已過期', 401);
  }
};
```

---

### 5.2 權限檢查中間件

```typescript
// src/middlewares/permission.ts
import { Context, Next } from 'hono';
import { AppError } from '@/errors/AppError';
import { checkModulePermission } from '@/services/permission.service';

export const requirePermission = (moduleName: string) => {
  return async (c: Context, next: Next) => {
    const userId = c.get('userId');
    const isAdmin = c.get('isAdmin');

    // 管理員擁有所有權限
    if (isAdmin) {
      await next();
      return;
    }

    // 檢查員工權限
    const hasPermission = await checkModulePermission(
      c.env.DB,
      userId,
      moduleName
    );

    if (!hasPermission) {
      throw new AppError(
        'FORBIDDEN',
        '您沒有權限存取此資源',
        403,
        { required_permission: moduleName }
      );
    }

    await next();
  };
};
```

---

## 6. 錯誤處理

詳細規範請參考：[錯誤處理規範](./錯誤處理規範.md)

**自訂錯誤類別：**

```typescript
// src/errors/AppError.ts
export class AppError extends Error {
  constructor(
    public code: string,
    public message: string,
    public statusCode: number = 500,
    public details?: any
  ) {
    super(message);
    this.name = 'AppError';
  }
}
```

**使用範例：**

```typescript
throw new AppError(
  'VALIDATION_ERROR',
  '請求參數驗證失敗',
  400,
  { field: 'email', issue: '格式不正確' }
);
```

---

## 7. 環境配置

### 7.1 環境變數

```toml
# wrangler.toml
name = "timesheet-api"
main = "src/index.ts"
compatibility_date = "2025-10-27"

[vars]
ENVIRONMENT = "production"

[[d1_databases]]
binding = "DB"
database_name = "timesheet-db"
database_id = "xxx"

[secrets]
JWT_SECRET = "xxx"  # 使用 wrangler secret put JWT_SECRET
```

---

### 7.2 配置管理

```typescript
// src/config/constants.ts
export const CONFIG = {
  JWT_EXPIRES_IN: 3600, // 1 hour
  MAX_PAGE_SIZE: 100,
  DEFAULT_PAGE_SIZE: 50,
  RATE_LIMIT: {
    GENERAL: 100, // requests per minute
    LOGIN: 5      // requests per minute
  }
};
```

---

## 8. 測試規範

### 8.1 單元測試

```typescript
// tests/unit/services/client.service.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { ClientService } from '@/services/client.service';
import { ClientRepository } from '@/repositories/client.repository';

describe('ClientService', () => {
  let clientService: ClientService;
  let mockClientRepo: ClientRepository;

  beforeEach(() => {
    // Mock Repository
    mockClientRepo = {
      findById: async (id) => ({ client_id: id, company_name: 'Test' }),
      create: async (data) => ({ ...data, client_id: '12345678' })
    } as any;

    clientService = new ClientService(mockClientRepo);
  });

  describe('createClient', () => {
    it('應該成功創建客戶', async () => {
      const data = {
        client_id: '12345678',
        company_name: '測試公司',
        contact_person: '王小明'
      };

      const result = await clientService.createClient(data, 1);

      expect(result).toBeDefined();
      expect(result.company_name).toBe('測試公司');
    });

    it('應該拋出錯誤當公司名稱太短', async () => {
      const data = {
        client_id: '12345678',
        company_name: 'A'  // 只有1個字元
      };

      await expect(
        clientService.createClient(data, 1)
      ).rejects.toThrow('公司名稱至少需要 2 個字元');
    });
  });
});
```

---

### 8.2 整合測試

```typescript
// tests/integration/api/clients.test.ts
import { describe, it, expect, beforeAll } from 'vitest';

describe('Clients API', () => {
  let authToken: string;

  beforeAll(async () => {
    // 登入獲取 token
    const response = await fetch('http://localhost:8787/api/v1/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        username: 'admin@example.com',
        password: 'password123'
      })
    });
    
    const data = await response.json();
    authToken = data.data.access_token;
  });

  it('應該成功獲取客戶列表', async () => {
    const response = await fetch('http://localhost:8787/api/v1/clients', {
      headers: { 'Authorization': `Bearer ${authToken}` }
    });

    expect(response.status).toBe(200);
    
    const data = await response.json();
    expect(data.success).toBe(true);
    expect(Array.isArray(data.data)).toBe(true);
  });

  it('應該拒絕未認證的請求', async () => {
    const response = await fetch('http://localhost:8787/api/v1/clients');

    expect(response.status).toBe(401);
    
    const data = await response.json();
    expect(data.success).toBe(false);
    expect(data.error.code).toBe('UNAUTHORIZED');
  });
});
```

---

## 9. 部署規範

### 9.1 部署前檢查清單

- [ ] 所有測試通過
- [ ] 環境變數已設定
- [ ] Secrets 已上傳（JWT_SECRET）
- [ ] 資料庫遷移已執行
- [ ] API 文檔已更新
- [ ] 版本號已更新

---

### 9.2 部署指令

```bash
# 本地開發
npm run dev

# 執行測試
npm run test

# 部署到生產環境
wrangler deploy

# 查看日誌
wrangler tail
```

---

## 10. 相關文檔

- [代碼規範](./代碼規範.md)
- [錯誤處理規範](./錯誤處理規範.md)
- [API 標準規範](../API設計/00-API標準規範.md)
- [專案開發規格總覽](../AI開發指南/專案開發規格總覽.md)

---

**最後更新：** 2025年10月27日  
**文檔版本：** 1.0


