# 錯誤處理規範

**最後更新：** 2025年10月27日  
**適用範圍：** 前端和後端錯誤處理

---

## 目錄

1. [錯誤處理原則](#1-錯誤處理原則)
2. [後端錯誤處理](#2-後端錯誤處理)
3. [前端錯誤處理](#3-前端錯誤處理)
4. [錯誤代碼標準](#4-錯誤代碼標準)
5. [錯誤訊息撰寫](#5-錯誤訊息撰寫)
6. [日誌記錄](#6-日誌記錄)

---

## 1. 錯誤處理原則

### 1.1 核心原則

**DO（應該做的）：**
- ✅ 使用統一的錯誤格式
- ✅ 提供清晰的錯誤訊息
- ✅ 記錄詳細的錯誤日誌
- ✅ 區分預期錯誤和未預期錯誤
- ✅ 在適當的層級捕獲錯誤
- ✅ 向用戶隱藏敏感資訊

**DON'T（不應該做的）：**
- ❌ 吞掉錯誤（catch 後不處理）
- ❌ 在多層重複捕獲同一個錯誤
- ❌ 向用戶顯示技術細節
- ❌ 使用 console.log 記錄錯誤（應使用專用日誌系統）
- ❌ 忽略錯誤類型，統一返回 500

---

### 1.2 錯誤分類

**1. 客戶端錯誤（4xx）：**
- 用戶輸入錯誤
- 缺少權限
- 資源不存在
- 業務邏輯不允許

**2. 伺服器錯誤（5xx）：**
- 資料庫錯誤
- 外部 API 錯誤
- 程式錯誤（bug）
- 系統資源不足

---

## 2. 後端錯誤處理

### 2.1 自訂錯誤類別

**AppError 類別定義：**

```typescript
// src/errors/AppError.ts

/**
 * 應用程式自訂錯誤類別
 * 所有業務邏輯錯誤都應該使用此類別
 */
export class AppError extends Error {
  /**
   * @param code - 錯誤代碼（機器可讀）
   * @param message - 錯誤訊息（人類可讀）
   * @param statusCode - HTTP 狀態碼
   * @param details - 詳細資訊（可選）
   */
  constructor(
    public code: string,
    public message: string,
    public statusCode: number = 500,
    public details?: any
  ) {
    super(message);
    this.name = 'AppError';
    
    // 保持正確的 stack trace（V8 引擎）
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, AppError);
    }
  }

  /**
   * 轉換為 JSON 格式（用於 API 回應）
   */
  toJSON() {
    return {
      code: this.code,
      message: this.message,
      details: this.details
    };
  }
}
```

---

### 2.2 Repository 層錯誤處理

**原則：** 捕獲資料庫錯誤，轉換為 AppError

```typescript
export class ClientRepository {
  async findById(clientId: string): Promise<Client | null> {
    try {
      const result = await this.db
        .prepare('SELECT * FROM Clients WHERE client_id = ?')
        .bind(clientId)
        .first();
      
      return result as Client | null;
    } catch (error) {
      // 記錄原始錯誤（用於調試）
      console.error('[ClientRepository.findById] Database error:', {
        clientId,
        error: error instanceof Error ? error.message : error
      });

      // 拋出統一的錯誤
      throw new AppError(
        'DATABASE_ERROR',
        '查詢客戶失敗',
        500,
        { 
          clientId,
          originalError: error instanceof Error ? error.message : String(error)
        }
      );
    }
  }

  async create(data: CreateClientData, userId: number): Promise<Client> {
    try {
      await this.db
        .prepare('INSERT INTO Clients (...) VALUES (...)')
        .bind(...)
        .run();

      return await this.findById(data.client_id);
    } catch (error) {
      // 檢查特定錯誤類型
      if (error instanceof Error) {
        // 唯一鍵衝突
        if (error.message.includes('UNIQUE')) {
          throw new AppError(
            'CLIENT_EXISTS',
            '客戶已存在',
            409,
            { client_id: data.client_id }
          );
        }

        // 外鍵約束錯誤
        if (error.message.includes('FOREIGN KEY')) {
          throw new AppError(
            'INVALID_REFERENCE',
            '引用的資源不存在',
            400,
            { error: error.message }
          );
        }
      }

      // 其他資料庫錯誤
      console.error('[ClientRepository.create] Database error:', error);
      throw new AppError(
        'DATABASE_ERROR',
        '創建客戶失敗',
        500,
        { originalError: error instanceof Error ? error.message : String(error) }
      );
    }
  }
}
```

---

### 2.3 Service 層錯誤處理

**原則：** 處理業務邏輯錯誤，拋出有意義的 AppError

```typescript
export class ClientService {
  async createClient(data: CreateClientRequest, userId: number): Promise<Client> {
    // 1. 輸入驗證
    this.validateClientData(data);

    // 2. 業務邏輯檢查
    const existing = await this.clientRepo.findById(data.client_id);
    if (existing) {
      throw new AppError(
        'CLIENT_EXISTS',
        '客戶已存在',
        409,
        { client_id: data.client_id }
      );
    }

    // 3. 執行操作（Repository 會拋出 AppError）
    try {
      return await this.clientRepo.create(data, userId);
    } catch (error) {
      // Service 層通常只需要重新拋出 Repository 的錯誤
      // 除非需要添加額外的業務上下文
      if (error instanceof AppError) {
        throw error;
      }
      
      // 未預期的錯誤
      console.error('[ClientService.createClient] Unexpected error:', error);
      throw new AppError(
        'SERVER_ERROR',
        '創建客戶時發生錯誤',
        500
      );
    }
  }

  /**
   * 驗證客戶資料
   * @throws {AppError} VALIDATION_ERROR
   */
  private validateClientData(data: CreateClientRequest): void {
    const errors: Record<string, string> = {};

    // 統一編號驗證
    if (!data.client_id) {
      errors.client_id = '統一編號為必填';
    } else if (!/^\d{8}$/.test(data.client_id)) {
      errors.client_id = '統一編號必須是 8 位數字';
    }

    // 公司名稱驗證
    if (!data.company_name) {
      errors.company_name = '公司名稱為必填';
    } else if (data.company_name.length < 2) {
      errors.company_name = '公司名稱至少需要 2 個字元';
    }

    // Email 驗證
    if (data.email && !this.isValidEmail(data.email)) {
      errors.email = 'Email 格式不正確';
    }

    // 如果有驗證錯誤，拋出統一的錯誤
    if (Object.keys(errors).length > 0) {
      throw new AppError(
        'VALIDATION_ERROR',
        '請求參數驗證失敗',
        400,
        { fields: errors }
      );
    }
  }

  async deleteClient(clientId: string, userId: number): Promise<void> {
    // 檢查客戶是否存在
    const client = await this.clientRepo.findById(clientId);
    if (!client) {
      throw new AppError(
        'NOT_FOUND',
        '客戶不存在',
        404,
        { client_id: clientId }
      );
    }

    // 業務規則檢查：是否有活躍的服務
    const hasServices = await this.clientRepo.hasActiveServices(clientId);
    if (hasServices) {
      throw new AppError(
        'UNPROCESSABLE',
        '無法刪除：客戶仍有進行中的服務',
        422,
        { 
          client_id: clientId,
          reason: 'has_active_services'
        }
      );
    }

    // 執行刪除
    await this.clientRepo.softDelete(clientId, userId);
  }
}
```

---

### 2.4 Route 層錯誤處理

**原則：** 捕獲所有錯誤，格式化為統一的 API 回應

```typescript
// src/routes/clients.routes.ts
import { Hono } from 'hono';
import { AppError } from '@/errors/AppError';

const app = new Hono();

/**
 * 創建客戶
 */
app.post('/', requireAuth, requirePermission('client_management'),
  async (c) => {
    try {
      const body = await c.req.json();
      const userId = c.get('userId');

      const clientRepo = new ClientRepository(c.env.DB);
      const clientService = new ClientService(clientRepo);

      const client = await clientService.createClient(body, userId);

      return c.json({
        success: true,
        data: client
      }, 201);
    } catch (error) {
      return handleError(c, error);
    }
  }
);

/**
 * 統一錯誤處理函數
 */
function handleError(c: Context, error: unknown) {
  // 1. 預期的業務錯誤（AppError）
  if (error instanceof AppError) {
    // 記錄錯誤（僅記錄關鍵資訊）
    if (error.statusCode >= 500) {
      console.error('[API Error]', {
        code: error.code,
        message: error.message,
        statusCode: error.statusCode,
        details: error.details,
        stack: error.stack
      });
    }

    // 返回格式化的錯誤回應
    return c.json({
      success: false,
      error: {
        code: error.code,
        message: error.message,
        details: error.details
      }
    }, error.statusCode);
  }

  // 2. 未預期的錯誤
  console.error('[Unexpected Error]', {
    error: error instanceof Error ? {
      name: error.name,
      message: error.message,
      stack: error.stack
    } : error,
    path: c.req.path,
    method: c.req.method
  });

  // 返回通用錯誤（隱藏技術細節）
  return c.json({
    success: false,
    error: {
      code: 'SERVER_ERROR',
      message: '伺服器發生錯誤，請稍後再試'
    }
  }, 500);
}

export default app;
```

---

### 2.5 中間件錯誤處理

```typescript
// src/middlewares/auth.ts
import { AppError } from '@/errors/AppError';

export const requireAuth = async (c: Context, next: Next) => {
  const authHeader = c.req.header('Authorization');
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    throw new AppError('UNAUTHORIZED', '未提供認證令牌', 401);
  }

  const token = authHeader.replace('Bearer ', '');
  
  try {
    const payload = await verifyToken(token, c.env.JWT_SECRET);
    c.set('userId', payload.userId);
    c.set('isAdmin', payload.isAdmin);
    await next();
  } catch (error) {
    // Token 驗證失敗
    throw new AppError(
      'UNAUTHORIZED',
      '認證令牌無效或已過期',
      401,
      { reason: 'token_verification_failed' }
    );
  }
};

// src/middlewares/permission.ts
export const requirePermission = (moduleName: string) => {
  return async (c: Context, next: Next) => {
    const userId = c.get('userId');
    const isAdmin = c.get('isAdmin');

    if (isAdmin) {
      await next();
      return;
    }

    const hasPermission = await checkModulePermission(
      c.env.DB,
      userId,
      moduleName
    );

    if (!hasPermission) {
      throw new AppError(
        'FORBIDDEN',
        '您沒有權限存取此資源',
        403,
        { 
          required_permission: moduleName,
          user_id: userId
        }
      );
    }

    await next();
  };
};
```

---

## 3. 前端錯誤處理

### 3.1 API 呼叫錯誤處理

**統一的 API 客戶端：**

```typescript
// src/api/client.ts
import type { ApiResponse, ApiError } from '@/types/api';

class ApiClient {
  private baseURL = import.meta.env.VITE_API_BASE_URL || '/api/v1';

  /**
   * 統一的請求處理
   */
  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    try {
      // 添加認證 token
      const token = localStorage.getItem('access_token');
      const headers: HeadersInit = {
        'Content-Type': 'application/json',
        ...options.headers
      };

      if (token) {
        headers['Authorization'] = `Bearer ${token}`;
      }

      // 發送請求
      const response = await fetch(`${this.baseURL}${endpoint}`, {
        ...options,
        headers
      });

      // 解析回應
      const data: ApiResponse<T> = await response.json();

      // 成功回應
      if (response.ok && data.success) {
        return data.data;
      }

      // API 錯誤回應
      throw new ApiError(
        data.error?.code || 'UNKNOWN_ERROR',
        data.error?.message || '請求失敗',
        response.status,
        data.error?.details
      );
    } catch (error) {
      // 網路錯誤或其他錯誤
      if (error instanceof ApiError) {
        throw error;
      }

      if (error instanceof TypeError && error.message.includes('fetch')) {
        throw new ApiError(
          'NETWORK_ERROR',
          '網路連線失敗，請檢查您的網路連線',
          0
        );
      }

      throw new ApiError(
        'UNKNOWN_ERROR',
        '發生未知錯誤',
        500,
        { originalError: error }
      );
    }
  }

  // GET 請求
  async get<T>(endpoint: string): Promise<T> {
    return this.request<T>(endpoint, { method: 'GET' });
  }

  // POST 請求
  async post<T>(endpoint: string, body: any): Promise<T> {
    return this.request<T>(endpoint, {
      method: 'POST',
      body: JSON.stringify(body)
    });
  }

  // PUT 請求
  async put<T>(endpoint: string, body: any): Promise<T> {
    return this.request<T>(endpoint, {
      method: 'PUT',
      body: JSON.stringify(body)
    });
  }

  // DELETE 請求
  async delete<T>(endpoint: string): Promise<T> {
    return this.request<T>(endpoint, { method: 'DELETE' });
  }
}

export const apiClient = new ApiClient();

/**
 * 自訂 API 錯誤類別
 */
export class ApiError extends Error {
  constructor(
    public code: string,
    public message: string,
    public statusCode: number,
    public details?: any
  ) {
    super(message);
    this.name = 'ApiError';
  }
}
```

---

### 3.2 Vue 組件錯誤處理

**組件內錯誤處理：**

```vue
<script setup lang="ts">
import { ref } from 'vue';
import { apiClient, ApiError } from '@/api/client';
import { useToast } from '@/composables/useToast';

const toast = useToast();
const isLoading = ref(false);
const error = ref<string | null>(null);

const handleSubmit = async () => {
  // 清除之前的錯誤
  error.value = null;
  isLoading.value = true;

  try {
    const result = await apiClient.post('/clients', form.value);
    
    // 成功處理
    toast.success('客戶創建成功');
    router.push(`/clients/${result.client_id}`);
  } catch (err) {
    // 錯誤處理
    if (err instanceof ApiError) {
      // API 錯誤
      handleApiError(err);
    } else {
      // 未預期的錯誤
      console.error('Unexpected error:', err);
      error.value = '發生未知錯誤，請稍後再試';
      toast.error('操作失敗');
    }
  } finally {
    isLoading.value = false;
  }
};

const handleApiError = (err: ApiError) => {
  switch (err.code) {
    case 'VALIDATION_ERROR':
      // 顯示欄位驗證錯誤
      if (err.details?.fields) {
        Object.entries(err.details.fields).forEach(([field, message]) => {
          fieldErrors.value[field] = message as string;
        });
      }
      error.value = err.message;
      break;

    case 'CLIENT_EXISTS':
      error.value = '此統一編號已存在';
      break;

    case 'UNAUTHORIZED':
      // 跳轉到登入頁
      router.push('/login');
      toast.error('請先登入');
      break;

    case 'FORBIDDEN':
      error.value = '您沒有權限執行此操作';
      toast.error('權限不足');
      break;

    case 'NETWORK_ERROR':
      error.value = '網路連線失敗，請檢查您的網路';
      toast.error('網路錯誤');
      break;

    default:
      error.value = err.message || '操作失敗，請稍後再試';
      toast.error('操作失敗');
  }
};
</script>

<template>
  <form @submit.prevent="handleSubmit">
    <!-- 全局錯誤訊息 -->
    <div v-if="error" class="p-4 bg-red-50 border border-red-200 rounded mb-4">
      <p class="text-sm text-red-600">{{ error }}</p>
    </div>

    <!-- 表單欄位 -->
    <div class="form-group">
      <label for="company-name">公司名稱</label>
      <input
        id="company-name"
        v-model="form.company_name"
        :class="{ 'border-red-500': fieldErrors.company_name }"
      />
      <span v-if="fieldErrors.company_name" class="text-sm text-red-600">
        {{ fieldErrors.company_name }}
      </span>
    </div>

    <button type="submit" :disabled="isLoading">
      {{ isLoading ? '儲存中...' : '儲存' }}
    </button>
  </form>
</template>
```

---

### 3.3 全局錯誤處理

```typescript
// src/main.ts
import { createApp } from 'vue';
import App from './App.vue';
import router from './router';

const app = createApp(App);

// 全局錯誤處理器
app.config.errorHandler = (err, instance, info) => {
  console.error('[Vue Error Handler]', {
    error: err,
    component: instance?.$options.name,
    info
  });

  // 顯示友好的錯誤訊息給用戶
  // 可以使用 toast 或其他通知系統
};

// 全局警告處理器（僅開發環境）
if (import.meta.env.DEV) {
  app.config.warnHandler = (msg, instance, trace) => {
    console.warn('[Vue Warning]', { msg, component: instance?.$options.name, trace });
  };
}

// 未捕獲的 Promise 錯誤
window.addEventListener('unhandledrejection', (event) => {
  console.error('[Unhandled Promise Rejection]', event.reason);
  event.preventDefault();
  
  // 顯示友好的錯誤訊息
  // toast.error('發生未預期的錯誤');
});

app.use(router);
app.mount('#app');
```

---

## 4. 錯誤代碼標準

### 4.1 通用錯誤代碼

```typescript
// 認證與授權
'UNAUTHORIZED'          // 401 - 未登入或 token 無效
'FORBIDDEN'             // 403 - 無權限
'TOKEN_EXPIRED'         // 401 - Token 已過期

// 請求驗證
'VALIDATION_ERROR'      // 400 - 參數驗證失敗
'MISSING_PARAMETER'     // 400 - 缺少必填參數
'INVALID_FORMAT'        // 400 - 格式不正確

// 資源操作
'NOT_FOUND'             // 404 - 資源不存在
'CONFLICT'              // 409 - 資源衝突
'UNPROCESSABLE'         // 422 - 業務邏輯驗證失敗

// 伺服器錯誤
'DATABASE_ERROR'        // 500 - 資料庫錯誤
'SERVER_ERROR'          // 500 - 伺服器錯誤
'SERVICE_UNAVAILABLE'   // 503 - 服務暫時無法使用
'NETWORK_ERROR'         // 0   - 網路連線失敗（前端）
```

### 4.2 模塊特定錯誤代碼

```typescript
// 客戶管理
'CLIENT_NOT_FOUND'      // 404 - 客戶不存在
'CLIENT_EXISTS'         // 409 - 客戶已存在
'CLIENT_HAS_SERVICES'   // 422 - 客戶仍有服務

// 任務管理
'TASK_NOT_FOUND'        // 404 - 任務不存在
'STAGE_LOCKED'          // 422 - 階段已鎖定
'TASK_COMPLETED'        // 422 - 任務已完成

// 權限管理
'PERMISSION_DENIED'     // 403 - 權限不足
'INVALID_PERMISSION'    // 400 - 無效的權限名稱
```

---

## 5. 錯誤訊息撰寫

### 5.1 撰寫原則

**DO（應該做的）：**
- ✅ 使用清晰、簡潔的語言
- ✅ 說明發生什麼問題
- ✅ 提供解決建議（如果可能）
- ✅ 使用用戶能理解的術語

**DON'T（不應該做的）：**
- ❌ 使用技術術語（如"NullPointerException"）
- ❌ 責怪用戶（如"你輸入的資料錯誤"）
- ❌ 過於模糊（如"錯誤"、"失敗"）
- ❌ 暴露敏感資訊（如資料庫結構、檔案路徑）

---

### 5.2 錯誤訊息範例

**✅ 好的錯誤訊息：**

```
❌ "客戶不存在"
✅ "找不到此客戶，請確認統一編號是否正確"

❌ "驗證失敗"
✅ "公司名稱至少需要 2 個字元"

❌ "權限不足"
✅ "您沒有權限存取客戶管理功能，請聯繫管理員"

❌ "錯誤"
✅ "網路連線失敗，請檢查您的網路連線後重試"

❌ "資料庫查詢失敗：SQLSTATE[42S02]"
✅ "系統暫時無法處理您的請求，請稍後再試"
```

---

### 5.3 多語言錯誤訊息

```typescript
// src/i18n/errors.ts
export const errorMessages = {
  'zh-TW': {
    'VALIDATION_ERROR': '請求參數驗證失敗',
    'NOT_FOUND': '資源不存在',
    'UNAUTHORIZED': '請先登入',
    'FORBIDDEN': '您沒有權限執行此操作',
    'CLIENT_EXISTS': '此客戶已存在'
  },
  'en-US': {
    'VALIDATION_ERROR': 'Validation failed',
    'NOT_FOUND': 'Resource not found',
    'UNAUTHORIZED': 'Please sign in',
    'FORBIDDEN': 'Permission denied',
    'CLIENT_EXISTS': 'Client already exists'
  }
};

export function getErrorMessage(code: string, locale: string = 'zh-TW'): string {
  return errorMessages[locale]?.[code] || errorMessages['zh-TW'][code] || '發生錯誤';
}
```

---

## 6. 日誌記錄

### 6.1 日誌級別

```typescript
enum LogLevel {
  DEBUG = 'debug',    // 調試資訊
  INFO = 'info',      // 一般資訊
  WARN = 'warn',      // 警告
  ERROR = 'error',    // 錯誤
  FATAL = 'fatal'     // 致命錯誤
}
```

---

### 6.2 後端日誌記錄

```typescript
// src/utils/logger.ts
export const logger = {
  debug(message: string, meta?: any) {
    if (process.env.NODE_ENV === 'development') {
      console.debug('[DEBUG]', message, meta);
    }
  },

  info(message: string, meta?: any) {
    console.log('[INFO]', message, meta);
  },

  warn(message: string, meta?: any) {
    console.warn('[WARN]', message, meta);
  },

  error(message: string, error?: Error | unknown, meta?: any) {
    console.error('[ERROR]', message, {
      error: error instanceof Error ? {
        name: error.name,
        message: error.message,
        stack: error.stack
      } : error,
      ...meta
    });
  },

  fatal(message: string, error?: Error | unknown, meta?: any) {
    console.error('[FATAL]', message, {
      error: error instanceof Error ? {
        name: error.name,
        message: error.message,
        stack: error.stack
      } : error,
      ...meta
    });
  }
};
```

**使用範例：**

```typescript
try {
  const client = await this.clientRepo.findById(clientId);
  logger.info('Client retrieved successfully', { clientId });
} catch (error) {
  logger.error('Failed to retrieve client', error, { clientId });
  throw error;
}
```

---

### 6.3 前端錯誤追蹤

**整合 Sentry（可選）：**

```typescript
// src/main.ts
import * as Sentry from '@sentry/vue';

if (import.meta.env.PROD) {
  Sentry.init({
    app,
    dsn: import.meta.env.VITE_SENTRY_DSN,
    integrations: [
      new Sentry.BrowserTracing({
        routingInstrumentation: Sentry.vueRouterInstrumentation(router)
      }),
      new Sentry.Replay()
    ],
    tracesSampleRate: 0.1,
    replaysSessionSampleRate: 0.1,
    replaysOnErrorSampleRate: 1.0
  });
}
```

---

## 7. 錯誤處理檢查清單

### 7.1 後端檢查清單

- [ ] 使用 AppError 類別拋出所有業務錯誤
- [ ] Repository 層捕獲並轉換資料庫錯誤
- [ ] Service 層進行業務邏輯驗證
- [ ] Route 層統一處理錯誤回應
- [ ] 中間件拋出適當的認證/授權錯誤
- [ ] 所有錯誤都有明確的錯誤代碼
- [ ] 錯誤訊息清晰且對用戶友好
- [ ] 敏感資訊不暴露給用戶
- [ ] 所有錯誤都有適當的日誌記錄
- [ ] 使用參數化查詢防止 SQL 注入

### 7.2 前端檢查清單

- [ ] API 客戶端統一處理錯誤
- [ ] 組件中正確捕獲和顯示錯誤
- [ ] 網路錯誤有友好的提示
- [ ] 認證錯誤會跳轉到登入頁
- [ ] 驗證錯誤顯示在對應欄位
- [ ] 有全局錯誤處理器
- [ ] Loading 狀態正確管理
- [ ] 錯誤狀態可以清除
- [ ] 有未處理 Promise 錯誤的捕獲

---

## 8. 相關文檔

- [代碼規範](./代碼規範.md)
- [後端開發規範](./後端開發規範.md)
- [前端開發規範](./前端開發規範.md)
- [API 標準規範](../API設計/00-API標準規範.md)

---

**最後更新：** 2025年10月27日  
**文檔版本：** 1.0


