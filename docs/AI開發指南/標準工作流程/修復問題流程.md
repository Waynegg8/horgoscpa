# 修復問題標準流程

**最後更新：** 2025年10月27日

---

## AI自動執行步驟

當識別到"修復問題"任務時，AI自動按以下步驟執行，**無需用戶提醒**。

---

## 步驟 1：診斷階段（深入追問找根本原因）

### AI自動執行：

```
AI會持續追問"為什麼"，直到找出根本原因（不限5次）
重點不是問幾次，而是是否找到根本原因
根本原因通常是：設計缺陷、邏輯錯誤、缺少驗證
```

### AI自動提問（逐層深入）：

**第一個為什麼：問題是什麼？**
```
Q: 能詳細描述一下問題嗎？
Q: 什麼時候發生的？
Q: 錯誤訊息是什麼？（如有）
Q: 能重現嗎？每次都發生還是偶爾發生？
```

**第二個為什麼：什麼條件下發生？**
```
Q: 在什麼情況下會觸發這個問題？
Q: 特定資料？特定操作順序？特定使用者角色？
Q: 有沒有剛修改過相關功能？
```

**第三個為什麼：為什麼會這樣？**
```
AI讀取相關代碼和文檔：
- 功能模塊文檔
- 技術規格文檔
- API規格文檔
- 相關源碼

AI分析：
- 資料流向是否正確？
- 驗證邏輯是否完整？
- 錯誤處理是否妥當？
```

**第四個為什麼：設計上的問題？**
```
AI檢查：
- 設計文檔中是否有說明此情況？
- 當初設計是否考慮到這種場景？
- 是設計缺陷還是實作缺陷？
```

**持續追問，直到找到根本原因**
```
AI不會在5次就停止，而是：
- 持續追問，直到找到真正的根本原因
- 根本原因通常是設計缺陷、邏輯錯誤、缺少驗證
- 有時3次就夠，有時需要8次以上
- 確定根本原因後：
  - 根本原因是什麼？
  - 是否還有其他地方有類似問題？
```

---

## 步驟 2：解決方案討論階段

### AI自動提出系統性解決方案

**AI分析：**
```
根本原因：{原因}

可能的解決方案：
方案A：{描述}
  優點：{列表}
  缺點：{列表}
  
方案B：{描述}
  優點：{列表}
  缺點：{列表}

我推薦：方案{X}
理由：{說明}

您同意嗎？或有其他想法？
```

### AI自動檢查：
- [ ] 是否為系統性解決（而非表面修復）？
- [ ] 是否解決根本原因？
- [ ] 是否影響其他功能？
- [ ] 是否需要修改設計文檔？

---

## 步驟 3：設計文檔更新階段（如需要）

### AI自動判斷：

**如果是設計缺陷：**
```
AI自動更新：
1. 技術規格文檔（補充邊界條件處理）
2. API規格文檔（補充錯誤處理）
3. 測試案例（新增相關測試）
```

**如果是實作缺陷：**
```
AI檢查：
- 文檔是否正確？（是 → 只修代碼）
- 文檔是否不完整？（是 → 補充文檔）
```

---

## 步驟 4：修復實作階段

### AI自動執行順序：

**4.1 創建修復計劃**
```
AI說明：
需要修改的檔案：
1. {檔案路徑} - {修改原因}
2. {檔案路徑} - {修改原因}

修改內容：
- 🔧 修復：{問題描述}
- 🔧 新增：{錯誤處理/驗證邏輯}
- 🔧 測試：{測試案例}
```

**4.2 執行修復**
```
AI自動修改：
1. 修復主要問題
2. 新增缺失的驗證/錯誤處理
3. 更新相關測試
```

**4.3 檢查類似問題**
```
AI自動搜索：
- 是否有其他地方有相同邏輯？
- 是否需要一併修復？
```

---

## 步驟 5：自動部署和測試階段

**⚠️ 超級重要：AI必須自己驗證問題真的解決了！**

### AI自動執行：

**5.1 自動部署**
```bash
# AI使用終端工具自動執行
cd timesheet-api
npm run build
npm run deploy
# 檢查服務狀態
```

**5.2 自動測試（全局驗證）**
```bash
# 測試1：原問題是否真的解決？
# 重現原問題的操作
curl -X POST http://localhost:8787/api/v1/{endpoint} \
  -H "Content-Type: application/json" \
  -d '{原問題的測試資料}'

# 檢查：
- [ ] 不再出現錯誤
- [ ] 回應正確
- [ ] 日誌無異常

# 測試2：邊界條件
# 測試3：異常情況
# 測試4：相關功能
```

**5.3 系統性驗證（全局角度）**
```
AI必須檢查：

□ 原問題是否真的解決？
  - 實際運行原問題的操作（不是猜測）
  - 驗證各種情況（正常、邊界、異常）
  - 檢查日誌無錯誤
  - 確認問題不再重現

□ 是否修復了所有類似問題？
  - 搜索相同邏輯的代碼
  - 一併修復並測試

□ 是否影響相關功能？
  - 運行相關功能的測試
  - 檢查使用相同Service的功能
  - 檢查使用相同資料表的功能

□ 是否造成新問題？
  - 檢查錯誤日誌
  - 檢查效能
  - 檢查其他模塊

□ 是否防止未來再次發生？
  - 補充文檔（驗證規範）
  - 新增測試案例
  - 加強錯誤處理
```

**5.4 確認無誤才輸出報告**
```
- [ ] 原問題真的解決了（實際驗證）
- [ ] 類似問題已全部修復
- [ ] 無影響其他功能
- [ ] 無造成新問題
- [ ] 已防止未來再次發生
- [ ] 才告訴用戶"已完成並驗證"
```

---

## 步驟 6：完成報告

### AI自動輸出：

```markdown
✅ 問題修復完成

問題描述：
- 🐛 {問題描述}

根本原因：
- 🔍 {五個為什麼分析結果}

解決方案：
- 🔧 {採用的方案}

已修改檔案：
- ✅ {檔案1} - {修改內容}
- ✅ {檔案2} - {修改內容}

已更新文檔（如有）：
- ✅ 技術規格/{模塊}/{主題}.md
- ✅ API規格/{模塊}/{端點}.md

類似問題處理：
- ✅ 已檢查並修復 {N} 個類似問題
- ✅ 已新增預防性驗證邏輯

已自動部署和測試：
- ✅ 代碼已部署
- ✅ 服務已重啟
- ✅ 原問題已解決（實際測試驗證，問題不再重現）
- ✅ 類似問題已修復（修復了X個類似問題）
- ✅ 相關功能測試通過（檢查了Y個相關功能）
- ✅ 無造成新問題（錯誤日誌無異常）

系統性驗證：
- ✅ 原問題真的解決了（不是只改了代碼）
- ✅ 找到並修復了根本原因
- ✅ 修復了所有類似問題
- ✅ 無影響其他功能
- ✅ 無造成新問題
- ✅ 已防止未來再次發生（新增驗證、測試、文檔）

預防措施：
- 🛡️ 已新增前端驗證
- 🛡️ 已新增後端驗證
- 🛡️ 已補充文檔說明
- 🛡️ 已新增測試案例

您可以直接使用，無需測試。
原問題已徹底解決，如有任何問題，我會立即修復。
```

---

## 完整示例

### 用戶需求：
```
工時表儲存時出現錯誤："hours must be between 0 and 24"，但我輸入的是8小時
```

### AI自動執行（完整流程）：

**步驟1：五個為什麼診斷**

```
AI問：為什麼會出現這個錯誤？
AI讀取：
- TimeLogs 表定義：hours REAL CHECK (hours >= 0 AND hours <= 24)
- 前端組件代碼
- API端點代碼

第一個為什麼：
Q: 能否提供完整錯誤訊息和操作步驟？
用戶：我填寫8小時正常工時，點儲存就出現這個錯誤

第二個為什麼：
AI檢查代碼發現：
- 前端送出的資料格式：{ hours: "8", work_type: "正常工時" }
- 問題：hours 是字串 "8" 而非數字 8

第三個為什麼：
AI檢查：
- 前端 input type="text"（應該是 type="number"）
- 前端未做類型轉換
- 後端API未驗證資料類型

第四個為什麼：
AI檢查設計文檔：
- API規格文檔中未明確說明資料類型驗證
- 技術規格文檔中未說明前端驗證邏輯

第五個為什麼（根本原因）：
- 設計文檔不完整（缺少資料類型驗證說明）
- 前端實作錯誤（input類型錯誤）
- 後端驗證不足（未檢查資料類型）
```

**步驟2：解決方案**

```
AI提出：
根本原因：
1. 前端 input 類型錯誤
2. 前端未做資料類型轉換
3. 後端缺少資料類型驗證

系統性解決方案：
方案A：三處都修復
  - 前端：改為 type="number"
  - 前端：送出前確保轉為數字
  - 後端：新增資料類型驗證
  - 文檔：補充驗證規範
  
  優點：最完整，多層防護
  缺點：需要修改多處

方案B：只修前端
  - 前端：改為 type="number" 並轉換類型
  
  優點：修改最少
  缺點：後端仍缺少驗證，不安全

我推薦：方案A
理由：多層防護更安全，且能防止其他類似問題

您同意嗎？
```

**步驟3：更新文檔**

```
AI自動更新：
1. docs/技術規格/工時表/UI設計.md
   - 🔄 2025-10-27：明確說明 input type="number"
   - 新增：送出前資料類型驗證

2. docs/API規格/工時/新增工時記錄.md
   - 🔄 2025-10-27：新增資料類型驗證說明
   - 錯誤回應新增：INVALID_TYPE 錯誤碼

3. docs/技術規格/工時表/測試案例.md
   - 新增：資料類型驗證測試案例
```

**步驟4：執行修復**

```
AI自動修改：

1. frontend/src/components/features/timesheet/TimesheetGrid.vue
   - 修改：<input type="text"> → <input type="number">
   - 新增：送出前 parseFloat() 轉換
   - 新增：前端驗證（0-24範圍）

2. worker/src/services/timesheet.service.ts
   - 新增：資料類型驗證
   - 新增：範圍驗證
   - 新增：ValidationError 錯誤處理

3. worker/src/utils/validation.util.ts
   - 新增：isNumber() 驗證函數
   - 新增：isInRange() 驗證函數

AI檢查類似問題：
- leave_hours 欄位（同樣問題）→ 一併修復
- overtime_hours 欄位（未來可能新增）→ 文檔中標註
```

**步驟5：驗證**

```
AI自動檢查：
✅ 輸入8小時正常儲存
✅ 輸入25小時正確顯示錯誤
✅ 輸入負數正確顯示錯誤
✅ 輸入文字正確顯示錯誤
✅ leave_hours 同樣修復完成
✅ 文檔已更新
```

---

## 禁止的做法 ❌

### 表面修復（禁止）

```typescript
// ❌ 只修改報錯的那一行
if (typeof hours === 'string') {
  hours = parseFloat(hours);  // 表面修復
}
```

### 正確的系統性修復（推薦）

```typescript
// ✅ 系統性解決
// 1. 前端：使用正確的input類型
<input type="number" min="0" max="24" step="0.5">

// 2. 前端：送出前驗證
const hours = parseFloat(formData.hours);
if (isNaN(hours) || hours < 0 || hours > 24) {
  throw new ValidationError('工時必須在0-24之間');
}

// 3. 後端：多層驗證
export function validateHours(hours: any): number {
  if (typeof hours !== 'number') {
    throw new ValidationError('hours must be a number');
  }
  if (hours < 0 || hours > 24) {
    throw new ValidationError('hours must be between 0 and 24');
  }
  return hours;
}

// 4. 文檔：明確說明驗證規則
```

---

## 相關文檔

- [AI開發指南](../AI開發指南.md)
- [任務類型自動識別](../任務類型自動識別.md)
- [新增功能流程](./新增功能流程.md)
- [修改功能流程](./修改功能流程.md)

---

**最後更新：** 2025年10月27日


**最後更新：** 2025年10月27日

---

## AI自動執行步驟

當識別到"修復問題"任務時，AI自動按以下步驟執行，**無需用戶提醒**。

---

## 步驟 1：診斷階段（深入追問找根本原因）

### AI自動執行：

```
AI會持續追問"為什麼"，直到找出根本原因（不限5次）
重點不是問幾次，而是是否找到根本原因
根本原因通常是：設計缺陷、邏輯錯誤、缺少驗證
```

### AI自動提問（逐層深入）：

**第一個為什麼：問題是什麼？**
```
Q: 能詳細描述一下問題嗎？
Q: 什麼時候發生的？
Q: 錯誤訊息是什麼？（如有）
Q: 能重現嗎？每次都發生還是偶爾發生？
```

**第二個為什麼：什麼條件下發生？**
```
Q: 在什麼情況下會觸發這個問題？
Q: 特定資料？特定操作順序？特定使用者角色？
Q: 有沒有剛修改過相關功能？
```

**第三個為什麼：為什麼會這樣？**
```
AI讀取相關代碼和文檔：
- 功能模塊文檔
- 技術規格文檔
- API規格文檔
- 相關源碼

AI分析：
- 資料流向是否正確？
- 驗證邏輯是否完整？
- 錯誤處理是否妥當？
```

**第四個為什麼：設計上的問題？**
```
AI檢查：
- 設計文檔中是否有說明此情況？
- 當初設計是否考慮到這種場景？
- 是設計缺陷還是實作缺陷？
```

**持續追問，直到找到根本原因**
```
AI不會在5次就停止，而是：
- 持續追問，直到找到真正的根本原因
- 根本原因通常是設計缺陷、邏輯錯誤、缺少驗證
- 有時3次就夠，有時需要8次以上
- 確定根本原因後：
  - 根本原因是什麼？
  - 是否還有其他地方有類似問題？
```

---

## 步驟 2：解決方案討論階段

### AI自動提出系統性解決方案

**AI分析：**
```
根本原因：{原因}

可能的解決方案：
方案A：{描述}
  優點：{列表}
  缺點：{列表}
  
方案B：{描述}
  優點：{列表}
  缺點：{列表}

我推薦：方案{X}
理由：{說明}

您同意嗎？或有其他想法？
```

### AI自動檢查：
- [ ] 是否為系統性解決（而非表面修復）？
- [ ] 是否解決根本原因？
- [ ] 是否影響其他功能？
- [ ] 是否需要修改設計文檔？

---

## 步驟 3：設計文檔更新階段（如需要）

### AI自動判斷：

**如果是設計缺陷：**
```
AI自動更新：
1. 技術規格文檔（補充邊界條件處理）
2. API規格文檔（補充錯誤處理）
3. 測試案例（新增相關測試）
```

**如果是實作缺陷：**
```
AI檢查：
- 文檔是否正確？（是 → 只修代碼）
- 文檔是否不完整？（是 → 補充文檔）
```

---

## 步驟 4：修復實作階段

### AI自動執行順序：

**4.1 創建修復計劃**
```
AI說明：
需要修改的檔案：
1. {檔案路徑} - {修改原因}
2. {檔案路徑} - {修改原因}

修改內容：
- 🔧 修復：{問題描述}
- 🔧 新增：{錯誤處理/驗證邏輯}
- 🔧 測試：{測試案例}
```

**4.2 執行修復**
```
AI自動修改：
1. 修復主要問題
2. 新增缺失的驗證/錯誤處理
3. 更新相關測試
```

**4.3 檢查類似問題**
```
AI自動搜索：
- 是否有其他地方有相同邏輯？
- 是否需要一併修復？
```

---

## 步驟 5：自動部署和測試階段

**⚠️ 超級重要：AI必須自己驗證問題真的解決了！**

### AI自動執行：

**5.1 自動部署**
```bash
# AI使用終端工具自動執行
cd timesheet-api
npm run build
npm run deploy
# 檢查服務狀態
```

**5.2 自動測試（全局驗證）**
```bash
# 測試1：原問題是否真的解決？
# 重現原問題的操作
curl -X POST http://localhost:8787/api/v1/{endpoint} \
  -H "Content-Type: application/json" \
  -d '{原問題的測試資料}'

# 檢查：
- [ ] 不再出現錯誤
- [ ] 回應正確
- [ ] 日誌無異常

# 測試2：邊界條件
# 測試3：異常情況
# 測試4：相關功能
```

**5.3 系統性驗證（全局角度）**
```
AI必須檢查：

□ 原問題是否真的解決？
  - 實際運行原問題的操作（不是猜測）
  - 驗證各種情況（正常、邊界、異常）
  - 檢查日誌無錯誤
  - 確認問題不再重現

□ 是否修復了所有類似問題？
  - 搜索相同邏輯的代碼
  - 一併修復並測試

□ 是否影響相關功能？
  - 運行相關功能的測試
  - 檢查使用相同Service的功能
  - 檢查使用相同資料表的功能

□ 是否造成新問題？
  - 檢查錯誤日誌
  - 檢查效能
  - 檢查其他模塊

□ 是否防止未來再次發生？
  - 補充文檔（驗證規範）
  - 新增測試案例
  - 加強錯誤處理
```

**5.4 確認無誤才輸出報告**
```
- [ ] 原問題真的解決了（實際驗證）
- [ ] 類似問題已全部修復
- [ ] 無影響其他功能
- [ ] 無造成新問題
- [ ] 已防止未來再次發生
- [ ] 才告訴用戶"已完成並驗證"
```

---

## 步驟 6：完成報告

### AI自動輸出：

```markdown
✅ 問題修復完成

問題描述：
- 🐛 {問題描述}

根本原因：
- 🔍 {五個為什麼分析結果}

解決方案：
- 🔧 {採用的方案}

已修改檔案：
- ✅ {檔案1} - {修改內容}
- ✅ {檔案2} - {修改內容}

已更新文檔（如有）：
- ✅ 技術規格/{模塊}/{主題}.md
- ✅ API規格/{模塊}/{端點}.md

類似問題處理：
- ✅ 已檢查並修復 {N} 個類似問題
- ✅ 已新增預防性驗證邏輯

已自動部署和測試：
- ✅ 代碼已部署
- ✅ 服務已重啟
- ✅ 原問題已解決（實際測試驗證，問題不再重現）
- ✅ 類似問題已修復（修復了X個類似問題）
- ✅ 相關功能測試通過（檢查了Y個相關功能）
- ✅ 無造成新問題（錯誤日誌無異常）

系統性驗證：
- ✅ 原問題真的解決了（不是只改了代碼）
- ✅ 找到並修復了根本原因
- ✅ 修復了所有類似問題
- ✅ 無影響其他功能
- ✅ 無造成新問題
- ✅ 已防止未來再次發生（新增驗證、測試、文檔）

預防措施：
- 🛡️ 已新增前端驗證
- 🛡️ 已新增後端驗證
- 🛡️ 已補充文檔說明
- 🛡️ 已新增測試案例

您可以直接使用，無需測試。
原問題已徹底解決，如有任何問題，我會立即修復。
```

---

## 完整示例

### 用戶需求：
```
工時表儲存時出現錯誤："hours must be between 0 and 24"，但我輸入的是8小時
```

### AI自動執行（完整流程）：

**步驟1：五個為什麼診斷**

```
AI問：為什麼會出現這個錯誤？
AI讀取：
- TimeLogs 表定義：hours REAL CHECK (hours >= 0 AND hours <= 24)
- 前端組件代碼
- API端點代碼

第一個為什麼：
Q: 能否提供完整錯誤訊息和操作步驟？
用戶：我填寫8小時正常工時，點儲存就出現這個錯誤

第二個為什麼：
AI檢查代碼發現：
- 前端送出的資料格式：{ hours: "8", work_type: "正常工時" }
- 問題：hours 是字串 "8" 而非數字 8

第三個為什麼：
AI檢查：
- 前端 input type="text"（應該是 type="number"）
- 前端未做類型轉換
- 後端API未驗證資料類型

第四個為什麼：
AI檢查設計文檔：
- API規格文檔中未明確說明資料類型驗證
- 技術規格文檔中未說明前端驗證邏輯

第五個為什麼（根本原因）：
- 設計文檔不完整（缺少資料類型驗證說明）
- 前端實作錯誤（input類型錯誤）
- 後端驗證不足（未檢查資料類型）
```

**步驟2：解決方案**

```
AI提出：
根本原因：
1. 前端 input 類型錯誤
2. 前端未做資料類型轉換
3. 後端缺少資料類型驗證

系統性解決方案：
方案A：三處都修復
  - 前端：改為 type="number"
  - 前端：送出前確保轉為數字
  - 後端：新增資料類型驗證
  - 文檔：補充驗證規範
  
  優點：最完整，多層防護
  缺點：需要修改多處

方案B：只修前端
  - 前端：改為 type="number" 並轉換類型
  
  優點：修改最少
  缺點：後端仍缺少驗證，不安全

我推薦：方案A
理由：多層防護更安全，且能防止其他類似問題

您同意嗎？
```

**步驟3：更新文檔**

```
AI自動更新：
1. docs/技術規格/工時表/UI設計.md
   - 🔄 2025-10-27：明確說明 input type="number"
   - 新增：送出前資料類型驗證

2. docs/API規格/工時/新增工時記錄.md
   - 🔄 2025-10-27：新增資料類型驗證說明
   - 錯誤回應新增：INVALID_TYPE 錯誤碼

3. docs/技術規格/工時表/測試案例.md
   - 新增：資料類型驗證測試案例
```

**步驟4：執行修復**

```
AI自動修改：

1. frontend/src/components/features/timesheet/TimesheetGrid.vue
   - 修改：<input type="text"> → <input type="number">
   - 新增：送出前 parseFloat() 轉換
   - 新增：前端驗證（0-24範圍）

2. worker/src/services/timesheet.service.ts
   - 新增：資料類型驗證
   - 新增：範圍驗證
   - 新增：ValidationError 錯誤處理

3. worker/src/utils/validation.util.ts
   - 新增：isNumber() 驗證函數
   - 新增：isInRange() 驗證函數

AI檢查類似問題：
- leave_hours 欄位（同樣問題）→ 一併修復
- overtime_hours 欄位（未來可能新增）→ 文檔中標註
```

**步驟5：驗證**

```
AI自動檢查：
✅ 輸入8小時正常儲存
✅ 輸入25小時正確顯示錯誤
✅ 輸入負數正確顯示錯誤
✅ 輸入文字正確顯示錯誤
✅ leave_hours 同樣修復完成
✅ 文檔已更新
```

---

## 禁止的做法 ❌

### 表面修復（禁止）

```typescript
// ❌ 只修改報錯的那一行
if (typeof hours === 'string') {
  hours = parseFloat(hours);  // 表面修復
}
```

### 正確的系統性修復（推薦）

```typescript
// ✅ 系統性解決
// 1. 前端：使用正確的input類型
<input type="number" min="0" max="24" step="0.5">

// 2. 前端：送出前驗證
const hours = parseFloat(formData.hours);
if (isNaN(hours) || hours < 0 || hours > 24) {
  throw new ValidationError('工時必須在0-24之間');
}

// 3. 後端：多層驗證
export function validateHours(hours: any): number {
  if (typeof hours !== 'number') {
    throw new ValidationError('hours must be a number');
  }
  if (hours < 0 || hours > 24) {
    throw new ValidationError('hours must be between 0 and 24');
  }
  return hours;
}

// 4. 文檔：明確說明驗證規則
```

---

## 相關文檔

- [AI開發指南](../AI開發指南.md)
- [任務類型自動識別](../任務類型自動識別.md)
- [新增功能流程](./新增功能流程.md)
- [修改功能流程](./修改功能流程.md)

---

**最後更新：** 2025年10月27日

