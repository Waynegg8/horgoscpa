# 修改功能標準流程

**最後更新：** 2025年10月27日

---

## AI自動執行步驟

當識別到"修改功能"任務時，AI自動按以下步驟執行，**無需用戶提醒**。

---

## 步驟 1：定位階段（3分鐘）

### AI自動執行：

```
1. 識別要修改的功能模塊
2. 讀取相關功能模塊文檔
3. 讀取相關技術規格文檔
4. 讀取相關API規格文檔
5. 讀取相關資料庫設計文檔
6. 讀取現有代碼（如需要）
```

### AI自動分析：
- [ ] 當前實作邏輯是什麼？
- [ ] 哪些文檔需要更新？
- [ ] 哪些代碼需要修改？
- [ ] 是否影響其他模塊？

---

## 步驟 2：需求確認階段（與用戶討論）

### AI自動提問（一次一個點）：

**理解修改需求：**
1. 確認理解：您想把{當前邏輯}改成{新邏輯}，對嗎？
2. 為什麼需要這個修改？（理解背景）
3. 修改後的預期行為是什麼？

**影響範圍確認：**
4. 這個修改是否影響現有資料？
5. 是否需要資料遷移？
6. 是否影響API的請求/回應格式？
7. 前端UI是否需要調整？

**向下相容性：**
8. 現有資料是否仍然有效？
9. 是否需要保留舊邏輯作為選項？

### 討論原則：
- ✅ 確保完全理解"為什麼"要改
- ✅ 確認修改範圍（最小化影響）
- ✅ 考慮向下相容性
- ✅ 所有細節確認後才進入下一步

---

## 步驟 3：設計文檔更新階段

### AI自動執行順序：

**3.1 技術規格文檔（優先更新）**
```
1. 更新 docs/技術規格/{模塊}/ 相關文檔
2. 標註修改內容（使用 "🔄 2025-10-27 修改："）
3. 更新業務邏輯說明
4. 更新測試案例（反映新邏輯）
```

**3.2 資料庫設計文檔（如有變更）**
```
如果修改資料表結構：
1. 更新 docs/資料庫設計/{分類}/{表格}.md
2. 標註新增/修改的欄位
3. 更新查詢範例

如果需要資料遷移：
1. 在文檔中說明遷移步驟
```

**3.3 API規格文檔（如有變更）**
```
如果修改API行為：
1. 更新 docs/API規格/{模塊}/{端點}.md
2. 標註變更內容
3. 如果是Breaking Change，增加版本號說明
4. 更新請求/回應範例
```

**3.4 功能模塊文檔**
```
1. 更新 docs/功能模塊/{編號}-{名稱}.md
2. 更新核心功能說明
3. 更新使用情境（如有變化）
```

### AI自動檢查：
- [ ] 所有受影響的文檔已更新
- [ ] 修改內容已標註日期
- [ ] 交叉引用已更新
- [ ] 測試案例反映新邏輯

---

## 步驟 4：編程實作階段

### AI自動執行順序：

**4.1 資料庫遷移（如需要）**
```typescript
// 1. 創建 D1 遷移檔案
// 2. 修改表格結構
// 3. 資料遷移腳本（如需要）
// 4. 更新索引（如需要）
```

**4.2 後端修改**
```typescript
// 按優先順序修改：
1. Repository（資料存取邏輯）
2. Service（業務邏輯）
3. Route（API端點，如需要）
4. Middleware（如需要）
```

**4.3 前端修改**
```typescript
// 按優先順序修改：
1. API Service（如API有變更）
2. Store（如狀態管理有變更）
3. 組件（UI邏輯）
4. 頁面（如需要）
```

### AI自動檢查：
- [ ] 修改最小化（只改必要的部分）
- [ ] 向下相容（如可能）
- [ ] 遵循命名規範
- [ ] 沒有破壞現有功能

---

## 步驟 5：自動部署和測試階段

**⚠️ 重要：AI自己測試驗證，不讓用戶測試！**

### AI自動執行：

**5.1 自動部署**
```bash
# AI使用終端工具自動執行
cd timesheet-api
npm run build
npm run deploy
# 檢查服務狀態
```

**5.2 自動測試（全局驗證）**
```bash
# 測試1：新邏輯是否正常？
curl -X {METHOD} http://localhost:8787/api/v1/{endpoint}
# 驗證回應符合新邏輯

# 測試2：現有功能是否被破壞？
# 運行相關功能的所有測試
curl -X GET http://localhost:8787/api/v1/{相關端點1}
curl -X GET http://localhost:8787/api/v1/{相關端點2}

# 測試3：邊界條件
# 測試4：錯誤處理
```

**5.3 系統性驗證（全局角度）**
```
AI必須檢查：

□ 修改的功能是否正常？
  - 實際運行測試（不是猜測）
  - 測試各種情況
  - 檢查日誌無錯誤

□ 現有功能是否被破壞？
  - 檢查使用相同Service的功能
  - 檢查使用相同資料表的功能
  - 運行所有相關測試

□ 是否造成新問題？
  - 檢查錯誤日誌
  - 檢查效能
  - 檢查其他模塊

□ 資料遷移是否成功？（如有）
  - 檢查資料完整性
  - 驗證無資料遺失

□ 文檔是否一致？
  - 代碼符合更新後的文檔
  - 所有變更已記錄
```

**5.4 確認無誤才輸出報告**
```
- [ ] 所有測試通過
- [ ] 無破壞現有功能
- [ ] 無造成新問題
- [ ] 文檔與代碼一致
- [ ] 才告訴用戶"已完成並驗證"
```

---

## 步驟 6：完成報告

### AI自動輸出：

```markdown
✅ 功能修改完成：{功能名稱}

修改內容：
- 🔄 {修改描述}

已更新文檔：
- ✅ 技術規格/{模塊}/{主題}.md
- ✅ API規格/{模塊}/{端點}.md（如有）
- ✅ 資料庫設計/{分類}/{表格}.md（如有）
- ✅ 功能模塊/{編號}-{名稱}.md

已修改檔案：
- ✅ worker/src/services/{name}.service.ts
- ✅ worker/src/repositories/{name}.repository.ts（如有）
- ✅ frontend/src/stores/{name}.store.ts（如有）
- ✅ frontend/src/components/...（如有）

資料遷移：
- ✅ 已創建遷移腳本（如需要）
- ✅ 現有資料遷移成功（如需要）

已自動部署和測試：
- ✅ 代碼已部署
- ✅ 服務已重啟
- ✅ 新邏輯測試通過（測試了X種情況）
- ✅ 現有功能測試通過（檢查了Y個相關功能）
- ✅ 邊界條件測試通過
- ✅ 錯誤處理測試通過

系統性驗證：
- ✅ 新邏輯運作正常（實際測試驗證）
- ✅ 現有功能未被破壞（檢查了所有相關功能）
- ✅ 無造成新問題（錯誤日誌無異常）
- ✅ 資料遷移成功（如有）
- ✅ 文檔與代碼一致

影響範圍：
- 📊 受影響的功能：{列表}（已全部測試通過）
- 🔗 相關模塊：{列表}（已全部檢查正常）

您可以直接使用，無需測試。
如有任何問題，我會立即修復。
```

---

## 完整示例

### 用戶需求：
```
@AI開發指南.md 我需要修改補休機制，改成先進先出（FIFO），而不是隨機扣除
```

### AI自動執行（完整流程）：

**步驟1：定位階段**
```
AI讀取：
- 技術規格/業務規則/補休機制.md
- 資料庫設計/補休系統/CompensatoryLeaveBalance.md
- 資料庫設計/補休系統/CompensatoryLeaveTransactions.md
- 資料庫設計/補休系統/CompensatoryLeaveUsage.md
- API規格/補休API（如有）

AI發現：
- 當前實作：使用 CompensatoryLeaveBalance 存總餘額
- 當前邏輯：使用時直接扣除總餘額
- 問題：沒有記錄哪筆補休被使用
```

**步驟2：確認階段**
```
AI提問：
Q1: 確認理解：您想讓最早累積的補休先被使用，對嗎？
用戶：是的

Q2: 月底清零邏輯是否改變？
用戶：不變，還是月底清零

Q3: 是否需要在前端顯示每筆補休的來源日期？
用戶：目前不需要，但資料要能支援未來顯示

Q4: 現有的補休餘額資料怎麼處理？
用戶：保留總額，但之後使用時才開始記錄明細

AI分析影響：
- 需要修改：CompensatoryLeaveUsage 表（增加 transaction_id）
- 需要修改：LeaveService.useCompensatoryLeave() 邏輯
- 需要新增：FIFO 扣除邏輯
- 不需要修改：API端點（行為變更但格式不變）
```

**步驟3：更新文檔**
```
AI自動更新：
1. docs/技術規格/業務規則/補休機制.md
   - 🔄 2025-10-27：補休使用改為FIFO方式
   - 增加FIFO扣除邏輯說明
   - 更新範例

2. docs/資料庫設計/補休系統/CompensatoryLeaveUsage.md
   - 🔄 2025-10-27：新增 transaction_id 欄位
   - 說明FIFO扣除邏輯
   - 更新查詢範例

3. docs/功能模塊/業務規則/2.6-補休機制.md
   - 更新核心功能說明

4. docs/API規格/補休API/使用補休.md（如有）
   - 標註：行為變更（FIFO），但API格式不變
```

**步驟4：編程實作**
```
AI自動修改：

1. D1遷移：
   ALTER TABLE CompensatoryLeaveUsage 
   ADD COLUMN transaction_id INTEGER
   ADD FOREIGN KEY (transaction_id) REFERENCES CompensatoryLeaveTransactions(transaction_id)

2. worker/src/services/leave.service.ts
   修改 useCompensatoryLeave() 方法：
   - 查詢最早的未使用完的 transactions（ORDER BY earned_date）
   - 按順序扣除
   - 記錄 CompensatoryLeaveUsage 時關聯 transaction_id

3. worker/src/repositories/compensatoryLeave.repository.ts
   新增 getEarliestUnusedTransactions() 方法
```

**步驟5：驗證**
```
AI自動檢查：
✅ FIFO邏輯正確實作
✅ 月底清零邏輯未被影響
✅ 現有補休餘額資料保持不變
✅ 新使用的補休正確記錄 transaction_id
✅ 文檔與代碼一致
```

---

## 相關文檔

- [AI開發指南](../AI開發指南.md)
- [任務類型自動識別](../任務類型自動識別.md)
- [新增功能流程](./新增功能流程.md)
- [修復問題流程](./修復問題流程.md)

---

**最後更新：** 2025年10月27日


**最後更新：** 2025年10月27日

---

## AI自動執行步驟

當識別到"修改功能"任務時，AI自動按以下步驟執行，**無需用戶提醒**。

---

## 步驟 1：定位階段（3分鐘）

### AI自動執行：

```
1. 識別要修改的功能模塊
2. 讀取相關功能模塊文檔
3. 讀取相關技術規格文檔
4. 讀取相關API規格文檔
5. 讀取相關資料庫設計文檔
6. 讀取現有代碼（如需要）
```

### AI自動分析：
- [ ] 當前實作邏輯是什麼？
- [ ] 哪些文檔需要更新？
- [ ] 哪些代碼需要修改？
- [ ] 是否影響其他模塊？

---

## 步驟 2：需求確認階段（與用戶討論）

### AI自動提問（一次一個點）：

**理解修改需求：**
1. 確認理解：您想把{當前邏輯}改成{新邏輯}，對嗎？
2. 為什麼需要這個修改？（理解背景）
3. 修改後的預期行為是什麼？

**影響範圍確認：**
4. 這個修改是否影響現有資料？
5. 是否需要資料遷移？
6. 是否影響API的請求/回應格式？
7. 前端UI是否需要調整？

**向下相容性：**
8. 現有資料是否仍然有效？
9. 是否需要保留舊邏輯作為選項？

### 討論原則：
- ✅ 確保完全理解"為什麼"要改
- ✅ 確認修改範圍（最小化影響）
- ✅ 考慮向下相容性
- ✅ 所有細節確認後才進入下一步

---

## 步驟 3：設計文檔更新階段

### AI自動執行順序：

**3.1 技術規格文檔（優先更新）**
```
1. 更新 docs/技術規格/{模塊}/ 相關文檔
2. 標註修改內容（使用 "🔄 2025-10-27 修改："）
3. 更新業務邏輯說明
4. 更新測試案例（反映新邏輯）
```

**3.2 資料庫設計文檔（如有變更）**
```
如果修改資料表結構：
1. 更新 docs/資料庫設計/{分類}/{表格}.md
2. 標註新增/修改的欄位
3. 更新查詢範例

如果需要資料遷移：
1. 在文檔中說明遷移步驟
```

**3.3 API規格文檔（如有變更）**
```
如果修改API行為：
1. 更新 docs/API規格/{模塊}/{端點}.md
2. 標註變更內容
3. 如果是Breaking Change，增加版本號說明
4. 更新請求/回應範例
```

**3.4 功能模塊文檔**
```
1. 更新 docs/功能模塊/{編號}-{名稱}.md
2. 更新核心功能說明
3. 更新使用情境（如有變化）
```

### AI自動檢查：
- [ ] 所有受影響的文檔已更新
- [ ] 修改內容已標註日期
- [ ] 交叉引用已更新
- [ ] 測試案例反映新邏輯

---

## 步驟 4：編程實作階段

### AI自動執行順序：

**4.1 資料庫遷移（如需要）**
```typescript
// 1. 創建 D1 遷移檔案
// 2. 修改表格結構
// 3. 資料遷移腳本（如需要）
// 4. 更新索引（如需要）
```

**4.2 後端修改**
```typescript
// 按優先順序修改：
1. Repository（資料存取邏輯）
2. Service（業務邏輯）
3. Route（API端點，如需要）
4. Middleware（如需要）
```

**4.3 前端修改**
```typescript
// 按優先順序修改：
1. API Service（如API有變更）
2. Store（如狀態管理有變更）
3. 組件（UI邏輯）
4. 頁面（如需要）
```

### AI自動檢查：
- [ ] 修改最小化（只改必要的部分）
- [ ] 向下相容（如可能）
- [ ] 遵循命名規範
- [ ] 沒有破壞現有功能

---

## 步驟 5：自動部署和測試階段

**⚠️ 重要：AI自己測試驗證，不讓用戶測試！**

### AI自動執行：

**5.1 自動部署**
```bash
# AI使用終端工具自動執行
cd timesheet-api
npm run build
npm run deploy
# 檢查服務狀態
```

**5.2 自動測試（全局驗證）**
```bash
# 測試1：新邏輯是否正常？
curl -X {METHOD} http://localhost:8787/api/v1/{endpoint}
# 驗證回應符合新邏輯

# 測試2：現有功能是否被破壞？
# 運行相關功能的所有測試
curl -X GET http://localhost:8787/api/v1/{相關端點1}
curl -X GET http://localhost:8787/api/v1/{相關端點2}

# 測試3：邊界條件
# 測試4：錯誤處理
```

**5.3 系統性驗證（全局角度）**
```
AI必須檢查：

□ 修改的功能是否正常？
  - 實際運行測試（不是猜測）
  - 測試各種情況
  - 檢查日誌無錯誤

□ 現有功能是否被破壞？
  - 檢查使用相同Service的功能
  - 檢查使用相同資料表的功能
  - 運行所有相關測試

□ 是否造成新問題？
  - 檢查錯誤日誌
  - 檢查效能
  - 檢查其他模塊

□ 資料遷移是否成功？（如有）
  - 檢查資料完整性
  - 驗證無資料遺失

□ 文檔是否一致？
  - 代碼符合更新後的文檔
  - 所有變更已記錄
```

**5.4 確認無誤才輸出報告**
```
- [ ] 所有測試通過
- [ ] 無破壞現有功能
- [ ] 無造成新問題
- [ ] 文檔與代碼一致
- [ ] 才告訴用戶"已完成並驗證"
```

---

## 步驟 6：完成報告

### AI自動輸出：

```markdown
✅ 功能修改完成：{功能名稱}

修改內容：
- 🔄 {修改描述}

已更新文檔：
- ✅ 技術規格/{模塊}/{主題}.md
- ✅ API規格/{模塊}/{端點}.md（如有）
- ✅ 資料庫設計/{分類}/{表格}.md（如有）
- ✅ 功能模塊/{編號}-{名稱}.md

已修改檔案：
- ✅ worker/src/services/{name}.service.ts
- ✅ worker/src/repositories/{name}.repository.ts（如有）
- ✅ frontend/src/stores/{name}.store.ts（如有）
- ✅ frontend/src/components/...（如有）

資料遷移：
- ✅ 已創建遷移腳本（如需要）
- ✅ 現有資料遷移成功（如需要）

已自動部署和測試：
- ✅ 代碼已部署
- ✅ 服務已重啟
- ✅ 新邏輯測試通過（測試了X種情況）
- ✅ 現有功能測試通過（檢查了Y個相關功能）
- ✅ 邊界條件測試通過
- ✅ 錯誤處理測試通過

系統性驗證：
- ✅ 新邏輯運作正常（實際測試驗證）
- ✅ 現有功能未被破壞（檢查了所有相關功能）
- ✅ 無造成新問題（錯誤日誌無異常）
- ✅ 資料遷移成功（如有）
- ✅ 文檔與代碼一致

影響範圍：
- 📊 受影響的功能：{列表}（已全部測試通過）
- 🔗 相關模塊：{列表}（已全部檢查正常）

您可以直接使用，無需測試。
如有任何問題，我會立即修復。
```

---

## 完整示例

### 用戶需求：
```
@AI開發指南.md 我需要修改補休機制，改成先進先出（FIFO），而不是隨機扣除
```

### AI自動執行（完整流程）：

**步驟1：定位階段**
```
AI讀取：
- 技術規格/業務規則/補休機制.md
- 資料庫設計/補休系統/CompensatoryLeaveBalance.md
- 資料庫設計/補休系統/CompensatoryLeaveTransactions.md
- 資料庫設計/補休系統/CompensatoryLeaveUsage.md
- API規格/補休API（如有）

AI發現：
- 當前實作：使用 CompensatoryLeaveBalance 存總餘額
- 當前邏輯：使用時直接扣除總餘額
- 問題：沒有記錄哪筆補休被使用
```

**步驟2：確認階段**
```
AI提問：
Q1: 確認理解：您想讓最早累積的補休先被使用，對嗎？
用戶：是的

Q2: 月底清零邏輯是否改變？
用戶：不變，還是月底清零

Q3: 是否需要在前端顯示每筆補休的來源日期？
用戶：目前不需要，但資料要能支援未來顯示

Q4: 現有的補休餘額資料怎麼處理？
用戶：保留總額，但之後使用時才開始記錄明細

AI分析影響：
- 需要修改：CompensatoryLeaveUsage 表（增加 transaction_id）
- 需要修改：LeaveService.useCompensatoryLeave() 邏輯
- 需要新增：FIFO 扣除邏輯
- 不需要修改：API端點（行為變更但格式不變）
```

**步驟3：更新文檔**
```
AI自動更新：
1. docs/技術規格/業務規則/補休機制.md
   - 🔄 2025-10-27：補休使用改為FIFO方式
   - 增加FIFO扣除邏輯說明
   - 更新範例

2. docs/資料庫設計/補休系統/CompensatoryLeaveUsage.md
   - 🔄 2025-10-27：新增 transaction_id 欄位
   - 說明FIFO扣除邏輯
   - 更新查詢範例

3. docs/功能模塊/業務規則/2.6-補休機制.md
   - 更新核心功能說明

4. docs/API規格/補休API/使用補休.md（如有）
   - 標註：行為變更（FIFO），但API格式不變
```

**步驟4：編程實作**
```
AI自動修改：

1. D1遷移：
   ALTER TABLE CompensatoryLeaveUsage 
   ADD COLUMN transaction_id INTEGER
   ADD FOREIGN KEY (transaction_id) REFERENCES CompensatoryLeaveTransactions(transaction_id)

2. worker/src/services/leave.service.ts
   修改 useCompensatoryLeave() 方法：
   - 查詢最早的未使用完的 transactions（ORDER BY earned_date）
   - 按順序扣除
   - 記錄 CompensatoryLeaveUsage 時關聯 transaction_id

3. worker/src/repositories/compensatoryLeave.repository.ts
   新增 getEarliestUnusedTransactions() 方法
```

**步驟5：驗證**
```
AI自動檢查：
✅ FIFO邏輯正確實作
✅ 月底清零邏輯未被影響
✅ 現有補休餘額資料保持不變
✅ 新使用的補休正確記錄 transaction_id
✅ 文檔與代碼一致
```

---

## 相關文檔

- [AI開發指南](../AI開發指南.md)
- [任務類型自動識別](../任務類型自動識別.md)
- [新增功能流程](./新增功能流程.md)
- [修復問題流程](./修復問題流程.md)

---

**最後更新：** 2025年10月27日

