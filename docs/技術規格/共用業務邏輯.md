# 共用業務邏輯

**常見業務邏輯的統一實現** | CRUD 模式、驗證規則、軟刪除

---

## 📋 目錄
- [CRUD 通用模式](#crud-通用模式)
- [驗證規則模式](#驗證規則模式)
- [軟刪除標準](#軟刪除標準)
- [審計日誌標準](#審計日誌標準)
- [權限檢查模式](#權限檢查模式)
- [分頁查詢模式](#分頁查詢模式)
- [唯一性檢查模式](#唯一性檢查模式)

---

## CRUD 通用模式

### 標準 CRUD 流程

所有資源的 CRUD 操作遵循統一的流程：

```
Create (新增):
1. 驗證必填欄位
2. 驗證欄位格式
3. 檢查唯一性
4. 插入資料庫
5. 記錄審計日誌
6. 返回成功響應

Read (查詢):
1. 驗證權限
2. 應用過濾條件
3. 應用分頁
4. 查詢資料庫
5. 返回結果

Update (更新):
1. 驗證資源存在
2. 驗證權限
3. 驗證欄位格式
4. 檢查唯一性（若修改唯一欄位）
5. 更新資料庫
6. 記錄審計日誌
7. 返回成功響應

Delete (刪除):
1. 驗證資源存在
2. 驗證權限
3. 檢查是否被引用
4. 軟刪除（設置 is_deleted = 1）
5. 記錄審計日誌
6. 返回成功響應
```

### Create 實現模板

```javascript
// Service 層
class ClientService {
  async createClient(data, userId) {
    // 1. 驗證必填欄位
    const validation = this.validateRequired(data, ['client_id', 'company_name', 'assignee_user_id']);
    if (!validation.valid) {
      throw new ValidationError(validation.error);
    }
    
    // 2. 驗證欄位格式
    if (!this.isValidClientId(data.client_id)) {
      throw new ValidationError('統一編號必須為 8 位數字');
    }
    
    // 3. 檢查唯一性
    const existing = await this.repository.findByClientId(data.client_id);
    if (existing) {
      throw new ConflictError('統一編號已存在');
    }
    
    // 4. 插入資料庫
    const client = await this.repository.create({
      ...data,
      created_by: userId,
      created_at: new Date(),
      updated_at: new Date(),
      is_deleted: 0
    });
    
    // 5. 記錄審計日誌
    await this.auditLog.log({
      user_id: userId,
      action: 'CREATE',
      table_name: 'Clients',
      record_id: client.client_id
    });
    
    // 6. 返回成功
    return client;
  }
}
```

### Read (列表) 實現模板

```javascript
async getClients(filters, pagination, userId, isAdmin) {
  // 1. 構建查詢條件
  let query = 'SELECT * FROM Clients WHERE is_deleted = 0';
  const params = [];
  
  // 2. 權限過濾（非管理員只能看自己負責的）
  if (!isAdmin) {
    query += ' AND assignee_user_id = ?';
    params.push(userId);
  }
  
  // 3. 應用過濾條件
  if (filters.company_name) {
    query += ' AND company_name LIKE ?';
    params.push(`%${filters.company_name}%`);
  }
  
  if (filters.business_status) {
    query += ' AND business_status = ?';
    params.push(filters.business_status);
  }
  
  // 4. 查詢總數
  const countQuery = query.replace('SELECT *', 'SELECT COUNT(*) as total');
  const countResult = await this.db.prepare(countQuery).bind(...params).first();
  
  // 5. 應用分頁
  query += ' ORDER BY created_at DESC LIMIT ? OFFSET ?';
  params.push(pagination.limit, pagination.offset);
  
  // 6. 執行查詢
  const result = await this.db.prepare(query).bind(...params).all();
  
  // 7. 返回結果
  return {
    data: result.results,
    pagination: {
      total: countResult.total,
      limit: pagination.limit,
      offset: pagination.offset,
      has_more: (pagination.offset + pagination.limit) < countResult.total
    }
  };
}
```

### Update 實現模板

```javascript
async updateClient(clientId, data, userId) {
  // 1. 驗證資源存在
  const client = await this.repository.findById(clientId);
  if (!client || client.is_deleted) {
    throw new NotFoundError('客戶不存在');
  }
  
  // 2. 驗證權限（非管理員只能修改自己負責的）
  if (!userId.isAdmin && client.assignee_user_id !== userId) {
    throw new ForbiddenError('您沒有權限修改此客戶');
  }
  
  // 3. 驗證欄位格式
  if (data.email && !this.isValidEmail(data.email)) {
    throw new ValidationError('Email 格式錯誤');
  }
  
  // 4. 檢查唯一性（若修改統一編號）
  if (data.client_id && data.client_id !== clientId) {
    const existing = await this.repository.findByClientId(data.client_id);
    if (existing) {
      throw new ConflictError('統一編號已存在');
    }
  }
  
  // 5. 更新資料庫
  const updated = await this.repository.update(clientId, {
    ...data,
    updated_by: userId,
    updated_at: new Date()
  });
  
  // 6. 記錄審計日誌
  await this.auditLog.log({
    user_id: userId,
    action: 'UPDATE',
    table_name: 'Clients',
    record_id: clientId,
    changes: data
  });
  
  return updated;
}
```

### Delete 實現模板

```javascript
async deleteClient(clientId, userId, isAdmin) {
  // 1. 驗證權限（僅管理員）
  if (!isAdmin) {
    throw new ForbiddenError('僅管理員可刪除客戶');
  }
  
  // 2. 驗證資源存在
  const client = await this.repository.findById(clientId);
  if (!client || client.is_deleted) {
    throw new NotFoundError('客戶不存在');
  }
  
  // 3. 檢查是否被引用
  const hasServices = await this.db.prepare(
    'SELECT COUNT(*) as count FROM ClientServices WHERE client_id = ? AND is_deleted = 0'
  ).bind(clientId).first();
  
  if (hasServices.count > 0) {
    throw new ConflictError('客戶有進行中的服務，無法刪除');
  }
  
  // 4. 軟刪除
  await this.repository.softDelete(clientId, userId);
  
  // 5. 記錄審計日誌
  await this.auditLog.log({
    user_id: userId,
    action: 'DELETE',
    table_name: 'Clients',
    record_id: clientId
  });
  
  return { success: true };
}
```

---

## 驗證規則模式

### 必填欄位驗證

```javascript
class Validator {
  validateRequired(data, requiredFields) {
    for (const field of requiredFields) {
      if (!data[field] || data[field] === '') {
        return {
          valid: false,
          error: `${field} 為必填欄位`
        };
      }
    }
    return { valid: true };
  }
}
```

### 格式驗證

```javascript
class Validator {
  // Email 驗證
  isValidEmail(email) {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  }
  
  // 台灣統一編號驗證（8 位數字）
  isValidClientId(clientId) {
    return /^\d{8}$/.test(clientId);
  }
  
  // 台灣手機號碼驗證
  isValidMobile(mobile) {
    return /^09\d{8}$/.test(mobile);
  }
  
  // 台灣電話號碼驗證
  isValidPhone(phone) {
    return /^0\d{1,2}-?\d{7,8}$/.test(phone);
  }
  
  // 日期格式驗證（YYYY-MM-DD）
  isValidDate(date) {
    return /^\d{4}-\d{2}-\d{2}$/.test(date);
  }
  
  // 時間格式驗證（HH:mm）
  isValidTime(time) {
    return /^([01]\d|2[0-3]):([0-5]\d)$/.test(time);
  }
}
```

### 數值範圍驗證

```javascript
class Validator {
  // 工時驗證（0-24 小時）
  isValidHours(hours) {
    const h = parseFloat(hours);
    return !isNaN(h) && h >= 0 && h <= 24;
  }
  
  // 分頁參數驗證
  validatePagination(limit, offset) {
    const safeLimit = Math.min(Math.max(parseInt(limit) || 50, 1), 100);
    const safeOffset = Math.max(parseInt(offset) || 0, 0);
    return { limit: safeLimit, offset: safeOffset };
  }
  
  // 金額驗證（正數）
  isValidAmount(amount) {
    const a = parseFloat(amount);
    return !isNaN(a) && a >= 0;
  }
}
```

---

## 軟刪除標準

### 資料表設計
**所有資料表必須包含：**
```sql
is_deleted INTEGER DEFAULT 0,  -- 0=未刪除, 1=已刪除
deleted_at DATETIME,            -- 刪除時間
deleted_by INTEGER,             -- 刪除人員ID
```

### 軟刪除實現

```javascript
class Repository {
  async softDelete(id, userId) {
    return await this.db.prepare(`
      UPDATE ${this.tableName}
      SET is_deleted = 1,
          deleted_at = CURRENT_TIMESTAMP,
          deleted_by = ?
      WHERE ${this.primaryKey} = ?
    `).bind(userId, id).run();
  }
  
  // 查詢時自動過濾已刪除
  async findAll(conditions = {}) {
    let query = `SELECT * FROM ${this.tableName} WHERE is_deleted = 0`;
    // ... 添加其他條件
    return await this.db.prepare(query).all();
  }
  
  // 恢復已刪除資料（若需要）
  async restore(id, userId) {
    return await this.db.prepare(`
      UPDATE ${this.tableName}
      SET is_deleted = 0,
          deleted_at = NULL,
          deleted_by = NULL,
          updated_by = ?
      WHERE ${this.primaryKey} = ?
    `).bind(userId, id).run();
  }
}
```

### 軟刪除檢查依賴

```javascript
async checkCanDelete(resourceId, tableName, foreignKey) {
  // 檢查是否有其他資源引用此資源
  const dependencies = [
    { table: 'ClientServices', key: 'client_id' },
    { table: 'TimeLogs', key: 'client_id' }
  ];
  
  for (const dep of dependencies) {
    const count = await this.db.prepare(`
      SELECT COUNT(*) as count 
      FROM ${dep.table} 
      WHERE ${dep.key} = ? AND is_deleted = 0
    `).bind(resourceId).first();
    
    if (count.count > 0) {
      throw new ConflictError(`此${tableName}有相關資料，無法刪除`);
    }
  }
  
  return true;
}
```

---

## 審計日誌標準

### 審計日誌資料表
```sql
CREATE TABLE AuditLogs (
  log_id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  action TEXT NOT NULL,          -- CREATE, UPDATE, DELETE, LOGIN
  table_name TEXT NOT NULL,      -- 操作的資料表
  record_id TEXT,                -- 記錄ID
  changes TEXT,                  -- JSON格式的變更內容
  ip_address TEXT,               -- 用戶IP
  user_agent TEXT,               -- 瀏覽器資訊
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

### 審計日誌實現

```javascript
class AuditLogService {
  async log(data) {
    return await this.db.prepare(`
      INSERT INTO AuditLogs (
        user_id, action, table_name, record_id, 
        changes, ip_address, user_agent, created_at
      )
      VALUES (?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
    `).bind(
      data.user_id,
      data.action,
      data.table_name,
      data.record_id,
      JSON.stringify(data.changes || {}),
      data.ip_address,
      data.user_agent
    ).run();
  }
  
  // 查詢特定記錄的操作歷史
  async getRecordHistory(tableName, recordId) {
    return await this.db.prepare(`
      SELECT 
        al.*,
        u.name as user_name
      FROM AuditLogs al
      LEFT JOIN Users u ON al.user_id = u.user_id
      WHERE al.table_name = ? AND al.record_id = ?
      ORDER BY al.created_at DESC
    `).bind(tableName, recordId).all();
  }
}
```

---

## 權限檢查模式

### 模塊權限檢查

```javascript
async function checkModulePermission(userId, moduleName) {
  // 查詢用戶權限
  const permission = await db.prepare(`
    SELECT can_access 
    FROM ModulePermissions 
    WHERE user_id = ? AND module_name = ?
  `).bind(userId, moduleName).first();
  
  return permission ? permission.can_access === 1 : false;
}

// Middleware 使用
function requirePermission(moduleName) {
  return async (c, next) => {
    const user = c.get('user');
    const hasPermission = await checkModulePermission(user.user_id, moduleName);
    
    if (!hasPermission) {
      return c.json(
        errorResponse('INSUFFICIENT_PERMISSIONS', '模塊權限未開啟'), 
        403
      );
    }
    
    await next();
  };
}
```

### 資源擁有者檢查

```javascript
async function checkResourceOwnership(userId, resourceId, resourceType, isAdmin) {
  // 管理員可以訪問所有資源
  if (isAdmin) {
    return true;
  }
  
  // 根據資源類型檢查擁有權
  const ownershipQueries = {
    'client': 'SELECT assignee_user_id FROM Clients WHERE client_id = ?',
    'timelog': 'SELECT user_id FROM TimeLogs WHERE log_id = ?',
    'task': 'SELECT assignee_user_id FROM ActiveTasks WHERE task_id = ?'
  };
  
  const query = ownershipQueries[resourceType];
  if (!query) {
    throw new Error(`Unknown resource type: ${resourceType}`);
  }
  
  const result = await db.prepare(query).bind(resourceId).first();
  
  if (!result) {
    return false;
  }
  
  // 檢查是否為擁有者
  const ownerIdKey = resourceType === 'client' ? 'assignee_user_id' : 'user_id';
  return result[ownerIdKey] === userId;
}
```

---

## 分頁查詢模式

### 標準分頁實現

```javascript
async function getPaginatedResults(query, params, pagination) {
  // 1. 查詢總數
  const countQuery = query.replace(
    /SELECT .* FROM/i, 
    'SELECT COUNT(*) as total FROM'
  );
  const countResult = await db.prepare(countQuery).bind(...params).first();
  
  // 2. 驗證分頁參數
  const limit = Math.min(Math.max(parseInt(pagination.limit) || 50, 1), 100);
  const offset = Math.max(parseInt(pagination.offset) || 0, 0);
  
  // 3. 添加分頁到查詢
  const paginatedQuery = `${query} LIMIT ? OFFSET ?`;
  const paginatedParams = [...params, limit, offset];
  
  // 4. 執行查詢
  const result = await db.prepare(paginatedQuery).bind(...paginatedParams).all();
  
  // 5. 返回結果
  return {
    data: result.results,
    pagination: {
      total: countResult.total,
      limit,
      offset,
      has_more: (offset + limit) < countResult.total
    }
  };
}
```

---

## 唯一性檢查模式

### 簡單唯一性檢查

```javascript
async function checkUnique(tableName, field, value, excludeId = null) {
  let query = `
    SELECT COUNT(*) as count 
    FROM ${tableName} 
    WHERE ${field} = ? AND is_deleted = 0
  `;
  const params = [value];
  
  // 更新時排除當前記錄
  if (excludeId) {
    query += ` AND ${getPrimaryKey(tableName)} != ?`;
    params.push(excludeId);
  }
  
  const result = await db.prepare(query).bind(...params).first();
  return result.count === 0;
}

// 使用範例
const isUnique = await checkUnique('Clients', 'client_id', '12345678');
if (!isUnique) {
  throw new ConflictError('統一編號已存在');
}
```

### 複合唯一性檢查

```javascript
async function checkCompositeUnique(tableName, conditions, excludeId = null) {
  // 構建查詢條件
  const whereClauses = [];
  const params = [];
  
  for (const [field, value] of Object.entries(conditions)) {
    whereClauses.push(`${field} = ?`);
    params.push(value);
  }
  
  let query = `
    SELECT COUNT(*) as count 
    FROM ${tableName} 
    WHERE ${whereClauses.join(' AND ')} AND is_deleted = 0
  `;
  
  if (excludeId) {
    query += ` AND ${getPrimaryKey(tableName)} != ?`;
    params.push(excludeId);
  }
  
  const result = await db.prepare(query).bind(...params).first();
  return result.count === 0;
}

// 使用範例：檢查同一主項目下子項目名稱唯一
const isUnique = await checkCompositeUnique('Services', {
  parent_service_id: 1,
  service_name: '記帳服務'
});
```

---

## 錯誤處理模式

### 自定義錯誤類別

```javascript
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = 'ValidationError';
    this.statusCode = 422;
    this.code = 'VALIDATION_ERROR';
  }
}

class NotFoundError extends Error {
  constructor(message) {
    super(message);
    this.name = 'NotFoundError';
    this.statusCode = 404;
    this.code = 'RESOURCE_NOT_FOUND';
  }
}

class ConflictError extends Error {
  constructor(message) {
    super(message);
    this.name = 'ConflictError';
    this.statusCode = 409;
    this.code = 'RESOURCE_CONFLICT';
  }
}

class ForbiddenError extends Error {
  constructor(message) {
    super(message);
    this.name = 'ForbiddenError';
    this.statusCode = 403;
    this.code = 'FORBIDDEN';
  }
}
```

### 統一錯誤處理 Middleware

```javascript
app.onError((err, c) => {
  console.error('Error:', err);
  
  // 已知錯誤類型
  if (err.statusCode) {
    return c.json(
      errorResponse(err.code, err.message),
      err.statusCode
    );
  }
  
  // 未知錯誤
  return c.json(
    errorResponse('INTERNAL_ERROR', '伺服器內部錯誤'),
    500
  );
});
```

---

## 📝 最佳實踐檢查清單

### Service 層實現檢查清單
- [ ] 實現 CRUD 完整流程
- [ ] 驗證所有必填欄位
- [ ] 驗證所有欄位格式
- [ ] 檢查唯一性約束
- [ ] 實現軟刪除（不實際刪除資料）
- [ ] 記錄審計日誌
- [ ] 實現權限檢查
- [ ] 使用自定義錯誤類別
- [ ] 返回統一響應格式

### Repository 層實現檢查清單
- [ ] 所有查詢自動過濾 `is_deleted = 0`
- [ ] 新增資料時設置標準欄位（created_at, created_by等）
- [ ] 更新資料時設置 updated_at, updated_by
- [ ] 實現軟刪除方法
- [ ] 使用參數化查詢（防止 SQL 注入）

---

## 🔗 相關文檔

- **[API 共用規範](../API規格/API共用規範.md)** - API 響應格式、錯誤處理
- **[後端開發規範](../開發規範/後端開發規範.md)** - 後端編碼標準
- **[數據模型速查表](../快速參考/數據模型速查表.md)** - 資料表結構

---

**最後更新：** 2025年10月27日  
**適用範圍：** 所有後端業務邏輯

