# 員工權限設定 - 權限驗證邏輯

**所屬功能：** [員工權限設定](../../功能模塊/01-員工權限設定.md)  
**最後更新：** 2025年10月27日

---

## 權限判定邏輯

### 判定流程

```
使用者嘗試存取模塊
↓
1. 檢查使用者角色
   ├─ 管理員？ → ✅ 允許所有模塊
   └─ 員工？ → 繼續檢查
↓
2. 檢查模塊是否為「管理員專屬」
   ├─ 是？ → ❌ 拒絕存取
   └─ 否？ → 繼續檢查
↓
3. 查詢 ModulePermissions 表
   ├─ 有個別設定？ → 使用個別設定
   └─ 無個別設定？ → 使用預設模板
↓
4. 檢查權限狀態
   ├─ is_enabled = true？ → ✅ 允許存取
   └─ is_enabled = false？ → ❌ 拒絕存取
```

---

## 權限查詢邏輯

### SQL 查詢

```sql
-- 檢查員工是否可存取特定模塊
SELECT 
  COALESCE(
    (SELECT is_enabled 
     FROM ModulePermissions 
     WHERE user_id = ? AND module_name = ?),
    (SELECT is_enabled 
     FROM ModulePermissions 
     WHERE user_id IS NULL AND module_name = ?)
  ) AS has_permission;
```

**邏輯說明：**
1. 先查詢該員工的個別設定（`user_id = ?`）
2. 如果沒有個別設定，使用預設模板（`user_id IS NULL`）
3. 回傳 `is_enabled` 狀態

---

### TypeScript 實作

```typescript
async function checkModulePermission(
  userId: number,
  moduleName: string
): Promise<boolean> {
  // 1. 檢查是否為管理員
  const user = await getUserById(userId);
  if (user.role === 'admin') {
    return true;  // 管理員允許所有模塊
  }
  
  // 2. 檢查是否為管理員專屬模塊
  const adminOnlyModules = [
    'employee_permissions',
    'business_rules',
    'employee_accounts',
    'external_articles',
    'external_faqs',
    'external_images',
    'external_resources',
    'booking_settings'
  ];
  
  if (adminOnlyModules.includes(moduleName)) {
    return false;  // 員工不可存取管理員專屬模塊
  }
  
  // 3. 查詢權限設定
  const permission = await db.get(`
    SELECT 
      COALESCE(
        (SELECT is_enabled 
         FROM ModulePermissions 
         WHERE user_id = ? AND module_name = ?),
        (SELECT is_enabled 
         FROM ModulePermissions 
         WHERE user_id IS NULL AND module_name = ?)
      ) AS has_permission
  `, [userId, moduleName, moduleName]);
  
  return permission?.has_permission === 1;
}
```

---

## 前端路由保護

### React Router 實作

```typescript
// ProtectedRoute.tsx
import { Navigate } from 'react-router-dom';
import { usePermission } from '@/hooks/usePermission';

interface ProtectedRouteProps {
  moduleName: string;
  children: React.ReactNode;
}

export function ProtectedRoute({ 
  moduleName, 
  children 
}: ProtectedRouteProps) {
  const { hasPermission, isLoading } = usePermission(moduleName);
  
  if (isLoading) {
    return <LoadingSpinner />;
  }
  
  if (!hasPermission) {
    return <Navigate to="/403" />;  // 無權限頁面
  }
  
  return <>{children}</>;
}

// 路由設定
<Route path="/reports" element={
  <ProtectedRoute moduleName="reports">
    <ReportsPage />
  </ProtectedRoute>
} />
```

---

### usePermission Hook

```typescript
// hooks/usePermission.ts
export function usePermission(moduleName: string) {
  const [hasPermission, setHasPermission] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const { user } = useAuth();
  
  useEffect(() => {
    async function checkPermission() {
      try {
        const result = await api.get(
          `/api/v1/permissions/check/${moduleName}`
        );
        setHasPermission(result.data.has_permission);
      } catch (error) {
        setHasPermission(false);
      } finally {
        setIsLoading(false);
      }
    }
    
    checkPermission();
  }, [moduleName, user?.id]);
  
  return { hasPermission, isLoading };
}
```

---

## API 層保護

### 中介軟體實作

```typescript
// middleware/checkModulePermission.ts
export function checkModulePermission(moduleName: string) {
  return async (req, res, next) => {
    const userId = req.user.id;
    
    const hasPermission = await permissionService.checkModulePermission(
      userId,
      moduleName
    );
    
    if (!hasPermission) {
      return res.status(403).json({
        success: false,
        error: {
          code: 'PERMISSION_DENIED',
          message: `無權限存取 ${moduleName} 模塊`
        }
      });
    }
    
    next();
  };
}

// 使用範例
router.get(
  '/api/v1/reports',
  authenticate,
  checkModulePermission('reports'),
  reportHandler.getReports
);
```

---

## 立即生效機制

### 前端實時更新

```typescript
// 使用 WebSocket 或輪詢
useEffect(() => {
  const ws = new WebSocket('ws://api/permissions/stream');
  
  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    
    if (data.type === 'PERMISSION_UPDATED' 
        && data.userId === currentUser.id) {
      // 重新載入權限
      refreshPermissions();
      
      // 如果當前頁面的權限被取消，導向首頁
      if (!data.permissions.includes(currentModule)) {
        navigate('/');
        showNotification('權限已更新，請重新確認可存取的功能');
      }
    }
  };
  
  return () => ws.close();
}, []);
```

---

### 後端快取更新

```typescript
// 權限更新時清除快取
async function updatePermissions(userId, permissions) {
  // 1. 更新資料庫
  await db.run(`
    UPDATE ModulePermissions 
    SET is_enabled = ? 
    WHERE user_id = ? AND module_name = ?
  `, [isEnabled, userId, moduleName]);
  
  // 2. 清除該使用者的權限快取
  await cache.delete(`permissions:user:${userId}`);
  
  // 3. 通知前端（WebSocket）
  wss.clients.forEach(client => {
    if (client.userId === userId) {
      client.send(JSON.stringify({
        type: 'PERMISSION_UPDATED',
        userId,
        permissions: await getUpdatedPermissions(userId)
      }));
    }
  });
}
```

---

## 效能優化

### 權限快取策略

```typescript
// 使用 Redis 快取權限
class PermissionCache {
  // 快取 TTL：5分鐘
  private readonly TTL = 300;
  
  async get(userId: number): Promise<string[] | null> {
    const cached = await redis.get(`permissions:user:${userId}`);
    return cached ? JSON.parse(cached) : null;
  }
  
  async set(userId: number, permissions: string[]): Promise<void> {
    await redis.setex(
      `permissions:user:${userId}`,
      this.TTL,
      JSON.stringify(permissions)
    );
  }
  
  async delete(userId: number): Promise<void> {
    await redis.del(`permissions:user:${userId}`);
  }
}

// 使用快取
async function getUserPermissions(userId: number): Promise<string[]> {
  // 1. 檢查快取
  let permissions = await permissionCache.get(userId);
  
  if (permissions) {
    return permissions;
  }
  
  // 2. 快取未命中，查詢資料庫
  permissions = await db.all(`
    SELECT module_name 
    FROM ModulePermissions 
    WHERE (user_id = ? OR user_id IS NULL) 
      AND is_enabled = TRUE
  `, [userId]);
  
  // 3. 寫入快取
  await permissionCache.set(userId, permissions);
  
  return permissions;
}
```

---

## 錯誤處理

### 前端錯誤處理

```typescript
try {
  await api.post('/api/v1/reports/generate');
} catch (error) {
  if (error.response?.status === 403) {
    showNotification('您沒有權限執行此操作', 'error');
    navigate('/');
  }
}
```

### 後端錯誤回應

```typescript
// 403 Forbidden
{
  "success": false,
  "error": {
    "code": "PERMISSION_DENIED",
    "message": "無權限存取此功能",
    "required_permission": "reports"
  }
}
```

---

## 測試案例

見 [測試案例文檔](./測試案例.md)

---

## 相關文檔

- [功能模塊](../../功能模塊/01-員工權限設定.md)
- [UI設計](./UI設計.md)
- [員工權限 API](../../API規格/員工權限/_概覽.md)

---

**最後更新：** 2025年10月27日



**所屬功能：** [員工權限設定](../../功能模塊/01-員工權限設定.md)  
**最後更新：** 2025年10月27日

---

## 權限判定邏輯

### 判定流程

```
使用者嘗試存取模塊
↓
1. 檢查使用者角色
   ├─ 管理員？ → ✅ 允許所有模塊
   └─ 員工？ → 繼續檢查
↓
2. 檢查模塊是否為「管理員專屬」
   ├─ 是？ → ❌ 拒絕存取
   └─ 否？ → 繼續檢查
↓
3. 查詢 ModulePermissions 表
   ├─ 有個別設定？ → 使用個別設定
   └─ 無個別設定？ → 使用預設模板
↓
4. 檢查權限狀態
   ├─ is_enabled = true？ → ✅ 允許存取
   └─ is_enabled = false？ → ❌ 拒絕存取
```

---

## 權限查詢邏輯

### SQL 查詢

```sql
-- 檢查員工是否可存取特定模塊
SELECT 
  COALESCE(
    (SELECT is_enabled 
     FROM ModulePermissions 
     WHERE user_id = ? AND module_name = ?),
    (SELECT is_enabled 
     FROM ModulePermissions 
     WHERE user_id IS NULL AND module_name = ?)
  ) AS has_permission;
```

**邏輯說明：**
1. 先查詢該員工的個別設定（`user_id = ?`）
2. 如果沒有個別設定，使用預設模板（`user_id IS NULL`）
3. 回傳 `is_enabled` 狀態

---

### TypeScript 實作

```typescript
async function checkModulePermission(
  userId: number,
  moduleName: string
): Promise<boolean> {
  // 1. 檢查是否為管理員
  const user = await getUserById(userId);
  if (user.role === 'admin') {
    return true;  // 管理員允許所有模塊
  }
  
  // 2. 檢查是否為管理員專屬模塊
  const adminOnlyModules = [
    'employee_permissions',
    'business_rules',
    'employee_accounts',
    'external_articles',
    'external_faqs',
    'external_images',
    'external_resources',
    'booking_settings'
  ];
  
  if (adminOnlyModules.includes(moduleName)) {
    return false;  // 員工不可存取管理員專屬模塊
  }
  
  // 3. 查詢權限設定
  const permission = await db.get(`
    SELECT 
      COALESCE(
        (SELECT is_enabled 
         FROM ModulePermissions 
         WHERE user_id = ? AND module_name = ?),
        (SELECT is_enabled 
         FROM ModulePermissions 
         WHERE user_id IS NULL AND module_name = ?)
      ) AS has_permission
  `, [userId, moduleName, moduleName]);
  
  return permission?.has_permission === 1;
}
```

---

## 前端路由保護

### React Router 實作

```typescript
// ProtectedRoute.tsx
import { Navigate } from 'react-router-dom';
import { usePermission } from '@/hooks/usePermission';

interface ProtectedRouteProps {
  moduleName: string;
  children: React.ReactNode;
}

export function ProtectedRoute({ 
  moduleName, 
  children 
}: ProtectedRouteProps) {
  const { hasPermission, isLoading } = usePermission(moduleName);
  
  if (isLoading) {
    return <LoadingSpinner />;
  }
  
  if (!hasPermission) {
    return <Navigate to="/403" />;  // 無權限頁面
  }
  
  return <>{children}</>;
}

// 路由設定
<Route path="/reports" element={
  <ProtectedRoute moduleName="reports">
    <ReportsPage />
  </ProtectedRoute>
} />
```

---

### usePermission Hook

```typescript
// hooks/usePermission.ts
export function usePermission(moduleName: string) {
  const [hasPermission, setHasPermission] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const { user } = useAuth();
  
  useEffect(() => {
    async function checkPermission() {
      try {
        const result = await api.get(
          `/api/v1/permissions/check/${moduleName}`
        );
        setHasPermission(result.data.has_permission);
      } catch (error) {
        setHasPermission(false);
      } finally {
        setIsLoading(false);
      }
    }
    
    checkPermission();
  }, [moduleName, user?.id]);
  
  return { hasPermission, isLoading };
}
```

---

## API 層保護

### 中介軟體實作

```typescript
// middleware/checkModulePermission.ts
export function checkModulePermission(moduleName: string) {
  return async (req, res, next) => {
    const userId = req.user.id;
    
    const hasPermission = await permissionService.checkModulePermission(
      userId,
      moduleName
    );
    
    if (!hasPermission) {
      return res.status(403).json({
        success: false,
        error: {
          code: 'PERMISSION_DENIED',
          message: `無權限存取 ${moduleName} 模塊`
        }
      });
    }
    
    next();
  };
}

// 使用範例
router.get(
  '/api/v1/reports',
  authenticate,
  checkModulePermission('reports'),
  reportHandler.getReports
);
```

---

## 立即生效機制

### 前端實時更新

```typescript
// 使用 WebSocket 或輪詢
useEffect(() => {
  const ws = new WebSocket('ws://api/permissions/stream');
  
  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    
    if (data.type === 'PERMISSION_UPDATED' 
        && data.userId === currentUser.id) {
      // 重新載入權限
      refreshPermissions();
      
      // 如果當前頁面的權限被取消，導向首頁
      if (!data.permissions.includes(currentModule)) {
        navigate('/');
        showNotification('權限已更新，請重新確認可存取的功能');
      }
    }
  };
  
  return () => ws.close();
}, []);
```

---

### 後端快取更新

```typescript
// 權限更新時清除快取
async function updatePermissions(userId, permissions) {
  // 1. 更新資料庫
  await db.run(`
    UPDATE ModulePermissions 
    SET is_enabled = ? 
    WHERE user_id = ? AND module_name = ?
  `, [isEnabled, userId, moduleName]);
  
  // 2. 清除該使用者的權限快取
  await cache.delete(`permissions:user:${userId}`);
  
  // 3. 通知前端（WebSocket）
  wss.clients.forEach(client => {
    if (client.userId === userId) {
      client.send(JSON.stringify({
        type: 'PERMISSION_UPDATED',
        userId,
        permissions: await getUpdatedPermissions(userId)
      }));
    }
  });
}
```

---

## 效能優化

### 權限快取策略

```typescript
// 使用 Redis 快取權限
class PermissionCache {
  // 快取 TTL：5分鐘
  private readonly TTL = 300;
  
  async get(userId: number): Promise<string[] | null> {
    const cached = await redis.get(`permissions:user:${userId}`);
    return cached ? JSON.parse(cached) : null;
  }
  
  async set(userId: number, permissions: string[]): Promise<void> {
    await redis.setex(
      `permissions:user:${userId}`,
      this.TTL,
      JSON.stringify(permissions)
    );
  }
  
  async delete(userId: number): Promise<void> {
    await redis.del(`permissions:user:${userId}`);
  }
}

// 使用快取
async function getUserPermissions(userId: number): Promise<string[]> {
  // 1. 檢查快取
  let permissions = await permissionCache.get(userId);
  
  if (permissions) {
    return permissions;
  }
  
  // 2. 快取未命中，查詢資料庫
  permissions = await db.all(`
    SELECT module_name 
    FROM ModulePermissions 
    WHERE (user_id = ? OR user_id IS NULL) 
      AND is_enabled = TRUE
  `, [userId]);
  
  // 3. 寫入快取
  await permissionCache.set(userId, permissions);
  
  return permissions;
}
```

---

## 錯誤處理

### 前端錯誤處理

```typescript
try {
  await api.post('/api/v1/reports/generate');
} catch (error) {
  if (error.response?.status === 403) {
    showNotification('您沒有權限執行此操作', 'error');
    navigate('/');
  }
}
```

### 後端錯誤回應

```typescript
// 403 Forbidden
{
  "success": false,
  "error": {
    "code": "PERMISSION_DENIED",
    "message": "無權限存取此功能",
    "required_permission": "reports"
  }
}
```

---

## 測試案例

見 [測試案例文檔](./測試案例.md)

---

## 相關文檔

- [功能模塊](../../功能模塊/01-員工權限設定.md)
- [UI設計](./UI設計.md)
- [員工權限 API](../../API規格/員工權限/_概覽.md)

---

**最後更新：** 2025年10月27日



