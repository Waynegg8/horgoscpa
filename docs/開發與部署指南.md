# 開發與部署指南

**版本**: 3.0  
**最後更新**: 2025-10-26  
**狀態**: 🔴 已更新為模組化架構

---

## 🚨 重要變更通知（v3.0）

系統已進行**全面模組化重構**，開發流程和架構有重大變更。

**📘 必讀文檔**：
1. [系統重構總設計文檔.md](./系統重構總設計文檔.md) - 完整的重構設計
2. [問題診斷與解決流程.md](./問題診斷與解決流程.md) - 問題處理規範

---

## 🎯 核心開發原則（v3.0 更新）

### ⚠️ 最重要：設計先行、深度診斷、模組化開發

**任何功能修改或新增，必須遵循以下順序：**

1. **第一步：閱讀標準化流程**
   - 閱讀 [系統重構總設計文檔.md](./系統重構總設計文檔.md) 第6章
   - 了解模組化架構和標準化流程
   - 檢查現有模組，最大化重用

2. **第二步：創建/更新設計文檔**
   - 使用標準範本創建功能設計文檔
   - 定義資料庫結構（遵循命名規範）
   - 設計 API 端點（100% RESTful）
   - 設計前端模組（職責單一、< 300行）
   - 通過設計評審（所有檢查清單）

3. **第三步：實施資料庫**
   - 創建 Migration 文件（標準格式）
   - 遵循命名規範：{table}s, {table}_id, is_{name}, {action}_at
   - 本地測試後再執行遠端
   - 驗證數據完整性

4. **第四步：實施後端（分層架構）**
   - Repository 層：資料訪問（< 200行）
   - Service 層：業務邏輯（< 300行）
   - Handler 層：HTTP 處理（< 200行）
   - Routes 層：路由註冊
   - 使用中間件：withAuth, withErrorHandler

5. **第五步：實施前端（分層架構）**
   - Core 層：API、State、Utils
   - Components 層：可重用 UI 組件
   - Modules 層：業務邏輯（< 200行）
   - Pages 層：頁面協調（< 150行）
   - HTML：使用標準範本，禁止內嵌樣式/腳本
   - CSS：優先使用組件庫，頁面特定樣式加前綴

6. **第六步：測試**
   - 單元測試（覆蓋率 > 80%）
   - 集成測試（所有 API）
   - E2E 測試（所有頁面）
   - 性能測試（頁面 < 2秒，API < 200ms）

7. **第七步：文檔同步**
   - 更新 API 文檔
   - 更新功能設計文檔
   - 更新系統架構文檔
   - 確保文檔與代碼 100% 同步

8. **第八步：清理**
   - 刪除測試腳本
   - 刪除臨時文件
   - 移動舊代碼到 deprecated
   - 確認 1 個月後刪除 deprecated

9. **第九步：自動部署**
   - Push 到 main 分支自動觸發部署
   - GitHub Actions 自動執行
   - **禁止手動部署**
   - 在 Actions 頁面監控狀態

### 其他開發原則

#### AI 助理協作原則（v3.0 更新）

- **深度診斷優先**: AI 助理發現問題時，**必須**使用「五個為什麼」找到根本原因，不做表面修復。參考 [問題診斷與解決流程.md](./問題診斷與解決流程.md)。
- **系統性解決**: 發現問題不只修復單點，**必須**檢查影響範圍，進行系統性解決。
- **模組化思維**: 任何修改都要考慮是否需要更新共用模組，不在多個文件重複修改。
- **主動更新設計**: AI 助理在發現任何代碼與設計不符時，**必須**先更新設計文檔，再實施修改。
- **整合修改建議**：發現問題或有修改意見時，**必須**整合進對應的設計文檔，然後再開始修復。
- **自動化優先**: AI 助理**絕不**要求手動部署，所有變更透過 Git Push 觸發自動化流程。
- **發現問題即處理**: 使用 TODO 追蹤，**不生成額外的問題彙總報告**。
- **禁止問題列表**: 發現問題後不彙總、不列表，直接記錄到 TODO 並開始修復。

#### 自動化測試與驗證
- ✅ 完成功能後立即測試
- ✅ 測試通過才能繼續下一步
- ❌ 不保留測試腳本和臨時檔案

#### 系統整合優先
- ✅ 所有新功能必須與現有系統完美整合
- ✅ 檢查是否已有相似功能，避免重複
- ❌ 不創建獨立的、不整合的功能

#### 保持專案整潔
- ✅ 測試完成立即刪除中間檔案
- ✅ 及時刪除過時文檔
- ❌ 不生成完成報告、總結、快速啟動等文件
- ❌ 不保留臨時測試檔案
- ❌ **絕對禁止生成任何形式的總結文檔、彙總報告、分析報告**

#### 問題處理原則（v3.0 更新）

- ✅ **深度診斷**：使用「五個為什麼」找根本原因（參考 [問題診斷與解決流程.md](./問題診斷與解決流程.md)）
- ✅ **系統性解決**：不只修復單點，檢查影響範圍，全面解決
- ✅ **【強制】更新設計文檔**：發現問題必須先更新設計文檔
  - 找到對應的設計文檔（docs/ 目錄）
  - 更新設計、添加說明或標記問題
  - 更新完設計文檔後再開始修復代碼
- ✅ **【強制】檢查是否為架構問題**：
  - 如果是樣式問題：檢查是否應該修改組件庫而非單一頁面
  - 如果是代碼重複：必須提取到共用模組
  - 如果是 API 問題：檢查是否需要統一處理
- ❌ **嚴格禁止表面修復**：只修改單一文件而不考慮系統影響
- ❌ **嚴格禁止彙總問題清單**：發現即修復，不製造垃圾文檔
- ✅ 使用 TODO 工具追蹤修復進度
- ✅ 發現設計與實現不符時，優先以設計文檔為準

#### 代碼修復流程（v3.0 更新）
1. **診斷根本原因**：使用「五個為什麼」深度診斷
2. **評估影響範圍**：檢查是單點問題還是系統性問題
3. **更新設計文檔**：如需修改架構，先更新設計
4. **系統性修復**：
   - 修改共用模組（如果是共用問題）
   - 修改組件庫（如果是樣式問題）
   - 修改中間件（如果是 API 問題）
   - 全面搜索替換（如果是命名問題）
5. **添加預防機制**：添加測試、更新規範、添加檢測工具
6. **更新文檔**：同步所有相關文檔
7. **自動部署生效**：推送到 main 分支後自動部署

---

## 📝 代碼規範

### 專案結構（2025-10-26 更新）

#### 新增的共用模組

**位置**: `assets/js/`

| 檔案 | 用途 | 主要功能 |
|------|------|----------|
| **config.js** | 系統配置 | API URL、常量定義、映射表 |
| **auth-common.js** | 統一認證 | 認證檢查、API請求、權限控制 |
| **common-utils.js** | 工具函數 | 日期格式化、HTML轉義、驗證函數 |
| **error-handler.js** | 錯誤處理 | 全局錯誤捕獲、友好提示 |

**使用方式**:
```html
<!-- 在所有內部管理頁面的 <head> 中引入 -->
<script src="assets/js/config.js"></script>
<script src="assets/js/common-utils.js"></script>
<script src="assets/js/auth-common.js"></script>
<script src="assets/js/error-handler.js"></script>

<!-- 然後再引入頁面特定的 JS -->
<script src="assets/js/dashboard.js"></script>
```

**優點**:
- ✅ 避免代碼重複（減少 ~500 行重複代碼）
- ✅ 統一錯誤處理
- ✅ 統一認證流程
- ✅ 集中配置管理
- ✅ 更易於維護和測試

### Git Commit 格式
```
簡潔描述變更內容（繁體中文）

例如：
- 新增客戶服務自動化功能
- 修復報表生成錯誤
- 更新 API 端點文檔
```

### JavaScript/TypeScript

#### 前端代碼規範（2025-10-26 更新）

```javascript
// ✅ 使用共用模組
import { apiRequest, showNotification } from './auth-common.js';
import { formatDate, escapeHtml } from './common-utils.js';
import { CONFIG } from './config.js';

// ✅ 統一的API調用方式
async function loadData() {
  try {
    const data = await apiRequest('/api/endpoint');
    showNotification('載入成功', 'success');
    return data;
  } catch (error) {
    // 錯誤已由 auth-common.js 和 error-handler.js 處理
    console.error('載入失敗:', error);
  }
}

// ✅ 統一的HTML渲染（防XSS）
function renderItem(item) {
  return `<div>${escapeHtml(item.name)}</div>`;
}

// ✅ 使用配置常量
const serviceTypeName = CONFIG.SERVICE_TYPE_NAMES[service.service_type];
```

#### 後端代碼規範（2025-10-26 更新）

```javascript
// ✅ 統一使用 jsonResponse（不要直接 new Response）
import { jsonResponse } from './utils.js';

export async function handleSomething(env, request) {
  try {
    const data = await processData(env.DB);
    return jsonResponse({  // ✅ 統一格式
      success: true,
      data: result
    });
  } catch (error) {
    console.error('處理失敗:', error);  // ✅ 添加日誌
    return jsonResponse({  // ✅ 統一錯誤格式
      success: false,
      error: error.message
    }, 500);
  }
}
```

**重要原則**:
- ✅ 前端：使用 `auth-common.js` 的 `apiRequest()`
- ✅ 後端：使用 `utils.js` 的 `jsonResponse()`
- ✅ 錯誤：添加 `console.error()` 日誌
- ✅ 超時：已內建在 `apiRequest()` 中（30秒）

### SQL
```sql
-- 表名使用小寫加底線
CREATE TABLE client_services (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  client_id INTEGER NOT NULL
);

-- 索引命名: idx_表名_欄位名
CREATE INDEX idx_client_services_client ON client_services(client_id);
```

---

## 🗄️ 資料庫規範

### Migration 命名
```
001_功能描述.sql
002_功能描述.sql
```

### 執行順序
```bash
# 1. 本地測試
npx wrangler d1 execute timesheet-db --local --file=migrations/XXX.sql

# 2. 確認無誤後部署到遠端
npx wrangler d1 execute timesheet-db --remote --file=migrations/XXX.sql
```

### 資料庫操作原則
- ✅ 使用參數化查詢防止 SQL 注入
- ✅ 建立適當的索引優化查詢
- ✅ 使用事務處理關聯操作
- ✅ 定期備份資料庫

---

## 🚀 部署流程

### 自動部署設定

**✅ 已啟用 GitHub Actions 自動部署**

本系統已配置完整的自動化部署流程：

1. **推送到 main 分支時自動部署**
   - 代碼推送到 GitHub main 分支
   - GitHub Actions 自動執行
   - 自動部署 Worker 到生產環境
   - 無需手動操作

2. **每日自動生成客戶服務任務**
   - 每天 00:00 (台北時間) 自動執行
   - GitHub Actions 調用 `/api/automated-tasks/generate`
   - 自動創建到期的客戶服務任務

3. **手動觸發部署**
   - 可在 GitHub Actions 頁面手動觸發
   - 適用於緊急部署或測試

### 自動部署步驟（GitHub Actions）

#### 1. 自動 Worker 部署
在 `.github/workflows/deploy.yml` 配置：

```yaml
name: 部署到 Cloudflare Workers

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '18'
      - name: 安裝依賴
        run: |
          cd timesheet-api
          npm ci
      - name: 部署到 Cloudflare
        run: |
          cd timesheet-api
          npx wrangler deploy
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
```

#### 2. 自動任務生成
在 `.github/workflows/auto-generate-tasks.yml` 配置：

```yaml
name: 自動生成客戶服務任務

on:
  schedule:
    - cron: '0 16 * * *'  # 每天 00:00 台北時間 (UTC+8)
  workflow_dispatch:

jobs:
  generate-tasks:
    runs-on: ubuntu-latest
    steps:
      - name: 調用任務生成 API
        run: |
          curl -X POST https://timesheet-api.hergscpa.workers.dev/api/automated-tasks/generate \
            -H "Authorization: Bearer ${{ secrets.API_TOKEN }}" \
            -H "Content-Type: application/json"
```

### 手動部署步驟（僅特殊情況）

#### 1. 資料庫遷移
```bash
cd timesheet-api

# 備份（建議先備份）
npx wrangler d1 execute timesheet-db --remote --command="SELECT name FROM sqlite_master" > backup.sql

# 執行遷移
npx wrangler d1 execute timesheet-db --remote --file=migrations/XXX.sql
```

#### 2. Worker 部署（手動）
```bash
# 生產環境
npx wrangler deploy

# 預覽環境
npx wrangler deploy --env preview
```

#### 3. 驗證部署
```bash
# 檢查 API 狀態
curl https://timesheet-api.hergscpa.workers.dev/api/verify

# 檢查資料庫連接
npx wrangler d1 execute timesheet-db --remote --command="SELECT COUNT(*) FROM users;"
```

### 部署注意事項

- ✅ **強制自動部署**：代碼推送到 main 分支後會自動部署，**不需要也不應該手動部署**
- ✅ **GitHub Actions**：推送後自動執行，可在 GitHub Actions 頁面查看狀態
- ⚠️ **資料庫遷移**：首次遷移建議手動執行並驗證
- ⚠️ **環境變數**：確保 GitHub Secrets 已正確配置
- ✅ **零停機時間**：Cloudflare Workers 支援無縫部署
- ❌ **嚴格禁止手動部署**：除非發生緊急情況且已獲批准，否則絕不應使用手動部署命令。所有常規部署都必須透過 GitHub Actions 自動完成。
- ❌ **AI 助理禁止要求手動部署**：AI 助理在任何情況下都不應要求用戶執行 `wrangler deploy` 或其他手動部署命令。所有變更通過 git push 自動觸發部署。

### 自動部署與遷移
- 任何 merge 到 `main` 會自動：
  1) 以 Wrangler 部署 Workers（讀取 `wrangler.jsonc` 綁定）
  2) 執行 D1 資料庫遷移（依 `/timesheet-api/migrations/` 序號順序）
  3) 清理並重建快取索引（必要時）
- 需要的環境變數：
  - `MEDIA_PUBLIC_BASE_URL`：R2 公開域名，例如 `https://media.horgoscpa.com`

### 設計文件同步原則
- 任一後端資料表/欄位或 API 行為改動，必須先更新對應的設計文件 (`docs/*.md`)，再送出程式碼變更。

---

## 🔧 開發環境設定

### 本地開發
```bash
cd timesheet-api

# 安裝依賴
npm install

# 啟動開發服務器
npx wrangler dev --local --persist-to .wrangler/state
```

### 環境變數
在 `wrangler.jsonc` 中配置：
```json
{
  "name": "timesheet-api",
  "main": "src/index.js",
  "compatibility_date": "2025-10-26",
  "d1_databases": [
    {
      "binding": "DB",
      "database_name": "timesheet-db",
      "database_id": "your-database-id"
    }
  ]
}
```

---

## 📦 API 設計原則

### 端點命名
```
GET    /api/資源名稱          # 獲取列表
GET    /api/資源名稱/:id      # 獲取單個
POST   /api/資源名稱          # 創建
PUT    /api/資源名稱/:id      # 更新
DELETE /api/資源名稱/:id      # 刪除
```

### 回應格式
```javascript
// 成功
{
  "success": true,
  "data": { ... }
}

// 失敗
{
  "success": false,
  "error": "錯誤訊息"
}
```

### 錯誤處理
```javascript
// 統一錯誤處理
try {
  // 業務邏輯
} catch (error) {
  return new Response(JSON.stringify({
    success: false,
    error: error.message
  }), {
    status: 500,
    headers: { 'Content-Type': 'application/json' }
  });
}
```

---

## 🧪 測試規範

### API 測試
```bash
# 本地測試
curl http://localhost:8787/api/endpoint

# 生產測試
curl https://your-worker.workers.dev/api/endpoint
```

### 功能測試檢查清單
- [ ] API 正常回應
- [ ] 資料庫操作成功
- [ ] 錯誤處理正確
- [ ] 認證授權有效
- [ ] 前端整合無誤

---

## 📚 文檔維護

### 文檔更新原則
- ✅ 功能變更必須更新文檔
- ✅ 重大變更需要版本標記
- ✅ 過時內容及時刪除
- ❌ 不生成臨時報告
- ❌ 不保留過時文檔

### 當前文檔結構
```
docs/
├── README.md                         # 文檔導航（從這裡開始）
├── 系統架構設計.md                   # ⭐ 總體架構（必讀）
├── 客戶服務自動化系統設計.md         # 詳細功能設計
├── 客戶服務自動化實施總結.md         # 實施記錄
├── 開發與部署指南.md                 # 本文件（開發規範）
├── API端點文檔.md                    # API 參考手冊
├── GitHub Actions設定.md             # 自動化配置
├── SEO部署指南.md                    # SEO 優化
└── timesheet-api/
    ├── README.md
    └── 資料庫還原指南.md
```

**⚠️ 修改功能前必讀：**
1. 先看 [系統架構設計.md](./系統架構設計.md) 瞭解整體
2. 找到對應的詳細設計文檔
3. 更新設計文檔
4. 再開始寫代碼

---

## 🔐 安全規範

### 認證與授權
```javascript
// 檢查認證
const auth = await requireAuth(env.DB, request);
if (!auth.authorized) {
  return jsonResponse({ error: 'Unauthorized' }, 401);
}

// 檢查權限
if (auth.user.role !== 'admin') {
  return jsonResponse({ error: 'Forbidden' }, 403);
}
```

### 資料驗證
```javascript
// 輸入驗證
if (!data.email || !data.email.includes('@')) {
  return jsonResponse({ error: '無效的電子郵件' }, 400);
}

// SQL 注入防護
const result = await db.get(
  'SELECT * FROM users WHERE id = ?',
  [userId]  // 使用參數化查詢
);
```

---

## 🆘 常見問題

### Q: 如何測試 API？
A: 使用 `curl` 或 Postman 測試端點，確保回應正確。

### Q: 資料庫遷移失敗怎麼辦？
A: 查看錯誤訊息，檢查 SQL 語法，必要時回滾。參考 [資料庫還原指南](./timesheet-api/資料庫還原指南.md)。

### Q: 如何新增 API 端點？
A: 
1. 在 `src/index.js` 添加路由
2. 實現處理函數
3. 更新 [API端點文檔.md](./API端點文檔.md)
4. 測試端點

---

**提示**：開發時遵循這些規範，保持代碼整潔、系統穩定。

