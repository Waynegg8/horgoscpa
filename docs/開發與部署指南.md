# 開發與部署指南

**版本**: 2.0  
**最後更新**: 2025-10-26

---

## 🎯 核心開發原則

### ⚠️ 最重要：先改設計，再改代碼

**任何功能修改或新增，必須遵循以下順序：**

1. **第一步：更新設計文檔**
   - 找到對應的設計文檔（在 `docs/` 目錄）
   - 更新功能描述、資料表結構、API 設計
   - 確保設計完整、清晰、可行

2. **第二步：按設計實施**
   - 嚴格按照設計文檔進行開發
   - 資料庫遷移、後端 API、前端介面
   - 不要在實施過程中隨意變更設計

3. **第三步：測試與清理**
   - 測試功能是否符合設計要求
   - 測試通過後立即刪除測試腳本
   - 不保留任何中間檔案

4. **第四步：同步文檔**
   - 如有設計變更，立即回頭更新設計文檔
   - 保持文檔與代碼 100% 同步

### 其他開發原則

#### 自動化測試與驗證
- ✅ 完成功能後立即測試
- ✅ 測試通過才能繼續下一步
- ❌ 不保留測試腳本和臨時檔案

#### 系統整合優先
- ✅ 所有新功能必須與現有系統完美整合
- ✅ 檢查是否已有相似功能，避免重複
- ❌ 不創建獨立的、不整合的功能

#### 保持專案整潔
- ✅ 測試完成立即刪除中間檔案
- ✅ 及時刪除過時文檔
- ❌ 不生成完成報告、總結、快速啟動等文件
- ❌ 不保留臨時測試檔案

---

## 📝 代碼規範

### 專案結構（2025-10-26 更新）

#### 新增的共用模組

**位置**: `assets/js/`

| 檔案 | 用途 | 主要功能 |
|------|------|----------|
| **config.js** | 系統配置 | API URL、常量定義、映射表 |
| **auth-common.js** | 統一認證 | 認證檢查、API請求、權限控制 |
| **common-utils.js** | 工具函數 | 日期格式化、HTML轉義、驗證函數 |
| **error-handler.js** | 錯誤處理 | 全局錯誤捕獲、友好提示 |

**使用方式**:
```html
<!-- 在所有內部管理頁面的 <head> 中引入 -->
<script src="assets/js/config.js"></script>
<script src="assets/js/common-utils.js"></script>
<script src="assets/js/auth-common.js"></script>
<script src="assets/js/error-handler.js"></script>

<!-- 然後再引入頁面特定的 JS -->
<script src="assets/js/dashboard.js"></script>
```

**優點**:
- ✅ 避免代碼重複（減少 ~500 行重複代碼）
- ✅ 統一錯誤處理
- ✅ 統一認證流程
- ✅ 集中配置管理
- ✅ 更易於維護和測試

### Git Commit 格式
```
簡潔描述變更內容（繁體中文）

例如：
- 新增客戶服務自動化功能
- 修復報表生成錯誤
- 更新 API 端點文檔
```

### JavaScript/TypeScript

#### 前端代碼規範（2025-10-26 更新）

```javascript
// ✅ 使用共用模組
import { apiRequest, showNotification } from './auth-common.js';
import { formatDate, escapeHtml } from './common-utils.js';
import { CONFIG } from './config.js';

// ✅ 統一的API調用方式
async function loadData() {
  try {
    const data = await apiRequest('/api/endpoint');
    showNotification('載入成功', 'success');
    return data;
  } catch (error) {
    // 錯誤已由 auth-common.js 和 error-handler.js 處理
    console.error('載入失敗:', error);
  }
}

// ✅ 統一的HTML渲染（防XSS）
function renderItem(item) {
  return `<div>${escapeHtml(item.name)}</div>`;
}

// ✅ 使用配置常量
const serviceTypeName = CONFIG.SERVICE_TYPE_NAMES[service.service_type];
```

#### 後端代碼規範（2025-10-26 更新）

```javascript
// ✅ 統一使用 jsonResponse（不要直接 new Response）
import { jsonResponse } from './utils.js';

export async function handleSomething(env, request) {
  try {
    const data = await processData(env.DB);
    return jsonResponse({  // ✅ 統一格式
      success: true,
      data: result
    });
  } catch (error) {
    console.error('處理失敗:', error);  // ✅ 添加日誌
    return jsonResponse({  // ✅ 統一錯誤格式
      success: false,
      error: error.message
    }, 500);
  }
}
```

**重要原則**:
- ✅ 前端：使用 `auth-common.js` 的 `apiRequest()`
- ✅ 後端：使用 `utils.js` 的 `jsonResponse()`
- ✅ 錯誤：添加 `console.error()` 日誌
- ✅ 超時：已內建在 `apiRequest()` 中（30秒）

### SQL
```sql
-- 表名使用小寫加底線
CREATE TABLE client_services (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  client_id INTEGER NOT NULL
);

-- 索引命名: idx_表名_欄位名
CREATE INDEX idx_client_services_client ON client_services(client_id);
```

---

## 🗄️ 資料庫規範

### Migration 命名
```
001_功能描述.sql
002_功能描述.sql
```

### 執行順序
```bash
# 1. 本地測試
npx wrangler d1 execute timesheet-db --local --file=migrations/XXX.sql

# 2. 確認無誤後部署到遠端
npx wrangler d1 execute timesheet-db --remote --file=migrations/XXX.sql
```

### 資料庫操作原則
- ✅ 使用參數化查詢防止 SQL 注入
- ✅ 建立適當的索引優化查詢
- ✅ 使用事務處理關聯操作
- ✅ 定期備份資料庫

---

## 🚀 部署流程

### 自動部署設定

**✅ 已啟用 GitHub Actions 自動部署**

本系統已配置完整的自動化部署流程：

1. **推送到 main 分支時自動部署**
   - 代碼推送到 GitHub main 分支
   - GitHub Actions 自動執行
   - 自動部署 Worker 到生產環境
   - 無需手動操作

2. **每日自動生成客戶服務任務**
   - 每天 00:00 (台北時間) 自動執行
   - GitHub Actions 調用 `/api/automated-tasks/generate`
   - 自動創建到期的客戶服務任務

3. **手動觸發部署**
   - 可在 GitHub Actions 頁面手動觸發
   - 適用於緊急部署或測試

### 自動部署步驟（GitHub Actions）

#### 1. 自動 Worker 部署
在 `.github/workflows/deploy.yml` 配置：

```yaml
name: 部署到 Cloudflare Workers

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '18'
      - name: 安裝依賴
        run: |
          cd timesheet-api
          npm ci
      - name: 部署到 Cloudflare
        run: |
          cd timesheet-api
          npx wrangler deploy
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
```

#### 2. 自動任務生成
在 `.github/workflows/auto-generate-tasks.yml` 配置：

```yaml
name: 自動生成客戶服務任務

on:
  schedule:
    - cron: '0 16 * * *'  # 每天 00:00 台北時間 (UTC+8)
  workflow_dispatch:

jobs:
  generate-tasks:
    runs-on: ubuntu-latest
    steps:
      - name: 調用任務生成 API
        run: |
          curl -X POST https://timesheet-api.hergscpa.workers.dev/api/automated-tasks/generate \
            -H "Authorization: Bearer ${{ secrets.API_TOKEN }}" \
            -H "Content-Type: application/json"
```

### 手動部署步驟（僅特殊情況）

#### 1. 資料庫遷移
```bash
cd timesheet-api

# 備份（建議先備份）
npx wrangler d1 execute timesheet-db --remote --command="SELECT name FROM sqlite_master" > backup.sql

# 執行遷移
npx wrangler d1 execute timesheet-db --remote --file=migrations/XXX.sql
```

#### 2. Worker 部署（手動）
```bash
# 生產環境
npx wrangler deploy

# 預覽環境
npx wrangler deploy --env preview
```

#### 3. 驗證部署
```bash
# 檢查 API 狀態
curl https://timesheet-api.hergscpa.workers.dev/api/verify

# 檢查資料庫連接
npx wrangler d1 execute timesheet-db --remote --command="SELECT COUNT(*) FROM users;"
```

### 部署注意事項

- ✅ **推薦**：使用 GitHub Actions 自動部署
- ⚠️ **資料庫遷移**：首次遷移建議手動執行並驗證
- ⚠️ **環境變數**：確保 GitHub Secrets 已正確配置
- ✅ **零停機時間**：Cloudflare Workers 支援無縫部署

---

## 🔧 開發環境設定

### 本地開發
```bash
cd timesheet-api

# 安裝依賴
npm install

# 啟動開發服務器
npx wrangler dev --local --persist-to .wrangler/state
```

### 環境變數
在 `wrangler.jsonc` 中配置：
```json
{
  "name": "timesheet-api",
  "main": "src/index.js",
  "compatibility_date": "2025-10-26",
  "d1_databases": [
    {
      "binding": "DB",
      "database_name": "timesheet-db",
      "database_id": "your-database-id"
    }
  ]
}
```

---

## 📦 API 設計原則

### 端點命名
```
GET    /api/資源名稱          # 獲取列表
GET    /api/資源名稱/:id      # 獲取單個
POST   /api/資源名稱          # 創建
PUT    /api/資源名稱/:id      # 更新
DELETE /api/資源名稱/:id      # 刪除
```

### 回應格式
```javascript
// 成功
{
  "success": true,
  "data": { ... }
}

// 失敗
{
  "success": false,
  "error": "錯誤訊息"
}
```

### 錯誤處理
```javascript
// 統一錯誤處理
try {
  // 業務邏輯
} catch (error) {
  return new Response(JSON.stringify({
    success: false,
    error: error.message
  }), {
    status: 500,
    headers: { 'Content-Type': 'application/json' }
  });
}
```

---

## 🧪 測試規範

### API 測試
```bash
# 本地測試
curl http://localhost:8787/api/endpoint

# 生產測試
curl https://your-worker.workers.dev/api/endpoint
```

### 功能測試檢查清單
- [ ] API 正常回應
- [ ] 資料庫操作成功
- [ ] 錯誤處理正確
- [ ] 認證授權有效
- [ ] 前端整合無誤

---

## 📚 文檔維護

### 文檔更新原則
- ✅ 功能變更必須更新文檔
- ✅ 重大變更需要版本標記
- ✅ 過時內容及時刪除
- ❌ 不生成臨時報告
- ❌ 不保留過時文檔

### 當前文檔結構
```
docs/
├── README.md                         # 文檔導航（從這裡開始）
├── 系統架構設計.md                   # ⭐ 總體架構（必讀）
├── 客戶服務自動化系統設計.md         # 詳細功能設計
├── 客戶服務自動化實施總結.md         # 實施記錄
├── 開發與部署指南.md                 # 本文件（開發規範）
├── API端點文檔.md                    # API 參考手冊
├── GitHub Actions設定.md             # 自動化配置
├── SEO部署指南.md                    # SEO 優化
└── timesheet-api/
    ├── README.md
    └── 資料庫還原指南.md
```

**⚠️ 修改功能前必讀：**
1. 先看 [系統架構設計.md](./系統架構設計.md) 瞭解整體
2. 找到對應的詳細設計文檔
3. 更新設計文檔
4. 再開始寫代碼

---

## 🔐 安全規範

### 認證與授權
```javascript
// 檢查認證
const auth = await requireAuth(env.DB, request);
if (!auth.authorized) {
  return jsonResponse({ error: 'Unauthorized' }, 401);
}

// 檢查權限
if (auth.user.role !== 'admin') {
  return jsonResponse({ error: 'Forbidden' }, 403);
}
```

### 資料驗證
```javascript
// 輸入驗證
if (!data.email || !data.email.includes('@')) {
  return jsonResponse({ error: '無效的電子郵件' }, 400);
}

// SQL 注入防護
const result = await db.get(
  'SELECT * FROM users WHERE id = ?',
  [userId]  // 使用參數化查詢
);
```

---

## 🆘 常見問題

### Q: 如何測試 API？
A: 使用 `curl` 或 Postman 測試端點，確保回應正確。

### Q: 資料庫遷移失敗怎麼辦？
A: 查看錯誤訊息，檢查 SQL 語法，必要時回滾。參考 [資料庫還原指南](./timesheet-api/資料庫還原指南.md)。

### Q: 如何新增 API 端點？
A: 
1. 在 `src/index.js` 添加路由
2. 實現處理函數
3. 更新 [API端點文檔.md](./API端點文檔.md)
4. 測試端點

---

**提示**：開發時遵循這些規範，保持代碼整潔、系統穩定。

