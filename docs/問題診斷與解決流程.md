# 問題診斷與解決流程

**版本**: 3.0  
**創建日期**: 2025-10-26  
**重要性**: 🔴 必讀 - 遇到任何問題必須遵循

---

## 📋 核心原則

### ⚠️ 最重要：找到根本原因，徹底解決

```
❌ 錯誤做法：
發現問題 → 表面修改 → 暫時解決 → 問題再次出現

✅ 正確做法：
發現問題 → 深度診斷 → 找到根本原因 → 系統性解決 → 更新規範 → 預防再發生
```

### 問題解決層次

```
Level 1: 表面症狀（錯誤訊息、功能失效）
Level 2: 直接原因（代碼錯誤、配置錯誤）
Level 3: 根本原因（架構問題、設計缺陷）
Level 4: 系統預防（更新規範、完善流程）

✅ 必須深入到 Level 3-4，不能只停留在 Level 1-2
```

---

## 🔍 問題分類與診斷流程

### 1. 前端頁面問題

#### 問題類型 A: 頁面樣式異常

**症狀**:
- 某個頁面的按鈕樣式不對
- 表格顯示錯亂
- 顏色不一致

**❌ 錯誤解決方式**:
```css
/* 直接在頁面特定 CSS 中覆蓋 */
.tasks-page .btn {
    background: blue !important;  /* ❌ 表面修復 */
}
```

**✅ 正確診斷流程**:

```
步驟 1: 確認問題範圍
  □ 只有這個頁面有問題？
  □ 其他頁面也有類似問題？
  □ 是某個組件的通用問題？

步驟 2: 檢查根本原因
  如果只有單一頁面：
    □ 是否使用了錯誤的 class？
    □ 是否有頁面特定的覆蓋樣式？
    □ 是否 HTML 結構不符合組件庫要求？
  
  如果多個頁面都有：
    □ 是組件庫的問題
    □ 需要修改 internal-components.css
    □ 不要在各個頁面分別修復

步驟 3: 系統性解決
  A. 如果是組件庫問題：
    1. 修改 assets/css/internal-components.css
    2. 測試所有使用此組件的頁面
    3. 更新組件文檔
  
  B. 如果是頁面特定問題：
    1. 檢查 HTML 結構是否符合標準
    2. 使用正確的組件庫 class
    3. 僅在必要時添加頁面特定樣式
    4. 頁面特定樣式必須加前綴

步驟 4: 預防再發生
  □ 更新 HTML與CSS規範文檔
  □ 添加檢查清單項目
  □ 如果是組件問題，考慮添加單元測試
```

**範例：按鈕樣式問題**

```
問題：Tasks 頁面的主要按鈕顏色不對

診斷過程：
1. 檢查頁面 - 發現其他頁面的主要按鈕也有問題
2. 確認是組件庫問題 - 不是單一頁面問題
3. 檢查 internal-components.css
4. 發現 .btn-primary 的顏色定義錯誤

正確解決：
1. 修改 internal-components.css 中的 .btn-primary
2. 測試所有頁面的主要按鈕
3. 更新組件文檔，明確顏色變數
4. 添加到檢查清單：所有按鈕必須用 btn-primary class

錯誤解決（禁止）：
1. 只在 tasks-page.css 中覆蓋樣式
2. 其他頁面繼續有問題
3. 造成樣式不一致
```

#### 問題類型 B: 頁面功能失效

**症狀**:
- 按鈕點擊沒反應
- API 調用失敗
- 數據顯示錯誤

**診斷流程**:

```
步驟 1: 檢查瀏覽器控制台
  □ 是否有 JavaScript 錯誤？
  □ 是否有網絡請求失敗？
  □ 是否有 404/500 錯誤？

步驟 2: 確定錯誤層次
  前端錯誤：
    □ 事件監聽器未綁定？
    □ DOM 元素不存在？
    □ 數據格式錯誤？
  
  API 錯誤：
    □ 端點不存在？
    □ 認證失敗？
    □ 參數錯誤？
  
  數據錯誤：
    □ 資料庫查詢失敗？
    □ 數據格式不對？
    □ 外鍵約束錯誤？

步驟 3: 找到根本原因
  不要只看錯誤訊息，要問：
    □ 為什麼會發生這個錯誤？
    □ 是代碼邏輯問題還是架構問題？
    □ 是單一功能問題還是系統性問題？
    □ 其他地方是否有相同問題？

步驟 4: 系統性解決
  A. 如果是代碼錯誤：
    1. 修復代碼
    2. 添加錯誤處理
    3. 添加日誌記錄
    4. 添加單元測試
  
  B. 如果是架構問題：
    1. 評估是否需要重構
    2. 更新架構設計文檔
    3. 修改代碼
    4. 更新開發規範

步驟 5: 預防措施
  □ 添加驗證邏輯
  □ 添加錯誤處理
  □ 更新文檔
  □ 添加測試用例
  □ 更新開發檢查清單
```

**範例：表格數據不顯示**

```
症狀：Tasks 頁面的表格無數據顯示

錯誤診斷（表面）：
❌ 在 TasksPage.js 中添加假數據測試
❌ 認為是這個頁面的問題

正確診斷（深度）：
1. 檢查控制台 - 發現 API 返回 500 錯誤
2. 檢查後端日誌 - 發現 SQL 查詢錯誤
3. 檢查 SQL - 發現使用了錯誤的欄位名（assigned_user 而非 assigned_user_id）
4. 追溯原因 - 發現資料庫命名不統一
5. 確認影響範圍 - 檢查其他 API 是否有相同問題

系統性解決：
1. 修改 TaskRepository 使用正確的欄位名
2. 檢查所有 Repository，統一欄位名稱
3. 更新資料庫設計文檔，明確命名規範
4. 添加到開發檢查清單
5. 添加資料庫欄位名稱驗證測試

預防措施：
1. 更新「資料庫重構設計.md」，強調命名規範
2. 在 BaseRepository 中添加欄位名稱驗證
3. 添加 SQL linter 檢查欄位名稱
4. 更新代碼審查清單
```

---

### 2. 後端 API 問題

#### 問題類型 A: API 返回錯誤

**診斷流程**:

```
步驟 1: 檢查錯誤類型
  □ 400 - 請求參數錯誤
  □ 401 - 認證失敗
  □ 403 - 權限不足
  □ 404 - 資源不存在
  □ 500 - 服務器錯誤

步驟 2: 檢查日誌
  □ 查看 Cloudflare Workers 日誌
  □ 確認具體錯誤訊息
  □ 檢查堆棧追蹤

步驟 3: 深度診斷
  如果是 400 錯誤：
    □ 是驗證邏輯錯誤？
    □ 是前端發送的參數格式錯誤？
    □ 是 API 文檔與實現不一致？
  
  如果是 500 錯誤：
    □ 是數據庫查詢錯誤？
    □ 是業務邏輯錯誤？
    □ 是未捕獲的異常？
  
  找到根本原因：
    □ 為什麼驗證邏輯錯誤？是否缺乏統一的驗證中間件？
    □ 為什麼 SQL 錯誤？是否表結構不清晰？
    □ 為什麼異常未捕獲？是否缺乏錯誤處理中間件？

步驟 4: 系統性解決
  不只修復這一個 API：
    □ 檢查所有類似的 API
    □ 確認是否有統一的處理機制
    □ 如果沒有，建立統一機制
    □ 更新所有相關 API

步驟 5: 架構改進
  □ 是否需要添加中間件？
  □ 是否需要統一驗證規則？
  □ 是否需要更新 API 設計規範？
  □ 是否需要添加自動化測試？
```

**範例：創建任務 API 返回 500**

```
症狀：POST /api/tasks 返回 500 錯誤

錯誤診斷：
❌ 在 tasks handler 中添加 try-catch
❌ 只修復這一個 API

正確診斷：
1. 檢查日誌 - 發現 SQL 錯誤："no such column: assigned_user"
2. 檢查代碼 - 發現使用了舊的欄位名
3. 檢查其他 API - 發現多個 API 有相同問題
4. 找到根本原因：
   - 資料庫已重構但代碼未同步
   - 缺乏統一的欄位名稱常量
   - 缺乏自動化測試

系統性解決：
1. 創建欄位名稱常量文件
2. 更新所有 Repository 使用常量
3. 添加資料庫欄位驗證測試
4. 更新 API 設計規範
5. 添加到 CI/CD 檢查

預防措施：
1. 在 BaseRepository 中強制使用欄位常量
2. 添加 Migration 後自動運行測試
3. 更新開發流程，要求資料庫變更必須同步代碼
```

---

### 3. 資料庫問題

#### 問題類型 A: 查詢性能問題

**診斷流程**:

```
步驟 1: 確認症狀
  □ 查詢慢（> 1秒）
  □ 頁面載入慢
  □ API 超時

步驟 2: 定位慢查詢
  □ 使用 EXPLAIN QUERY PLAN 分析
  □ 檢查是否有全表掃描
  □ 檢查是否缺少索引

步驟 3: 找到根本原因
  不只是缺少索引：
    □ 為什麼當初沒有建立索引？
    □ 是否有索引建立規範？
    □ 是否有性能測試流程？
    □ 其他表是否有類似問題？

步驟 4: 系統性解決
  1. 添加缺失的索引
  2. 檢查所有表，建立完整的索引策略
  3. 創建索引建立規範文檔
  4. 添加性能測試到 CI/CD
  5. 更新 Migration 範本，強制包含索引

步驟 5: 架構改進
  □ 建立索引命名規範：idx_{table}_{column}
  □ 建立索引建立檢查清單
  □ 添加自動化性能測試
  □ 更新資料庫設計文檔
```

#### 問題類型 B: 數據完整性問題

**診斷流程**:

```
步驟 1: 確認症狀
  □ 外鍵約束錯誤
  □ 數據不一致
  □ 孤兒記錄

步驟 2: 檢查資料庫設計
  □ 外鍵約束是否正確？
  □ ON DELETE/UPDATE 行為是否合理？
  □ 是否有循環依賴？

步驟 3: 找到根本原因
  □ 為什麼會產生不一致？
  □ 是否缺乏事務處理？
  □ 是否缺乏數據驗證？
  □ 是否資料庫設計有缺陷？

步驟 4: 系統性解決
  1. 修復數據不一致
  2. 添加正確的外鍵約束
  3. 添加事務處理
  4. 更新所有相關操作使用事務
  5. 添加數據完整性測試

步驟 5: 架構改進
  □ 建立事務處理規範
  □ 建立外鍵約束規範
  □ 添加數據完整性自動測試
  □ 更新資料庫設計文檔
```

---

### 4. 模組化架構問題

#### 問題類型：代碼重複

**症狀**:
- 在多個文件中發現相同的邏輯
- 修改一個地方需要改多個文件

**診斷流程**:

```
步驟 1: 確認重複範圍
  □ 重複代碼出現在幾個文件？
  □ 重複的是什麼邏輯？
  □ 為什麼會重複？

步驟 2: 找到根本原因
  □ 是否缺乏共用模組？
  □ 是否開發者不知道有共用模組？
  □ 是否共用模組功能不足？
  □ 是否缺乏代碼審查？

步驟 3: 系統性解決
  1. 提取重複代碼到共用模組
  2. 檢查整個代碼庫，找出所有重複
  3. 統一使用共用模組
  4. 刪除重複代碼
  5. 添加代碼重複檢測工具

步驟 4: 架構改進
  □ 完善共用模組文檔
  □ 建立代碼重用檢查清單
  □ 添加代碼審查規範
  □ 使用工具自動檢測重複（如 jsinspect）

步驟 5: 流程改進
  □ 更新開發流程，要求先檢查現有模組
  □ 建立模組索引文檔
  □ Code Review 必須檢查重複
```

---

## 🛠️ 問題解決決策樹

### 遇到任何問題時的決策流程

```
發現問題
    ↓
┌─────────────────────────┐
│ 1. 確認問題類型          │
│   - 前端問題？          │
│   - 後端問題？          │
│   - 資料庫問題？        │
│   - 架構問題？          │
└─────────────────────────┘
    ↓
┌─────────────────────────┐
│ 2. 檢查是否為表面症狀    │
│   問自己：              │
│   - 只是這裡有問題嗎？  │
│   - 其他地方也有嗎？    │
│   - 為什麼會有這問題？  │
└─────────────────────────┘
    ↓
┌─────────────────────────┐
│ 3. 診斷根本原因          │
│   深入追問：            │
│   - 代碼層面的原因？    │
│   - 設計層面的原因？    │
│   - 架構層面的原因？    │
│   - 流程層面的原因？    │
└─────────────────────────┘
    ↓
┌─────────────────────────┐
│ 4. 評估影響範圍          │
│   檢查：                │
│   - 影響幾個模組？      │
│   - 影響幾個頁面？      │
│   - 是否系統性問題？    │
└─────────────────────────┘
    ↓
    ┌────────────────┐
    │ 是系統性問題？  │
    └────────────────┘
         ↙          ↘
      Yes            No
       ↓              ↓
┌──────────────┐  ┌──────────────┐
│ 架構層面解決  │  │ 局部修復      │
│ 1. 重構模組   │  │ 1. 修復代碼   │
│ 2. 統一規範   │  │ 2. 添加測試   │
│ 3. 更新文檔   │  │ 3. 添加註釋   │
│ 4. 全面測試   │  │ 4. 更新文檔   │
└──────────────┘  └──────────────┘
       ↓              ↓
       └──────┬───────┘
              ↓
┌─────────────────────────┐
│ 5. 預防再發生            │
│   - 更新規範文檔        │
│   - 添加自動化檢查      │
│   - 添加到檢查清單      │
│   - 團隊培訓            │
└─────────────────────────┘
```

---

## 📋 問題解決檢查清單

### 基礎檢查

```
□ 我是否只解決了表面問題？
□ 我是否找到了根本原因？
□ 我是否檢查了其他地方是否有類似問題？
□ 我是否考慮了系統性解決方案？
□ 我是否更新了相關文檔？
```

### 深度檢查

```
□ 這個問題為什麼會發生？（問 5 次為什麼）
□ 是代碼問題、設計問題，還是流程問題？
□ 如果修改代碼，是改局部還是改架構？
□ 如果修改架構，影響範圍有多大？
□ 是否需要重構？
□ 是否需要更新設計文檔？
□ 是否需要更新開發規範？
```

### 解決方案檢查

```
□ 我的解決方案是否徹底？
□ 是否只是暫時修復（technical debt）？
□ 是否會引入新問題？
□ 是否符合架構設計？
□ 是否符合開發規範？
□ 是否添加了測試？
□ 是否更新了文檔？
```

### 預防措施檢查

```
□ 我是否更新了相關規範文檔？
□ 我是否添加了檢查清單項目？
□ 我是否添加了自動化測試？
□ 我是否更新了開發流程？
□ 我是否分享了經驗教訓？
```

---

## 🎯 常見問題與正確解決方式

### 問題 1: 樣式不一致

**錯誤解決**:
```css
/* 在每個頁面的 CSS 中分別修改 */
.tasks-page .btn { background: blue; }
.dashboard-page .btn { background: blue; }
.settings-page .btn { background: blue; }
```

**正確解決**:
```css
/* 在 internal-components.css 中統一修改 */
.btn-primary {
    background: var(--primary-color);
}

/* 然後檢查所有頁面是否使用了 btn-primary */
```

**改進措施**:
1. 更新組件庫文檔，明確所有按鈕 class
2. 添加到開發檢查清單：使用組件庫 class
3. 添加 CSS lint 規則：禁止覆蓋組件庫樣式

---

### 問題 2: 代碼重複

**錯誤解決**:
```javascript
// 發現重複，但只刪除其中一處
// 其他地方繼續重複
```

**正確解決**:
```javascript
// 1. 提取到共用模組
// assets/js/core/utils/format.js
export function formatDate(date) { ... }

// 2. 全面搜索並替換
// 使用工具搜索所有類似代碼
// 統一替換為共用模組

// 3. 添加檢測
// 添加工具自動檢測代碼重複
```

**改進措施**:
1. 建立共用模組索引文檔
2. Code Review 必須檢查是否重用現有模組
3. 使用 jsinspect 自動檢測重複代碼
4. 添加到 CI/CD 檢查

---

### 問題 3: API 端點混亂

**錯誤解決**:
```javascript
// 只修改這一個端點
router.get('/api/get-clients', handler);  // ❌
```

**正確解決**:
```javascript
// 1. 修改為 RESTful
router.get('/api/clients', handler);  // ✅

// 2. 檢查所有端點
// 找出所有不符合 RESTful 的端點
// 統一修改

// 3. 更新前端 API 調用
// 更新 endpoints.js
// 測試所有 API 調用
```

**改進措施**:
1. 建立 API 端點命名規範
2. 添加 API lint 工具檢查命名
3. 更新 API 設計檢查清單
4. 添加到 Code Review 必查項目

---

### 問題 4: 外鍵命名不一致

**錯誤解決**:
```sql
-- 只修改這一個表
ALTER TABLE tasks RENAME COLUMN assigned_to TO assigned_user_id;
```

**正確解決**:
```sql
-- 1. 統一所有表的外鍵命名
-- 創建完整的重構 Migration

-- 2. 更新所有相關代碼
-- Repository
-- Service  
-- Handler

-- 3. 更新文檔
-- 資料庫設計文檔
-- API 文檔
```

**改進措施**:
1. 建立嚴格的命名規範
2. 添加資料庫 schema 驗證腳本
3. Migration 必須經過 schema 驗證
4. 添加到開發檢查清單

---

## 📚 問題類型索引

### 前端問題

| 問題類型 | 表面症狀 | 可能的根本原因 | 正確解決層次 |
|---------|---------|---------------|-------------|
| 樣式異常 | 按鈕顏色錯誤 | 缺乏統一組件庫 | 修改組件庫 |
| 功能失效 | 點擊無反應 | 事件綁定錯誤 | 檢查組件生命週期 |
| 數據錯誤 | 顯示異常 | API 數據格式不對 | 統一數據轉換 |
| 性能問題 | 載入慢 | 未優化打包 | 實現代碼分割 |

### 後端問題

| 問題類型 | 表面症狀 | 可能的根本原因 | 正確解決層次 |
|---------|---------|---------------|-------------|
| API 錯誤 | 500 錯誤 | 缺乏錯誤處理 | 添加錯誤中間件 |
| 認證失敗 | 401 錯誤 | Token 驗證邏輯問題 | 統一認證中間件 |
| 查詢錯誤 | SQL 錯誤 | 欄位名稱不一致 | 標準化資料庫 |
| 性能問題 | 響應慢 | 缺少索引 | 建立索引策略 |

### 資料庫問題

| 問題類型 | 表面症狀 | 可能的根本原因 | 正確解決層次 |
|---------|---------|---------------|-------------|
| 查詢慢 | 超時 | 缺少索引 | 完整索引策略 |
| 數據不一致 | 孤兒記錄 | 缺少外鍵約束 | 完善約束系統 |
| Migration 失敗 | SQL 錯誤 | 表依賴錯誤 | 規劃 Migration 順序 |

---

## 📝 問題解決文檔範本

當解決一個系統性問題後，必須記錄：

```markdown
# 問題解決記錄：{問題簡述}

## 問題症狀
- 時間：YYYY-MM-DD
- 發現者：XXX
- 症狀描述：...

## 診斷過程
1. 表面症狀：...
2. 直接原因：...
3. 根本原因：...
4. 影響範圍：...

## 解決方案
1. 局部修復：...
2. 系統性改進：...
3. 架構調整：...

## 預防措施
1. 更新的文檔：...
2. 添加的測試：...
3. 更新的規範：...
4. 添加的工具：...

## 經驗教訓
- 學到什麼：...
- 如何預防：...
- 改進建議：...
```

**⚠️ 重要**: 將此記錄添加到相關設計文檔的「常見問題」章節

---

## ✅ 解決問題的最佳實踐

### Do's（必須做）

```
✅ 深入診斷，找到根本原因
✅ 評估影響範圍，全面解決
✅ 更新架構設計，系統改進
✅ 更新開發規範，預防再發
✅ 添加自動化測試
✅ 記錄解決過程
✅ 分享經驗教訓
```

### Don'ts（禁止做）

```
❌ 只修復表面問題
❌ 只解決單一案例
❌ 不追究根本原因
❌ 不更新文檔
❌ 不添加測試
❌ 不考慮預防措施
❌ 不分享經驗
```

---

## 🔄 持續改進流程

```
問題發生
    ↓
診斷根本原因
    ↓
系統性解決
    ↓
更新規範文檔
    ↓
添加自動化檢查
    ↓
團隊分享
    ↓
監控是否再發生
    ↓
（如再發生）
    ↓
分析為何預防失敗
    ↓
改進預防機制
```

---

## 📚 相關文檔

- [標準化開發流程與規範.md](./標準化開發流程與規範.md)
- [完整模組化系統設計.md](./完整模組化系統設計.md)
- [系統全面重構設計.md](./系統全面重構設計.md)

---

## 🎯 總結

**核心原則**：

1. **5 個為什麼**: 每個問題都問 5 次"為什麼"，找到根本原因
2. **系統思考**: 不只看單點，要看整個系統
3. **架構優先**: 架構問題要從架構層面解決
4. **文檔同步**: 解決問題後立即更新文檔
5. **預防為主**: 添加機制防止問題再發生

**記住**：
- 🔍 表面修復是技術債務
- 🎯 徹底解決才是真正的解決
- 📚 更新文檔是解決方案的一部分
- 🛡️ 預防機制是系統健康的保證

---

**最後更新**: 2025-10-26  
**維護者**: 開發團隊  
**狀態**: 📘 必須遵循

