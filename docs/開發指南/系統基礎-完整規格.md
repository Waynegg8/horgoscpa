# 系統基礎 - 完整開發規格

**給 AI：** 認證、員工管理、系統設定等基礎功能的完整技術規格

---

## 💾 資料表

### Users（員工/用戶）
```sql
CREATE TABLE Users (
  user_id INTEGER PRIMARY KEY AUTOINCREMENT,
  username TEXT UNIQUE NOT NULL,
  password_hash TEXT NOT NULL,
  name TEXT NOT NULL,
  email TEXT NOT NULL,                 -- 必填
  is_admin BOOLEAN DEFAULT 0,          -- ⭐ 核心：0=員工, 1=管理員
  gender TEXT NOT NULL,                -- 'M', 'F'（必填，影響假期選項）
  birth_date TEXT,
  start_date TEXT NOT NULL,            -- 到職日期（必填，用於計算年資和特休）
  phone TEXT,
  address TEXT,
  emergency_contact_name TEXT,
  emergency_contact_phone TEXT,
  
  -- 登入控制
  login_attempts INTEGER DEFAULT 0,
  last_failed_login TEXT,
  last_login TEXT,
  
  -- 審計欄位
  created_at TEXT DEFAULT (datetime('now')),
  updated_at TEXT DEFAULT (datetime('now')),
  is_deleted BOOLEAN DEFAULT 0,
  deleted_at TEXT,
  deleted_by INTEGER
);

CREATE UNIQUE INDEX idx_users_username ON Users(username);
CREATE INDEX idx_users_email ON Users(email);
CREATE INDEX idx_users_is_admin ON Users(is_admin);
```

### Settings（系統設定）
```sql
CREATE TABLE Settings (
  setting_key TEXT PRIMARY KEY,
  setting_value TEXT NOT NULL,
  description TEXT,
  is_dangerous BOOLEAN DEFAULT 0,  -- ⭐ 是否為危險設定（需警告）
  updated_at TEXT DEFAULT (datetime('now')),
  updated_by INTEGER,
  
  FOREIGN KEY (updated_by) REFERENCES Users(user_id)
);

CREATE UNIQUE INDEX idx_settings_key ON Settings(setting_key);

-- 預設系統參數
INSERT INTO Settings (setting_key, setting_value, description, is_dangerous) VALUES
('comp_leave_expiry_rule', 'current_month', '補休有效期規則', 1),  -- ⚠️ 危險設定
('daily_work_hours_limit', '12', '每日工時上限', 1),
('hourly_wage_base', '240', '月薪制換算時數', 1),
('company_name', '霍爾果斯會計師事務所', '公司名稱', 0),
('contact_email', 'contact@horgoscpa.com', '聯絡信箱', 0);

-- 補休有效期規則可選值說明：
-- 'current_month'  - 當月有效，次月1日歸0（預設）
-- 'next_month'     - 次月有效，次次月1日歸0
-- '3_months'       - 3個月有效
-- '6_months'       - 半年有效
```

### AuditLogs（審計日誌）
```sql
CREATE TABLE AuditLogs (
  log_id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  action TEXT NOT NULL,                -- CREATE, UPDATE, DELETE, LOGIN
  table_name TEXT NOT NULL,
  record_id TEXT,
  changes TEXT,                        -- JSON 格式
  ip_address TEXT,
  user_agent TEXT,
  created_at TEXT DEFAULT (datetime('now')),
  
  FOREIGN KEY (user_id) REFERENCES Users(user_id)
);

CREATE INDEX idx_audit_logs_user ON AuditLogs(user_id);
CREATE INDEX idx_audit_logs_table ON AuditLogs(table_name);
CREATE INDEX idx_audit_logs_action ON AuditLogs(action);
CREATE INDEX idx_audit_logs_date ON AuditLogs(created_at);
```

### FieldAuditTrail（字段級審計）
```sql
CREATE TABLE FieldAuditTrail (
  audit_id INTEGER PRIMARY KEY AUTOINCREMENT,
  table_name TEXT NOT NULL,
  record_id TEXT NOT NULL,
  field_name TEXT NOT NULL,
  old_value TEXT,
  new_value TEXT,
  changed_by INTEGER NOT NULL,
  changed_at TEXT DEFAULT (datetime('now')),
  
  FOREIGN KEY (changed_by) REFERENCES Users(user_id)
);

CREATE INDEX idx_field_audit_table_record ON FieldAuditTrail(table_name, record_id);
CREATE INDEX idx_field_audit_field ON FieldAuditTrail(field_name);
CREATE INDEX idx_field_audit_user ON FieldAuditTrail(changed_by);
CREATE INDEX idx_field_audit_date ON FieldAuditTrail(changed_at);
```

### Notifications（系統通知）⭐ 新增

**設計理由：** 儀表板提醒功能（工時缺填、任務逾期等）

**設計哲學：**
- ✅ 專注於「需要處理的事項」，不是社交通知中心
- ✅ 自動消失機制：問題解決後，通知自動移除
- ✅ 簡化狀態：不需要「已讀/未讀」區分，只有「顯示/移除」

```sql
CREATE TABLE Notifications (
  notification_id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,             -- 通知對象（員工或管理員）
  type TEXT NOT NULL,                   -- 通知類型
  message TEXT NOT NULL,                -- 通知訊息
  related_date TEXT,                    -- 關聯日期（如：缺填的日期）
  related_user_id INTEGER,              -- 關聯用戶（管理員看員工缺填時用）
  action_url TEXT,                      -- 操作連結（如：/timesheets/new?date=2025-11-26）
  auto_dismiss BOOLEAN DEFAULT 1,       -- 是否自動消失（1=問題解決後自動移除，0=需手動關閉）
  created_at TEXT DEFAULT (datetime('now')),
  is_deleted BOOLEAN DEFAULT 0,         -- 是否已移除（0=顯示在列表，1=已移除）
  dismissed_at TEXT,                    -- 移除時間（自動或手動）
  
  FOREIGN KEY (user_id) REFERENCES Users(user_id),
  FOREIGN KEY (related_user_id) REFERENCES Users(user_id),
  CHECK (type IN ('missing_timesheet', 'task_overdue', 'leave_pending', 'payment_overdue', 'cron_failed'))
);

CREATE INDEX idx_notifications_user ON Notifications(user_id);
CREATE INDEX idx_notifications_type ON Notifications(type);
CREATE INDEX idx_notifications_deleted ON Notifications(is_deleted);
CREATE INDEX idx_notifications_date ON Notifications(related_date);
CREATE UNIQUE INDEX idx_notifications_unique ON Notifications(user_id, type, related_date, related_user_id) 
  WHERE is_deleted = 0;  -- 同一用戶同類型同日期只有一筆未移除通知
```

**狀態機定義：**

```typescript
/**
 * 通知生命週期
 * 
 * 1. 創建通知（系統自動）
 *    is_deleted = 0
 *    auto_dismiss = 1（工時缺填、補休到期等）
 * 
 * 2. 問題解決（自動移除）
 *    - 觸發：員工填寫工時、使用補休等
 *    - 動作：is_deleted = 1, dismissed_at = now()
 *    - 結果：通知從儀表板消失
 * 
 * 3. 查詢顯示
 *    SELECT * FROM Notifications
 *    WHERE user_id = ? AND is_deleted = 0
 *    ORDER BY created_at DESC
 * 
 * ⚠️ 簡化設計說明：
 * - 移除 is_read 欄位（不需要「已讀/未讀」區分）
 * - 移除 read_at 欄位（改用 dismissed_at）
 * - 通知要麼「需要處理」（顯示），要麼「已處理」（移除）
 * - 沒有「查看歷史通知」功能（保持介面簡潔）
 */
```

**通知類型說明：**
```
missing_timesheet   - 工時缺填提醒（auto_dismiss=1，填寫後自動消失）
  員工：看到自己缺填的日期
  管理員：看到所有員工缺填統計
  
task_overdue        - 任務逾期提醒（auto_dismiss=1，任務完成後自動消失）

leave_pending       - 假期待審核（目前無審核機制，保留欄位）

payment_overdue     - 應收帳款逾期（auto_dismiss=1，收款後自動消失）

cron_failed         - 定時任務執行失敗（auto_dismiss=0，需管理員手動處理）
```

### 數據歸檔表（熱數據保留2年）
```sql
-- TimeLogs 歸檔表（按年份）
CREATE TABLE TimeLogs_Archive_2023 (
  log_id INTEGER PRIMARY KEY,
  user_id INTEGER NOT NULL,
  work_date TEXT NOT NULL,
  client_id TEXT,
  hours REAL NOT NULL,
  work_type_id INTEGER DEFAULT 1,
  description TEXT,
  created_at TEXT,
  updated_at TEXT,
  is_deleted BOOLEAN DEFAULT 0
);

-- LeaveApplications 歸檔表（按年份）
CREATE TABLE LeaveApplications_Archive_2023 (
  leave_id INTEGER PRIMARY KEY,
  user_id INTEGER NOT NULL,
  leave_type_id INTEGER NOT NULL,
  start_date TEXT NOT NULL,
  end_date TEXT NOT NULL,
  total_days REAL NOT NULL,
  reason TEXT,
  status TEXT DEFAULT 'approved',
  created_at TEXT,
  is_deleted BOOLEAN DEFAULT 0
);

-- AuditLogs 歸檔表（按年份）
CREATE TABLE AuditLogs_Archive_2023 (
  log_id INTEGER PRIMARY KEY,
  user_id INTEGER NOT NULL,
  action TEXT NOT NULL,
  table_name TEXT NOT NULL,
  record_id TEXT,
  changes TEXT,
  ip_address TEXT,
  user_agent TEXT,
  created_at TEXT
);
```

---

## 🔌 API 端點

### 認證
```
POST /api/v1/auth/login              登入
POST /api/v1/auth/logout             登出
GET  /api/v1/auth/me                 驗證當前會話
POST /api/v1/auth/change-password    修改密碼
```

### 個人資料
```
GET  /api/v1/profile                 獲取個人資料
PUT  /api/v1/profile                 更新個人資料
```

### 員工管理（管理員）
```
GET    /api/v1/admin/users           查詢員工列表
POST   /api/v1/admin/users           新增員工
GET    /api/v1/admin/users/:id       查詢員工詳情
PUT    /api/v1/admin/users/:id       更新員工
DELETE /api/v1/admin/users/:id       刪除員工
POST   /api/v1/admin/users/:id/reset-password  重設密碼
```

### 系統設定（管理員）
```
GET  /api/v1/admin/settings          獲取所有設定
PUT  /api/v1/admin/settings/:key     更新設定值
```

**獲取設定範例：**
```json
// GET /api/v1/admin/settings

{
  "success": true,
  "data": [
    {
      "setting_key": "comp_leave_expiry_rule",
      "setting_value": "current_month",
      "description": "補休有效期規則",
      "is_dangerous": true,
      "updated_at": "2025-01-01 00:00:00"
    },
    {
      "setting_key": "daily_work_hours_limit",
      "setting_value": "12",
      "description": "每日工時上限",
      "is_dangerous": true
    },
    {
      "setting_key": "company_name",
      "setting_value": "宏國會計師事務所",
      "description": "公司名稱",
      "is_dangerous": false
    }
  ]
}
```

**更新設定範例（危險設定）：**
```json
// PUT /api/v1/admin/settings/comp_leave_expiry_rule
{
  "setting_value": "next_month",
  "confirmed": true  // ⭐ 危險設定需確認
}

// 回應
{
  "success": true,
  "data": {
    "setting_key": "comp_leave_expiry_rule",
    "setting_value": "next_month",
    "old_value": "current_month",
    "warning": "⚠️ 補休有效期延長可能增加人力成本"
  }
}
```

### 審計日誌（管理員）
```
GET  /api/v1/admin/audit-logs        查詢操作日誌
GET  /api/v1/admin/audit-logs/user/:userId  查詢特定員工的日誌
```

---

## 🎨 前端組件

### SystemSettingsPage.vue（系統參數設定）⭐ 新增

```vue
<template>
  <div class="system-settings-page">
    <h2>系統參數</h2>
    
    <!-- 危險設定區域（警告色）-->
    <div class="settings-section danger-section">
      <h3>⚠️ 危險設定（修改前請三思）</h3>
      <p class="warning-text">
        以下設定會影響系統核心運作，修改後可能增加成本或造成法律風險。
      </p>
      
      <!-- 補休有效期 -->
      <div class="setting-item">
        <label class="setting-label">
          <strong>補休有效期規則</strong>
          <span class="current-value">當前：{{ getExpiryRuleText(settings.comp_leave_expiry_rule) }}</span>
        </label>
        
        <select v-model="tempSettings.comp_leave_expiry_rule">
          <option value="current_month">當月有效（推薦）</option>
          <option value="next_month">次月有效</option>
          <option value="3_months">3個月有效</option>
          <option value="6_months">半年有效</option>
        </select>
        
        <div v-if="tempSettings.comp_leave_expiry_rule !== 'current_month'" class="warning-box">
          <p>⚠️ <strong>風險警告：</strong></p>
          <ul>
            <li>延長補休有效期會讓員工補休累積過多</li>
            <li>到期時轉換為加班費，增加人力成本</li>
            <li>範例：改為「次月有效」，成本可能增加15-30%</li>
          </ul>
          <label>
            <input type="checkbox" v-model="confirmDangerous" />
            我了解風險，確定要修改
          </label>
        </div>
        
        <StyledButton 
          @click="updateSetting('comp_leave_expiry_rule')"
          :disabled="tempSettings.comp_leave_expiry_rule !== 'current_month' && !confirmDangerous"
          variant="warning"
        >
          儲存修改
        </StyledButton>
      </div>
      
      <hr />
      
      <!-- 每日工時上限 -->
      <div class="setting-item">
        <label class="setting-label">
          <strong>每日工時上限</strong>
          <span class="current-value">當前：{{ settings.daily_work_hours_limit }} 小時</span>
        </label>
        
        <input 
          type="number" 
          v-model.number="tempSettings.daily_work_hours_limit" 
          min="8"
          max="12"
          disabled
        />
        
        <p class="readonly-hint">⚠️ 此參數受勞基法限制，不可修改（固定12小時）</p>
      </div>
      
      <hr />
      
      <!-- 月薪制換算時數 -->
      <div class="setting-item">
        <label class="setting-label">
          <strong>月薪制換算時數</strong>
          <span class="current-value">當前：{{ settings.hourly_wage_base }} 小時</span>
        </label>
        
        <input 
          type="number" 
          v-model.number="tempSettings.hourly_wage_base" 
          disabled
        />
        
        <p class="readonly-hint">⚠️ 此參數受勞基法限制，不可修改（固定240小時）</p>
      </div>
    </div>
    
    <!-- 一般設定區域 -->
    <div class="settings-section normal-section">
      <h3>一般設定</h3>
      
      <div class="setting-item">
        <label class="setting-label">公司名稱</label>
        <input v-model="tempSettings.company_name" />
        <StyledButton @click="updateSetting('company_name')">儲存</StyledButton>
      </div>
      
      <div class="setting-item">
        <label class="setting-label">聯絡信箱</label>
        <input v-model="tempSettings.contact_email" type="email" />
        <StyledButton @click="updateSetting('contact_email')">儲存</StyledButton>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import { getSettings, updateSetting as apiUpdateSetting } from '@/api/settings';

const settings = ref({});
const tempSettings = ref({});
const confirmDangerous = ref(false);

onMounted(async () => {
  const response = await getSettings();
  settings.value = response.data.reduce((obj, item) => {
    obj[item.setting_key] = item.setting_value;
    return obj;
  }, {});
  tempSettings.value = { ...settings.value };
});

function getExpiryRuleText(value) {
  const map = {
    'current_month': '當月有效（次月1日歸0）',
    'next_month': '次月有效',
    '3_months': '3個月有效',
    '6_months': '半年有效'
  };
  return map[value] || value;
}

async function updateSetting(key) {
  const isDangerous = ['comp_leave_expiry_rule', 'daily_work_hours_limit', 'hourly_wage_base'].includes(key);
  
  if (isDangerous && !confirmDangerous.value) {
    alert('請先勾選「我了解風險」');
    return;
  }
  
  try {
    await apiUpdateSetting(key, {
      setting_value: tempSettings.value[key],
      confirmed: confirmDangerous.value
    });
    
    alert('設定已更新');
    settings.value[key] = tempSettings.value[key];
    confirmDangerous.value = false;  // 重置確認
  } catch (error) {
    alert('更新失敗：' + error.message);
  }
}
</script>

<style scoped>
.danger-section {
  border: 2px solid #ef4444;
  border-radius: 8px;
  padding: 1.5rem;
  margin-bottom: 2rem;
  background: #fef2f2;
}

.warning-box {
  background: #fef3c7;
  border-left: 4px solid #f59e0b;
  padding: 1rem;
  margin: 1rem 0;
}

.warning-box ul {
  margin: 0.5rem 0;
  padding-left: 1.5rem;
}

.readonly-hint {
  color: #6b7280;
  font-size: 0.875rem;
  font-style: italic;
}

.current-value {
  color: #059669;
  font-weight: 600;
  margin-left: 1rem;
}
</style>
```

---

## 🔧 後端實現

### AuthService
```typescript
class AuthService {
  async login(username, password) {
    // 1. 查詢用戶
    const user = await this.userRepo.findByUsername(username);
    if (!user) {
      throw new UnauthorizedError('帳號或密碼錯誤');
    }
    
    // 2. 檢查鎖定
    if (user.login_attempts >= 5) {
      const lockUntil = addMinutes(user.last_failed_login, 15);
      if (new Date() < lockUntil) {
        throw new ForbiddenError('帳號已鎖定，請15分鐘後再試');
      }
      // 重置計數器
      user.login_attempts = 0;
    }
    
    // 3. 驗證密碼
    const isValid = await verifyPassword(password, user.password_hash);
    if (!isValid) {
      // 增加失敗次數
      await this.userRepo.incrementLoginAttempts(user.user_id);
      throw new UnauthorizedError('帳號或密碼錯誤');
    }
    
    // 4. 重置失敗計數，更新登入時間
    await this.userRepo.update(user.user_id, {
      login_attempts: 0,
      last_login: new Date()
    });
    
    // 5. 生成 JWT Token
    const token = await createJWT({
      user_id: user.user_id,
      username: user.username,
      is_admin: user.is_admin
    }, JWT_SECRET);
    
    return { user, token };
  }
  
  async changePassword(userId, currentPassword, newPassword) {
    // 1. 獲取用戶
    const user = await this.userRepo.findById(userId);
    
    // 2. 驗證原密碼
    const isValid = await verifyPassword(currentPassword, user.password_hash);
    if (!isValid) {
      throw new UnauthorizedError('原密碼錯誤');
    }
    
    // 3. 驗證新密碼長度（業務需求：無複雜度要求）
    if (newPassword.length < 6) {
      throw new ValidationError('密碼至少6個字元');
    }
    
    // 4. 雜湊並更新
    const hashedPassword = await hashPassword(newPassword);
    await this.userRepo.update(userId, {
      password_hash: hashedPassword
    });
    
    return { success: true };
  }
}
```

### UserManagementService
```typescript
class UserManagementService {
  async createUser(data, adminUserId) {
    // 1. 驗證必填欄位
    if (!data.username || !data.name || !data.email || !data.gender || !data.start_date) {
      throw new ValidationError('使用者名稱、姓名、Email、性別、到職日為必填');
    }
    
    // 2. 驗證性別值
    if (!['M', 'F', '男', '女'].includes(data.gender)) {
      throw new ValidationError('性別必須為：M（男）或 F（女）');
    }
    
    // 2. 檢查唯一性
    const existing = await this.repository.findByUsername(data.username);
    if (existing) {
      throw new ConflictError('使用者名稱已存在');
    }
    
    // 3. 生成初始密碼
    const initialPassword = generateRandomPassword();
    const hashedPassword = await hashPassword(initialPassword);
    
    // 4. 創建用戶
    const user = await this.repository.create({
      ...data,
      password_hash: hashedPassword,
      is_admin: data.is_admin || false
    });
    
    // 5. 記錄審計日誌
    await this.auditLog.log({
      user_id: adminUserId,
      action: 'CREATE',
      table_name: 'Users',
      record_id: user.user_id
    });
    
    return { user, initialPassword };
  }
  
  async resetPassword(userId, adminUserId) {
    // 1. 生成新密碼
    const newPassword = generateRandomPassword();
    const hashedPassword = await hashPassword(newPassword);
    
    // 2. 更新
    await this.repository.update(userId, {
      password_hash: hashedPassword,
      login_attempts: 0
    });
    
    // 3. 記錄日誌
    await this.auditLog.log({
      user_id: adminUserId,
      action: 'RESET_PASSWORD',
      table_name: 'Users',
      record_id: userId
    });
    
    return { newPassword };
  }
}
```

### AuditLogService
```typescript
class AuditLogService {
  async log(data) {
    await this.repository.create({
      user_id: data.user_id,
      action: data.action,
      table_name: data.table_name,
      record_id: data.record_id,
      changes: JSON.stringify(data.changes || {}),
      ip_address: data.ip_address,
      user_agent: data.user_agent
    });
  }
  
  async getRecordHistory(tableName, recordId) {
    return await this.repository.findByRecord(tableName, recordId);
  }
  
  async getUserLogs(userId, startDate, endDate) {
    return await this.repository.findByUser(userId, startDate, endDate);
  }
}
```

---

## 🔒 安全機制

### 密碼雜湊（使用 bcrypt）
```typescript
import bcrypt from 'bcryptjs';

// 雜湊密碼
// 使用 bcrypt，成本因子 12（平衡安全性與效能）
async function hashPassword(password: string): Promise<string> {
  const saltRounds = 12;
  return await bcrypt.hash(password, saltRounds);
}

// 驗證密碼
async function verifyPassword(password: string, hash: string): Promise<boolean> {
  return await bcrypt.compare(password, hash);
}

// 密碼強度驗證（⚠️ 依業務需求：無密碼規則）
function isStrongPassword(password: string): boolean {
  // 業務需求確認：無密碼強度要求
  // 只檢查最小長度
  if (password.length < 6) return false;
  
  return true;
  
  // ❌ 移除複雜度要求（業務報告明確說明「無密碼規則」）
  // if (!/[A-Z]/.test(password)) return false;
  // if (!/[a-z]/.test(password)) return false;
  // if (!/[0-9]/.test(password)) return false;
}

// 生成隨機密碼（用於初始密碼和重設密碼）
function generateRandomPassword(): string {
  const uppercaseChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  const lowercaseChars = 'abcdefghijklmnopqrstuvwxyz';
  const numberChars = '0123456789';
  const specialChars = '!@#$%^&*';
  
  let password = '';
  password += uppercaseChars[Math.floor(Math.random() * uppercaseChars.length)];
  password += lowercaseChars[Math.floor(Math.random() * lowercaseChars.length)];
  password += numberChars[Math.floor(Math.random() * numberChars.length)];
  password += specialChars[Math.floor(Math.random() * specialChars.length)];
  
  // 填充至 12 個字元
  const allChars = uppercaseChars + lowercaseChars + numberChars + specialChars;
  for (let i = 4; i < 12; i++) {
    password += allChars[Math.floor(Math.random() * allChars.length)];
  }
  
  // 打亂順序
  return password.split('').sort(() => Math.random() - 0.5).join('');
}
```

**為什麼選擇 bcrypt：**
- ✅ 專為密碼設計的雜湊算法
- ✅ 自動加鹽（salt）
- ✅ 計算成本可調整（成本因子 12）
- ✅ 抗彩虹表攻擊
- ✅ 成熟穩定，廣泛使用

**避免使用：**
- ❌ SHA-256/SHA-512（太快，易被暴力破解）
- ❌ MD5（已被攻破，不安全）

### 登入失敗鎖定
```
連續失敗 5 次 → 鎖定 15 分鐘
登入成功 → 重置計數器
```

### 密碼強度要求

⚠️ **業務需求確認：** 無密碼強度規則（小型事務所，簡化管理）

```
最小長度：6 個字元
無複雜度要求（不強制大小寫、數字等）
```

### JWT Token
```typescript
{
  user_id: 1,
  username: 'admin',
  is_admin: true,
  iat: 1234567890,
  exp: 1234654290
}

// 儲存在 HttpOnly Cookie
// 有效期：24小時
```

---

## ✅ 系統設定 Key-Value

| Key | 說明 | 預設值 |
|-----|------|--------|
| `system_name` | 系統名稱 | "XX 會計師事務所" |
| `default_working_hours` | 預設工時/日 | "8" |
| `fiscal_year_start` | 會計年度開始月 | "1" |
| `comp_leave_expiry_months` | 補休期限（月）| "12" |

---

## 📦 數據歸檔策略

### 歸檔時機
```
每年 1 月 1 日 03:00 執行歸檔作業
歸檔前 2 年的數據（保留熱數據 2 年）
```

### 歸檔流程
```typescript
// 1. 創建歸檔表（如果不存在）
const archiveYear = new Date().getFullYear() - 2;
await db.exec(`
  CREATE TABLE IF NOT EXISTS TimeLogs_Archive_${archiveYear} 
  AS SELECT * FROM TimeLogs WHERE 1=0;
`);

// 2. 遷移數據
await db.exec(`
  INSERT INTO TimeLogs_Archive_${archiveYear}
  SELECT * FROM TimeLogs 
  WHERE created_at < datetime('now', '-2 years');
`);

// 3. 刪除已歸檔數據
await db.exec(`
  DELETE FROM TimeLogs 
  WHERE created_at < datetime('now', '-2 years');
`);

// 4. 記錄歸檔日誌
await auditLog.log({
  action: 'ARCHIVE',
  table_name: 'TimeLogs',
  details: `Archived ${count} records to ${archiveYear}`
});
```

### 歸檔數據查詢
```typescript
// 查詢歷史數據（包含歸檔）
async function getTimeLogsWithArchive(userId, startDate, endDate) {
  const year = new Date(startDate).getFullYear();
  const currentYear = new Date().getFullYear();
  
  // 判斷是否需要查詢歸檔表
  if (year < currentYear - 2) {
    return await db.query(`
      SELECT * FROM TimeLogs_Archive_${year}
      WHERE user_id = ? AND work_date BETWEEN ? AND ?
    `, [userId, startDate, endDate]);
  } else {
    return await db.query(`
      SELECT * FROM TimeLogs
      WHERE user_id = ? AND work_date BETWEEN ? AND ?
    `, [userId, startDate, endDate]);
  }
}
```

### 歸檔備份
```
1. 每月將歸檔表備份到 Cloudflare R2
2. 保留 7 年（法規要求）
3. 壓縮存儲（節省空間）
```

---

## ⏱️ 時間戳存儲說明

### 當前方案：TEXT 格式
```sql
created_at TEXT DEFAULT (datetime('now'))
-- 格式：'2024-10-28 15:30:45'
```

**優勢：**
- ✅ 人類可讀，調試方便
- ✅ SQLite datetime 函數直接支持
- ✅ 不需要應用層轉換

**劣勢：**
- ⚠️ 占用空間較大（19 字節）
- ⚠️ 範圍查詢性能較 INTEGER 稍慢

### 替代方案：INTEGER（UNIX時間戳）
```sql
created_at INTEGER DEFAULT (strftime('%s', 'now'))
-- 格式：1698516645
```

**優勢：**
- ✅ 占用空間小（4-8 字節）
- ✅ 範圍查詢性能更好
- ✅ 時區處理簡單

**劣勢：**
- ⚠️ 數據庫內查看不直觀
- ⚠️ 需要應用層轉換

### 決策：保持 TEXT 格式
```
理由：
1. 內部系統，數據量不大（<100萬條）
2. 調試和維護便利性更重要
3. SQLite datetime 函數生態完善
4. 性能差異在可接受範圍內
```

**如果未來數據量激增：**
- 再評估遷移到 INTEGER
- 或使用數據庫級優化（分區、索引優化）

---

**這個文檔包含系統基礎功能的所有技術細節。**

