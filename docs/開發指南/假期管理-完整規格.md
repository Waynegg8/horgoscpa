# 假期管理 - 完整開發規格

**給 AI：** 實現假期管理功能的完整技術規格

---

## 💾 資料表

### LeaveApplications
```sql
CREATE TABLE LeaveApplications (
  application_id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  leave_type_id INTEGER NOT NULL,
  start_date TEXT NOT NULL,
  end_date TEXT NOT NULL,
  days REAL NOT NULL,
  hours REAL,
  reason TEXT,
  event_type TEXT,                      -- 如果是生活事件產生的
  counts_as_sick_leave BOOLEAN DEFAULT 0,  -- ⭐ 生理假專用：是否併入病假（第4日起）
  applied_at TEXT DEFAULT (datetime('now')),
  is_deleted BOOLEAN DEFAULT 0,         -- ⭐ 軟刪除標記
  deleted_at TEXT,                      -- ⭐ 刪除時間
  deleted_by INTEGER,                   -- ⭐ 刪除人員
  
  FOREIGN KEY (user_id) REFERENCES Users(user_id),
  FOREIGN KEY (leave_type_id) REFERENCES LeaveTypes(leave_type_id),
  FOREIGN KEY (deleted_by) REFERENCES Users(user_id)
);

CREATE INDEX idx_leave_apps_user ON LeaveApplications(user_id);
CREATE INDEX idx_leave_apps_date ON LeaveApplications(start_date, end_date);
CREATE INDEX idx_leave_apps_user_date ON LeaveApplications(user_id, start_date, end_date);  -- ⭐ 假期查詢專用
CREATE INDEX idx_leave_apps_type_year ON LeaveApplications(leave_type_id, start_date);  -- ⭐ 假期統計專用
```

**索引使用說明：**
```
idx_leave_apps_user_date: ⭐ 新增
  用途：查詢員工某時間區間的請假記錄
  查詢：WHERE user_id = ? AND start_date <= ? AND end_date >= ?
  效能提升：避免重疊假期檢查時的全表掃描
```

### LeaveTypes（假別類型）
```sql
CREATE TABLE LeaveTypes (
  leave_type_id INTEGER PRIMARY KEY AUTOINCREMENT,
  type_name TEXT UNIQUE NOT NULL,
  annual_quota REAL,                    -- 年度額度（天）
  deduct_leave BOOLEAN DEFAULT 1,       -- 是否扣假
  is_paid BOOLEAN DEFAULT 1,            -- 是否有薪
  affects_attendance BOOLEAN DEFAULT 1, -- 是否影響全勤
  gender_specific TEXT,                 -- 'M'=男性限定,'F'=女性限定,NULL=不限
  is_enabled BOOLEAN DEFAULT 1
);

-- 預設假別（⚠️ 注意性別限制）
INSERT INTO LeaveTypes VALUES
  (1, '特休', NULL, 1, 1, 0, NULL, 1),      -- 依年資計算，不影響全勤
  (2, '病假', 30, 1, 1, 1, NULL, 1),        -- 影響全勤
  (3, '事假', 14, 1, 0, 1, NULL, 1),        -- 影響全勤
  (4, '婚假', 8, 1, 1, 0, NULL, 1),         -- 不影響全勤
  (5, '產假', 56, 1, 1, 0, 'F', 1),         -- 限女性，不影響全勤
  (6, '產檢假', 7, 1, 1, 0, 'F', 1),        -- 限女性，不影響全勤
  (7, '陪產檢及陪產假', 7, 1, 1, 0, 'M', 1), -- 限男性，不影響全勤
  (8, '生理假', 12, 1, 0.5, 0, 'F', 1),     -- 限女性，半薪，不影響全勤
  (9, '喪假', NULL, 1, 1, 0, NULL, 1),      -- 不影響全勤
  (10, '公假', NULL, 1, 1, 0, NULL, 1),     -- 不影響全勤
  (11, '家庭照顧假', 7, 1, 0, 0, NULL, 1),  -- 不影響全勤
  (12, '補休', NULL, 0, 1, 0, NULL, 1),     -- 不扣假，不影響全勤
  (13, '颱風假', NULL, 1, 0, 0, NULL, 1);   -- 不影響全勤
```

### AnnualLeaveRules（特休規則）
```sql
CREATE TABLE AnnualLeaveRules (
  rule_id INTEGER PRIMARY KEY AUTOINCREMENT,
  min_months INTEGER NOT NULL,
  max_months INTEGER NOT NULL,
  days INTEGER NOT NULL
);

-- 法定特休（勞基法第38條）
INSERT INTO AnnualLeaveRules VALUES
  (1, 6, 12, 3),       -- 6個月-1年：3天
  (2, 12, 24, 7),      -- 1-2年：7天
  (3, 24, 36, 10),     -- 2-3年：10天
  (4, 36, 60, 14),     -- 3-5年：14天
  (5, 60, 120, 15),    -- 5-10年：15天
  (6, 120, 132, 16),   -- 10-11年：16天
  (7, 132, 144, 17),   -- 11-12年：17天
  (8, 144, 156, 18),   -- 12-13年：18天
  (9, 156, 168, 19),   -- 13-14年：19天
  (10, 168, 180, 20),  -- 14-15年：20天
  -- ... 以此類推，每滿1年加1天，最高30天
  (11, 300, 999999, 30); -- 25年以上：30天（上限）
```

### AnnualLeaveBalance（特休餘額）⚠️ 累積制
```sql
CREATE TABLE AnnualLeaveBalance (
  balance_id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  year INTEGER NOT NULL,                -- 年度
  entitled_days REAL NOT NULL,          -- 當年度新增特休
  carried_over_days REAL DEFAULT 0,     -- 去年遞延特休（累積）
  used_days REAL DEFAULT 0,             -- 已使用天數
  remaining_days REAL NOT NULL,         -- 剩餘天數
  created_at TEXT DEFAULT (datetime('now')),
  updated_at TEXT DEFAULT (datetime('now')),
  
  FOREIGN KEY (user_id) REFERENCES Users(user_id),
  UNIQUE(user_id, year)
);

CREATE INDEX idx_annual_leave_balance_user ON AnnualLeaveBalance(user_id);
CREATE INDEX idx_annual_leave_balance_year ON AnnualLeaveBalance(year);
```

### OtherLeaveRules（其他假期規則）
```sql
CREATE TABLE OtherLeaveRules (
  rule_id INTEGER PRIMARY KEY AUTOINCREMENT,
  leave_type_id INTEGER NOT NULL,
  event_type TEXT NOT NULL,             -- '結婚','生育','父母過世'等
  days REAL NOT NULL,
  validity_days INTEGER DEFAULT 365,
  
  FOREIGN KEY (leave_type_id) REFERENCES LeaveTypes(leave_type_id)
);

-- 預設規則
INSERT INTO OtherLeaveRules VALUES
  (1, 4, '結婚', 8, 365),
  (2, 5, '生育', 56, 0),
  (3, 6, '配偶生育', 7, 15),
  (4, 7, '父母過世', 8, 365),
  (5, 7, '配偶過世', 8, 365),
  (6, 7, '祖父母過世', 6, 365);
```

### LifeEventLeaveGrants（生活事件假期額度）⭐ 新增

**設計理由：** 追蹤生活事件產生的假期餘額和有效期（如：婚假8天，1年內分次使用）

```sql
CREATE TABLE LifeEventLeaveGrants (
  grant_id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  leave_type_id INTEGER NOT NULL,       -- 假別（婚假、喪假等）
  event_type TEXT NOT NULL,             -- 事件類型（'結婚'、'父母過世'等）
  event_date TEXT NOT NULL,             -- 事件發生日期
  total_days REAL NOT NULL,             -- 總額度（如：8天）
  used_days REAL DEFAULT 0,             -- 已使用天數
  remaining_days REAL NOT NULL,         -- 剩餘天數
  valid_from TEXT NOT NULL,             -- 有效期起始日
  valid_until TEXT NOT NULL,            -- 有效期結束日
  created_at TEXT DEFAULT (datetime('now')),
  is_deleted BOOLEAN DEFAULT 0,
  
  FOREIGN KEY (user_id) REFERENCES Users(user_id),
  FOREIGN KEY (leave_type_id) REFERENCES LeaveTypes(leave_type_id)
);

CREATE INDEX idx_life_event_grants_user ON LifeEventLeaveGrants(user_id);
CREATE INDEX idx_life_event_grants_valid ON LifeEventLeaveGrants(valid_until);
CREATE INDEX idx_life_event_grants_type ON LifeEventLeaveGrants(leave_type_id);

/**
 * 範例資料：
 * 
 * 員工B登記「結婚」事件（2025-12-15）：
 * INSERT INTO LifeEventLeaveGrants VALUES
 * (1, 2, 4, '結婚', '2025-12-15', 8.0, 0.0, 8.0, '2025-12-15', '2026-12-14', ...);
 * 
 * 使用狀態追蹤：
 * - 12月請5天婚假 → used_days = 5.0, remaining_days = 3.0
 * - 剩餘3天可在 2026-12-14 前使用
 * - 超過有效期 → 自動失效（或由Cron Job標記為過期）
 */
```

### CronJobExecutions（定時任務執行記錄）⭐

**注意：** 此表定義在 [系統基礎-完整規格.md](./系統基礎-完整規格.md) 中，此處僅供參考。

```sql
CREATE TABLE CronJobExecutions (
  execution_id INTEGER PRIMARY KEY AUTOINCREMENT,
  job_name TEXT NOT NULL,               -- 任務名稱（如：'annual_leave_update'）
  execution_date TEXT NOT NULL,         -- 執行日期（如：'2026-01-01'）
  status TEXT NOT NULL,                 -- 'success', 'failed'
  affected_users INTEGER DEFAULT 0,     -- 影響的用戶數
  error_message TEXT,                   -- 錯誤訊息（失敗時）
  executed_at TEXT DEFAULT (datetime('now')),
  execution_duration_ms INTEGER,        -- 執行時長（毫秒）
  
  CHECK (status IN ('success', 'failed'))
);

CREATE INDEX idx_cron_job_name ON CronJobExecutions(job_name);
CREATE INDEX idx_cron_job_date ON CronJobExecutions(execution_date);
CREATE INDEX idx_cron_job_status ON CronJobExecutions(status);
CREATE UNIQUE INDEX idx_cron_job_unique ON CronJobExecutions(job_name, execution_date, status) 
  WHERE status = 'success';  -- 同一天同一任務只能成功執行一次
```

**詳細設計請參考：** [系統基礎-完整規格.md](./系統基礎-完整規格.md)

### Notifications（系統通知）⭐ 

**注意：** 此表定義在 [系統基礎-完整規格.md](./系統基礎-完整規格.md) 中，此處僅供參考。

```sql
CREATE TABLE Notifications (
  notification_id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,             -- 通知對象（員工或管理員）
  type TEXT NOT NULL,                   -- 通知類型
  message TEXT NOT NULL,                -- 通知訊息
  related_date TEXT,                    -- 關聯日期（如：缺填的日期）
  related_user_id INTEGER,              -- 關聯用戶（管理員看員工缺填時用）
  action_url TEXT,                      -- 操作連結（如：/timesheets/new?date=2025-11-26）
  auto_dismiss BOOLEAN DEFAULT 1,       -- 是否自動消失（1=問題解決後自動移除，0=需手動關閉）
  created_at TEXT DEFAULT (datetime('now')),
  is_deleted BOOLEAN DEFAULT 0,         -- 是否已移除（0=顯示在列表，1=已移除）
  dismissed_at TEXT,                    -- 移除時間（自動或手動）
  
  FOREIGN KEY (user_id) REFERENCES Users(user_id),
  FOREIGN KEY (related_user_id) REFERENCES Users(user_id),
  CHECK (type IN ('missing_timesheet', 'task_overdue', 'leave_pending', 'payment_overdue', 'cron_failed'))
);

CREATE INDEX idx_notifications_user ON Notifications(user_id);
CREATE INDEX idx_notifications_type ON Notifications(type);
CREATE INDEX idx_notifications_deleted ON Notifications(is_deleted);
CREATE INDEX idx_notifications_date ON Notifications(related_date);
CREATE UNIQUE INDEX idx_notifications_unique ON Notifications(user_id, type, related_date, related_user_id) 
  WHERE is_deleted = 0;  -- 同一用戶同類型同日期只有一筆未移除通知
```

**詳細設計請參考：** [系統基礎-完整規格.md](./系統基礎-完整規格.md)

---

## 🔌 API 端點

### 1. 新增假期申請
```
POST /api/v1/leave/applications
```

**請求：**
```json
{
  "leave_type_id": 1,
  "start_date": "2025-11-15",
  "end_date": "2025-11-16",
  "days": 2,
  "reason": "家庭事務"
}
```

### 2. 查詢假期餘額
```
GET /api/v1/leave/balance?user_id=1&year=2025
```

**響應：**
```json
{
  "success": true,
  "data": {
    "balances": [
      {
        "leave_type": "特休",
        "entitled_days": 10,
        "used_days": 3,
        "remaining_days": 7
      },
      {
        "leave_type": "病假",
        "entitled_days": 30,
        "used_days": 2,
        "remaining_days": 28
      }
    ]
  }
}
```

### 3. 查詢可申請的假別（依性別過濾）⭐ 新增
```
GET /api/v1/leave/available-types?user_id=1
```

**回應範例（女性員工）：**
```json
{
  "success": true,
  "data": [
    { "leave_type_id": 1, "type_name": "特休", "gender_specific": null },
    { "leave_type_id": 2, "type_name": "病假", "gender_specific": null },
    { "leave_type_id": 3, "type_name": "事假", "gender_specific": null },
    { "leave_type_id": 4, "type_name": "婚假", "gender_specific": null },
    { "leave_type_id": 5, "type_name": "產假", "gender_specific": "F" },
    { "leave_type_id": 6, "type_name": "產檢假", "gender_specific": "F" },
    { "leave_type_id": 8, "type_name": "生理假", "gender_specific": "F" },
    { "leave_type_id": 9, "type_name": "喪假", "gender_specific": null },
    { "leave_type_id": 10, "type_name": "公假", "gender_specific": null }
    // ⚠️ 不包含「陪產檢及陪產假」（leave_type_id = 7，限男性）
  ]
}
```

**回應範例（男性員工）：**
```json
{
  "success": true,
  "data": [
    { "leave_type_id": 1, "type_name": "特休", "gender_specific": null },
    { "leave_type_id": 2, "type_name": "病假", "gender_specific": null },
    { "leave_type_id": 3, "type_name": "事假", "gender_specific": null },
    { "leave_type_id": 4, "type_name": "婚假", "gender_specific": null },
    { "leave_type_id": 7, "type_name": "陪產檢及陪產假", "gender_specific": "M" },
    { "leave_type_id": 9, "type_name": "喪假", "gender_specific": null },
    { "leave_type_id": 10, "type_name": "公假", "gender_specific": null }
    // ⚠️ 不包含「產假、產檢假、生理假」（限女性）
  ]
}
```

### 4. 登記生活事件
```
POST /api/v1/leave/life-events
```

**請求：**
```json
{
  "event_type": "結婚",
  "event_date": "2025-12-01",
  "description": "婚禮日期"
}
```

### 5. 手動觸發Cron Job（管理員專用）⭐ 新增
```
POST /api/v1/admin/cron/execute
權限：管理員
```

**請求：**
```json
{
  "job_name": "annual_leave_update",
  "target_date": "2026-01-01"
}
```

**回應：**
```json
{
  "success": true,
  "data": {
    "job_name": "annual_leave_update",
    "execution_date": "2026-01-01",
    "status": "success",
    "affected_users": 5,
    "execution_duration_ms": 234
  }
}
```

### 6. 查詢Cron Job執行歷史（管理員專用）⭐ 新增
```
GET /api/v1/admin/cron/history?job_name=annual_leave_update
權限：管理員
```

**回應：**
```json
{
  "success": true,
  "data": [
    {
      "execution_id": 1,
      "job_name": "annual_leave_update",
      "execution_date": "2026-01-01",
      "status": "success",
      "affected_users": 5,
      "executed_at": "2026-01-01 00:00:15"
    },
    {
      "execution_id": 2,
      "job_name": "annual_leave_update",
      "execution_date": "2025-01-01",
      "status": "success",
      "affected_users": 4,
      "executed_at": "2025-01-01 00:00:08"
    }
  ]
}
```

---

## 🔧 後端實現

### LeaveService
```typescript
class LeaveService {
  async applyLeave(data, user) {
    // 0. 驗證性別限制 ⭐ 新增
    await this.validateGenderRestriction(user.user_id, data.leave_type_id);
    
    // 1. 驗證日期
    if (data.end_date < data.start_date) {
      throw new ValidationError('結束日期不能早於開始日期');
    }
    
    // 2. 檢查餘額
    const balance = await this.calculateBalance(user.user_id, data.leave_type_id);
    if (balance.remaining < data.days) {
      throw new ValidationError(`假期餘額不足，剩餘${balance.remaining}天`);
    }
    
    // 3. 檢查重疊
    const overlap = await this.checkOverlap(user.user_id, data.start_date, data.end_date);
    if (overlap) {
      throw new ConflictError('與現有假期重疊');
    }
    
    // 4. ⭐ 生理假特殊處理：判斷是否併入病假
    let countsAsSickLeave = false;
    
    if (data.leave_type_id === 8) {  // 生理假
      const currentYear = new Date(data.start_date).getFullYear();
      
      // 查詢今年已請生理假天數
      const menstrualUsed = await this.db.prepare(`
        SELECT COALESCE(SUM(days), 0) as total
        FROM LeaveApplications
        WHERE user_id = ?
          AND leave_type_id = 8
          AND strftime('%Y', start_date) = ?
          AND is_deleted = 0
      `).bind(user.user_id, currentYear.toString()).first();
      
      const totalMenstrualDays = (menstrualUsed?.total || 0) + data.days;
      
      // 判斷是否超過3日
      if (totalMenstrualDays > 3) {
        countsAsSickLeave = true;  // 超過部分併入病假
        
        // 額外檢查：病假額度是否足夠
        const sickBalance = await this.calculateBalance(user.user_id, 2);  // 2=病假
        const overDays = totalMenstrualDays - 3;  // 超過的天數
        
        if (sickBalance.remaining < overDays) {
          throw new ValidationError(
            `生理假超過3日的部分會併入病假計算，但您的病假餘額不足。` +
            `超過天數：${overDays}天，病假餘額：${sickBalance.remaining}天`
          );
        }
      }
    }
    
    // 5. 創建申請
    return await this.repository.create({
      ...data,
      user_id: user.user_id,
      counts_as_sick_leave: countsAsSickLeave  // ⭐ 記錄是否併入病假
    });
  }
  
  async calculateBalance(userId, leaveTypeId, year) {
    const leaveType = await this.getLeaveType(leaveTypeId);
    
    let entitled = 0;
    
    if (leaveType.type_name === '特休') {
      // 根據年資計算
      const user = await this.userRepo.findById(userId);
      const months = this.calculateMonths(user.start_date, new Date());
      const rule = await this.getAnnualLeaveRule(months);
      entitled = rule.days;
    } else if (leaveType.annual_quota) {
      // 固定額度
      entitled = leaveType.annual_quota;
    } else {
      // 事件給假（查詢生活事件）
      entitled = await this.calculateEventLeave(userId, leaveTypeId);
    }
    
    // 計算已用
    const used = await this.repository.sumUsedDays(userId, leaveTypeId, year);
    
    return {
      entitled_days: entitled,
      used_days: used,
      remaining_days: entitled - used
    };
  }
  
  async registerLifeEvent(eventType, eventDate, user) {
    // 1. 查詢對應規則
    const rule = await this.getOtherLeaveRule(eventType);
    if (!rule) {
      throw new NotFoundError('找不到對應的假期規則');
    }
    
    // 2. 檢查是否已登記過（避免重複，如：同一年結兩次婚）
    const existingGrant = await this.db.prepare(`
      SELECT * FROM LifeEventLeaveGrants
      WHERE user_id = ?
        AND event_type = ?
        AND event_date = ?
        AND is_deleted = 0
    `).bind(user.user_id, eventType, eventDate).first();
    
    if (existingGrant) {
      throw new ConflictError('此生活事件已登記過');
    }
    
    // 3. 計算有效期
    const validFrom = eventDate;
    const validUntil = this.addDays(eventDate, rule.validity_days);
    
    // 4. 創建假期額度記錄 ⭐
    const result = await this.db.prepare(`
      INSERT INTO LifeEventLeaveGrants (
        user_id, leave_type_id, event_type, event_date,
        total_days, remaining_days, valid_from, valid_until
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `).bind(
      user.user_id,
      rule.leave_type_id,
      eventType,
      eventDate,
      rule.days,
      rule.days,  // 初始 remaining = total
      validFrom,
      validUntil
    ).run();
    
    return {
      grant_id: result.meta.last_row_id,
      leave_type: rule.leave_type_name,
      event_type: eventType,
      event_date: eventDate,
      total_days: rule.days,
      remaining_days: rule.days,
      valid_from: validFrom,
      valid_until: validUntil
    };
  }
  
  /**
   * 申請生活事件假期時的餘額驗證 ⭐
   */
  async applyLifeEventLeave(data, user) {
    // 1. 查詢可用的生活事件假期額度
    const grants = await this.db.prepare(`
      SELECT * FROM LifeEventLeaveGrants
      WHERE user_id = ?
        AND leave_type_id = ?
        AND remaining_days > 0
        AND valid_until >= ?
        AND is_deleted = 0
      ORDER BY event_date ASC
    `).bind(user.user_id, data.leave_type_id, data.start_date).all();
    
    if (grants.results.length === 0) {
      throw new ValidationError('沒有可用的生活事件假期額度，或額度已過期');
    }
    
    // 2. 計算總可用天數
    const totalAvailable = grants.results.reduce((sum, g) => sum + g.remaining_days, 0);
    
    if (totalAvailable < data.days) {
      throw new ValidationError(
        `假期額度不足。可用：${totalAvailable}天，申請：${data.days}天`
      );
    }
    
    // 3. 驗證申請日期在有效期內
    const grant = grants.results[0];  // 使用最早的額度（FIFO）
    if (data.start_date < grant.valid_from || data.end_date > grant.valid_until) {
      throw new ValidationError(
        `請假日期必須在有效期內（${grant.valid_from} ~ ${grant.valid_until}）`
      );
    }
    
    // 4. 創建請假申請
    const application = await this.repository.create({
      ...data,
      user_id: user.user_id,
      event_type: grant.event_type
    });
    
    // 5. 扣除額度（優先使用最早的額度，FIFO）
    let remainingToDeduct = data.days;
    
    for (const grant of grants.results) {
      if (remainingToDeduct <= 0) break;
      
      const deductFromThis = Math.min(grant.remaining_days, remainingToDeduct);
      
      await this.db.prepare(`
        UPDATE LifeEventLeaveGrants
        SET used_days = used_days + ?,
            remaining_days = remaining_days - ?
        WHERE grant_id = ?
      `).bind(deductFromThis, deductFromThis, grant.grant_id).run();
      
      remainingToDeduct -= deductFromThis;
    }
    
    return application;
  }
  
  /**
   * 範例：
   * 
   * 1. 員工B登記結婚（2025-12-15）
   *    → 創建 grant：8天婚假，有效期至 2026-12-14
   * 
   * 2. 12月請5天婚假（2025-12-16 ~ 2025-12-20）
   *    → used_days = 5, remaining_days = 3
   * 
   * 3. 2026年6月再請3天婚假（2026-06-10 ~ 2026-06-12）
   *    → 驗證：2026-06-12 < 2026-12-14 ✅ 有效
   *    → used_days = 8, remaining_days = 0
   * 
   * 4. 2026年12月想再請婚假
   *    → 查詢：remaining_days = 0 且 valid_until 已過
   *    → 拋出錯誤：「沒有可用的生活事件假期額度」
   */
}
```

---

## ✅ 業務規則

### 假期餘額計算

#### 特休（依年資，⚠️ 累積制）

**重要說明：** 特休採累積制，去年剩餘特休會累積到今年，不會歸零。

```typescript
/**
 * 計算特休餘額（含累積）
 */
async function calculateAnnualLeaveBalance(userId: number, year: number) {
  // 1. 查詢員工到職日
  const user = await db.prepare(
    'SELECT join_date FROM Users WHERE user_id = ?'
  ).bind(userId).first();
  
  // 2. 計算年資（月數）
  const joinDate = new Date(user.join_date);
  const currentDate = new Date(year, 11, 31); // 當年度12月31日
  const months = calculateMonths(joinDate, currentDate);
  
  // 3. 查詢當年度應得特休
  const rule = await db.prepare(`
    SELECT days FROM AnnualLeaveRules
    WHERE min_months <= ? AND max_months > ?
  `).bind(months, months).first();
  
  const entitledDays = rule?.days || 0;
  
  // 4. 查詢去年剩餘特休（累積）
  const lastYearBalance = await db.prepare(`
    SELECT remaining_days FROM AnnualLeaveBalance
    WHERE user_id = ? AND year = ?
  `).bind(userId, year - 1).first();
  
  const carriedOverDays = lastYearBalance?.remaining_days || 0;
  
  // 5. 查詢今年已使用天數
  const usedDays = await db.prepare(`
    SELECT SUM(days) as total FROM LeaveApplications
    WHERE user_id = ?
      AND leave_type_id = 1  -- 特休
      AND strftime('%Y', start_date) = ?
  `).bind(userId, year.toString()).first();
  
  const used = usedDays?.total || 0;
  
  // 6. 計算剩餘特休
  const remaining = entitledDays + carriedOverDays - used;
  
  return {
    entitled_days: entitledDays,      // 當年新增
    carried_over_days: carriedOverDays, // 去年累積
    used_days: used,
    remaining_days: remaining,
    total_available: entitledDays + carriedOverDays  // 總可用
  };
}

/**
 * 範例：
 * 
 * 員工 A：
 * - 到職日：2024-01-15
 * - 查詢年度：2025
 * - 工作年資：1年11個月 = 23個月
 * - 當年新增特休：7天（1-2年）
 * - 去年（2024）剩餘：2天
 * - 今年總可用：7 + 2 = 9天 ✅ 累積制
 * - 已使用：3天
 * - 剩餘：6天
 */
```

**年初自動處理（每年1月1日）：**
```typescript
/**
 * Cron Job: 每年 1/1 00:00 執行
 * 配置檔：wrangler.toml
 * 
 * [triggers]
 * crons = ["0 0 1 1 *"]  # 每年1月1日 00:00
 */
async function annualLeaveYearEndProcessing(targetDate?: string) {
  const startTime = Date.now();
  const executionDate = targetDate || new Date().toISOString().split('T')[0];
  const currentYear = parseInt(executionDate.substring(0, 4));
  const lastYear = currentYear - 1;
  
  // ⚠️ 冪等性檢查：防止重複執行
  const existingExecution = await db.prepare(`
    SELECT * FROM CronJobExecutions
    WHERE job_name = 'annual_leave_update'
      AND execution_date = ?
      AND status = 'success'
  `).bind(executionDate).first();
  
  if (existingExecution) {
    console.log(`特休更新已執行過（${executionDate}），跳過`);
    return {
      skipped: true,
      message: '該日期已執行過',
      previous_execution: existingExecution
    };
  }
  
  try {
    // 查詢所有員工
    const users = await db.prepare(`
      SELECT user_id, join_date FROM Users WHERE is_deleted = 0
    `).all();
    
    let affectedUsers = 0;
    
    for (const user of users.results) {
      // 計算當年度應得特休
      const months = calculateMonths(user.join_date, new Date(currentYear, 11, 31));
      const rule = await getAnnualLeaveRule(months);
      
      if (!rule) {
        console.warn(`員工 ${user.user_id} 年資不足，跳過`);
        continue;
      }
      
      // 查詢去年剩餘特休
      const lastYearBalance = await db.prepare(`
        SELECT remaining_days FROM AnnualLeaveBalance
        WHERE user_id = ? AND year = ?
      `).bind(user.user_id, lastYear).first();
      
      const carriedOver = lastYearBalance?.remaining_days || 0;
      
      // 創建今年度特休記錄
      await db.prepare(`
        INSERT INTO AnnualLeaveBalance (
          user_id, year, entitled_days, carried_over_days, remaining_days
        ) VALUES (?, ?, ?, ?, ?)
      `).bind(
        user.user_id,
        currentYear,
        rule.days,
        carriedOver,  // ✅ 去年剩餘累積到今年
        rule.days + carriedOver
      ).run();
      
      affectedUsers++;
    }
    
    // 記錄執行成功
    const duration = Date.now() - startTime;
    await db.prepare(`
      INSERT INTO CronJobExecutions (
        job_name, execution_date, status, affected_users, execution_duration_ms
      ) VALUES (?, ?, 'success', ?, ?)
    `).bind('annual_leave_update', executionDate, affectedUsers, duration).run();
    
    console.log(`特休更新完成：${affectedUsers} 位員工，耗時 ${duration}ms`);
    
    return {
      success: true,
      affected_users: affectedUsers,
      execution_duration_ms: duration
    };
    
  } catch (error) {
    // 記錄執行失敗
    const duration = Date.now() - startTime;
    await db.prepare(`
      INSERT INTO CronJobExecutions (
        job_name, execution_date, status, error_message, execution_duration_ms
      ) VALUES (?, ?, 'failed', ?, ?)
    `).bind('annual_leave_update', executionDate, error.message, duration).run();
    
    // ⚠️ 通知管理員（儀表板顯示）
    await sendAdminNotification({
      type: 'cron_failed',
      message: `特休年初更新失敗：${error.message}`,
      action_url: '/admin/cron/history?job_name=annual_leave_update'
    });
    
    console.error('特休更新失敗:', error);
    throw error;
  }
}
```

#### 病假/事假（固定額度）
```
病假：30天/年
事假：14天/年
每年1月1日重置

⚠️ 生理假併入病假的特殊處理：
- 全年生理假前 3 日：不併入病假計算
- 全年生理假第 4 日起：併入病假計算
```

**生理假併入病假的計算邏輯：**
```typescript
/**
 * 計算病假餘額（含生理假併入）
 */
async function calculateSickLeaveBalance(userId: number, year: number) {
  // 1. 查詢病假使用天數
  const sickLeaveUsed = await db.prepare(`
    SELECT COALESCE(SUM(days), 0) as total
    FROM LeaveApplications
    WHERE user_id = ?
      AND leave_type_id = 2  -- 病假
      AND strftime('%Y', start_date) = ?
      AND is_deleted = 0
  `).bind(userId, year.toString()).first();
  
  // 2. 查詢生理假併入病假的天數
  const menstrualAsSickLeave = await db.prepare(`
    SELECT COALESCE(SUM(days), 0) as total
    FROM LeaveApplications
    WHERE user_id = ?
      AND leave_type_id = 8  -- 生理假
      AND counts_as_sick_leave = 1  -- ⭐ 併入病假的部分
      AND strftime('%Y', start_date) = ?
      AND is_deleted = 0
  `).bind(userId, year.toString()).first();
  
  const totalUsed = (sickLeaveUsed?.total || 0) + (menstrualAsSickLeave?.total || 0);
  
  return {
    entitled: 30,
    used: totalUsed,
    remaining: 30 - totalUsed,
    breakdown: {
      sick_leave_used: sickLeaveUsed?.total || 0,
      menstrual_as_sick_leave: menstrualAsSickLeave?.total || 0
    }
  };
}

/**
 * 範例：
 * 
 * 女性員工今年請假記錄：
 * - 病假：2天
 * - 生理假（前3日）：3天（counts_as_sick_leave = 0）
 * - 生理假（第4日）：1天（counts_as_sick_leave = 1）⭐
 * 
 * 病假餘額計算：
 * - 病假使用：2天
 * - 生理假併入：1天
 * - 總使用：3天
 * - 剩餘：30 - 3 = 27天
 */
```

#### 婚假/喪假（生活事件）
```
登記「結婚」→ 產生婚假8天
登記「父母過世」→ 產生喪假8天
有效期限：事件後1年

⚠️ 使用 LifeEventLeaveGrants 表追蹤：
- 記錄總額度（8天）
- 記錄已使用（如：5天）
- 記錄剩餘（如：3天）
- 記錄有效期（事件日 ~ 事件日+365天）
- 支援分次使用（FIFO，優先使用最早的額度）
```

**生活事件假期餘額查詢邏輯：**
```typescript
/**
 * 查詢生活事件假期餘額
 */
async function getLifeEventLeaveBalance(userId: number, leaveTypeId: number) {
  const grants = await db.prepare(`
    SELECT 
      grant_id,
      event_type,
      event_date,
      total_days,
      used_days,
      remaining_days,
      valid_from,
      valid_until,
      CASE 
        WHEN valid_until < date('now') THEN 'expired'
        WHEN remaining_days <= 0 THEN 'used_up'
        ELSE 'active'
      END as status
    FROM LifeEventLeaveGrants
    WHERE user_id = ?
      AND leave_type_id = ?
      AND is_deleted = 0
    ORDER BY event_date ASC
  `).bind(userId, leaveTypeId).all();
  
  // 只計算有效且未用完的額度
  const activeGrants = grants.results.filter(g => g.status === 'active');
  const totalRemaining = activeGrants.reduce((sum, g) => sum + g.remaining_days, 0);
  
  return {
    total_remaining: totalRemaining,
    grants: grants.results,
    active_grants: activeGrants
  };
}

/**
 * 範例輸出：
 * 
 * 員工B查詢婚假餘額：
 * {
 *   "total_remaining": 3,
 *   "grants": [
 *     {
 *       "grant_id": 1,
 *       "event_type": "結婚",
 *       "event_date": "2025-12-15",
 *       "total_days": 8,
 *       "used_days": 5,
 *       "remaining_days": 3,
 *       "valid_from": "2025-12-15",
 *       "valid_until": "2026-12-14",
 *       "status": "active"
 *     }
 *   ],
 *   "active_grants": [...]
 * }
 */
```

### 驗證規則
1. 日期區間有效（end_date >= start_date）
2. 假期餘額足夠
3. 無重疊假期（同一天不能重複請假）
4. 假別類型已啟用
5. **性別限制檢查**（重要！）

#### 性別限制驗證

```typescript
/**
 * 驗證假別是否符合性別限制
 * ⚠️ 此函數已整合到 LeaveService.applyLeave() 中，作為第0步驗證
 */
async function validateGenderRestriction(userId: number, leaveTypeId: number): boolean {
  // 1. 查詢員工性別
  const user = await db.prepare(`
    SELECT gender FROM Users WHERE user_id = ?
  `).bind(userId).first();
  
  if (!user) {
    throw new NotFoundError('員工不存在');
  }
  
  // 2. 查詢假別性別限制
  const leaveType = await db.prepare(`
    SELECT gender_specific, type_name FROM LeaveTypes WHERE leave_type_id = ?
  `).bind(leaveTypeId).first();
  
  if (!leaveType) {
    throw new NotFoundError('假別不存在');
  }
  
  // 3. 檢查性別限制
  if (leaveType.gender_specific) {
    if (leaveType.gender_specific === 'F' && user.gender !== '女') {
      throw new ValidationError(
        `${leaveType.type_name}僅限女性員工申請`,
        'GENDER_RESTRICTION_VIOLATED'
      );
    }
    if (leaveType.gender_specific === 'M' && user.gender !== '男') {
      throw new ValidationError(
        `${leaveType.type_name}僅限男性員工申請`,
        'GENDER_RESTRICTION_VIOLATED'
      );
    }
  }
  
  return true;
}

/**
 * 範例：
 * 
 * 情境 1：男性員工申請產假
 * - user.gender = '男'
 * - leaveType.gender_specific = 'F'
 * - 結果：❌ 拋出錯誤「產假僅限女性員工申請」
 * 
 * 情境 2：女性員工申請陪產檢及陪產假
 * - user.gender = '女'
 * - leaveType.gender_specific = 'M'
 * - 結果：❌ 拋出錯誤「陪產檢及陪產假僅限男性員工申請」
 * 
 * 情境 3：男性員工申請特休
 * - user.gender = '男'
 * - leaveType.gender_specific = NULL
 * - 結果：✅ 通過（特休無性別限制）
 */
```

#### 前端假別選項過濾（API實作）

**API端點：** `GET /api/v1/leave/available-types?user_id=1`

```typescript
/**
 * 根據員工性別過濾可申請的假別
 * ⚠️ 前端下拉選單應調用此API，不要在前端自行過濾
 */
async function getAvailableLeaveTypes(userId: number) {
  // 1. 查詢員工性別
  const user = await db.prepare(`
    SELECT gender FROM Users WHERE user_id = ?
  `).bind(userId).first();
  
  if (!user) {
    throw new NotFoundError('員工不存在');
  }
  
  // 2. 查詢符合性別的假別
  const leaveTypes = await db.prepare(`
    SELECT 
      leave_type_id,
      type_name,
      gender_specific,
      annual_quota,
      is_paid,
      affects_attendance
    FROM LeaveTypes
    WHERE is_enabled = 1
      AND (gender_specific IS NULL 
        OR gender_specific = ?)
    ORDER BY leave_type_id
  `).bind(user.gender === '女' ? 'F' : user.gender === '男' ? 'M' : NULL).all();
  
  return leaveTypes.results;
}

/**
 * 範例輸出：
 * 
 * 女性員工看到的假別選項：
 * - 特休 ✅
 * - 病假 ✅
 * - 事假 ✅
 * - 婚假 ✅
 * - 產假 ✅（僅女性）
 * - 產檢假 ✅（僅女性）
 * - 生理假 ✅（僅女性）
 * - 喪假 ✅
 * - 公假 ✅
 * - 家庭照顧假 ✅
 * - 補休 ✅
 * - 颱風假 ✅
 * （不會顯示陪產檢及陪產假）
 * 
 * 男性員工看到的假別選項：
 * - 特休 ✅
 * - 病假 ✅
 * - 事假 ✅
 * - 婚假 ✅
 * - 陪產檢及陪產假 ✅（僅男性）
 * - 喪假 ✅
 * - 公假 ✅
 * - 家庭照顧假 ✅
 * - 補休 ✅
 * - 颱風假 ✅
 * （不會顯示產假、產檢假、生理假）
 */
```

---

## 🎨 前端組件範例

### LeaveApplicationForm.vue（假期申請表單）

```vue
<template>
  <Modal :show="show" title="申請假期">
    <form @submit.prevent="submitLeave">
      <!-- 假別選擇（自動依性別過濾）⭐ -->
      <FormGroup label="假別">
        <select v-model="form.leave_type_id" required>
          <option value="">請選擇</option>
          <option 
            v-for="type in availableLeaveTypes" 
            :key="type.leave_type_id"
            :value="type.leave_type_id"
          >
            {{ type.type_name }}
            <span v-if="type.gender_specific === 'F'">（限女性）</span>
            <span v-if="type.gender_specific === 'M'">（限男性）</span>
          </option>
        </select>
      </FormGroup>
      
      <!-- 日期選擇 -->
      <FormGroup label="開始日期">
        <input type="date" v-model="form.start_date" required />
      </FormGroup>
      
      <FormGroup label="結束日期">
        <input type="date" v-model="form.end_date" required />
      </FormGroup>
      
      <!-- 原因 -->
      <FormGroup label="原因">
        <textarea v-model="form.reason"></textarea>
      </FormGroup>
      
      <StyledButton type="submit">送出申請</StyledButton>
    </form>
  </Modal>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import { getAvailableLeaveTypes, applyLeave } from '@/api/leave';
import { useAuth } from '@/composables/useAuth';

const { user } = useAuth();
const availableLeaveTypes = ref([]);
const form = ref({
  leave_type_id: '',
  start_date: '',
  end_date: '',
  reason: ''
});

// ⭐ 載入時自動取得該員工可申請的假別（已依性別過濾）
onMounted(async () => {
  const response = await getAvailableLeaveTypes(user.value.user_id);
  availableLeaveTypes.value = response.data;
  
  // 男性員工看不到產假、產檢假、生理假
  // 女性員工看不到陪產檢及陪產假
});

async function submitLeave() {
  try {
    await applyLeave(form.value);
    alert('假期申請成功');
  } catch (error) {
    // 如果後端也攔截到性別限制錯誤
    if (error.code === 'GENDER_RESTRICTION_VIOLATED') {
      alert(error.message);  // 顯示：「產假僅限女性員工申請」
    } else {
      alert('申請失敗：' + error.message);
    }
  }
}
</script>
```

### API Service（前端調用）

```typescript
// src/api/leave.ts

/**
 * 查詢可申請的假別（依性別自動過濾）
 */
export async function getAvailableLeaveTypes(userId: number) {
  const response = await fetch(`/api/v1/leave/available-types?user_id=${userId}`, {
    headers: { 'Authorization': `Bearer ${getToken()}` }
  });
  return await response.json();
}

/**
 * 申請假期
 */
export async function applyLeave(data: LeaveApplicationData) {
  const response = await fetch('/api/v1/leave/applications', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${getToken()}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(data)
  });
  
  const result = await response.json();
  
  if (!result.success) {
    throw { code: result.error.code, message: result.error.message };
  }
  
  return result;
}
```

---

**這個文檔包含假期管理的所有技術細節。**

