# 薪資管理 - 完整規格

**模組名稱：** 薪資管理系統  
**版本：** 3.2  
**更新日期：** 2025-10-28  
**適用對象：** 月薪制員工

---

## 📋 功能概述

### 核心功能

1. **靈活薪資結構**
   - 可自由新增/修改薪資項目（全勤、津貼、加給等）
   - 每位員工可設定不同的薪資項目組合
   
2. **月薪制計算**
   - 符合台灣勞基法（月薪 ÷ 240小時 = 時薪基準）
   - 自動計算加班費（平日/休息日/國定假日不同倍率）
   
3. **全勤機制**
   - 補休不影響全勤
   - 病假/事假扣除全勤
   
4. **薪資報表**
   - 月度薪資明細
   - 加班費統計
   - 成本分析

---

## 💾 資料表設計

### 1. Users 表擴充

```sql
-- 新增基本薪資資訊到 Users 表
ALTER TABLE Users ADD COLUMN base_salary REAL NOT NULL DEFAULT 0;  -- 底薪（月薪）
ALTER TABLE Users ADD COLUMN join_date TEXT;  -- 到職日期
ALTER TABLE Users ADD COLUMN comp_hours_current_month REAL DEFAULT 0;  -- 本月補休時數
```

**說明：**
- `base_salary`：月薪底薪（如：35,000元）
- `join_date`：用於計算年資、特休
- 其他薪資項目（全勤、津貼）使用靈活配置系統

### 2. SalaryItemTypes（薪資項目類型）⭐

**設計理由：** 每家公司的薪資項目不同，需要能自由新增/修改項目

```sql
CREATE TABLE SalaryItemTypes (
  item_type_id INTEGER PRIMARY KEY AUTOINCREMENT,
  item_code TEXT UNIQUE NOT NULL,  -- 項目代碼（如：ATTENDANCE_BONUS）
  item_name TEXT NOT NULL,  -- 項目名稱（如：全勤獎金）
  category TEXT NOT NULL,  -- 類別：'allowance'（津貼）, 'bonus'（獎金）, 'deduction'（扣款）
  is_taxable BOOLEAN DEFAULT 1,  -- 是否計入課稅
  is_fixed BOOLEAN DEFAULT 1,  -- 金額是否固定（1=每月同金額，0=金額會變動）
  is_regular_payment BOOLEAN DEFAULT 1,  -- ⭐ 是否為經常性給與（1=每月發放，0=偶爾發放如年終）
  affects_labor_insurance BOOLEAN DEFAULT 1,  -- 是否影響勞健保
  affects_attendance BOOLEAN DEFAULT 0,  -- 是否影響全勤判定
  calculation_formula TEXT,  -- 計算公式（變動項目用）
  display_order INTEGER DEFAULT 0,  -- 顯示順序
  is_active BOOLEAN DEFAULT 1,  -- 是否啟用
  created_at TEXT DEFAULT (datetime('now')),
  
  CHECK (category IN ('allowance', 'bonus', 'deduction'))
);

CREATE INDEX idx_salary_item_types_active ON SalaryItemTypes(is_active);
CREATE INDEX idx_salary_item_types_order ON SalaryItemTypes(display_order);
CREATE INDEX idx_salary_item_types_regular ON SalaryItemTypes(is_regular_payment);

-- 預設項目範例
INSERT INTO SalaryItemTypes (item_code, item_name, category, is_taxable, is_fixed, is_regular_payment) VALUES
('ATTENDANCE_BONUS', '全勤獎金', 'bonus', 1, 1, 1),        -- 固定金額，計入時薪
('TRANSPORT', '交通津貼', 'allowance', 0, 1, 1),           -- 固定金額，計入時薪
('MEAL', '伙食津貼', 'allowance', 0, 1, 1),                -- 固定金額，計入時薪
('POSITION', '職務加給', 'allowance', 1, 1, 1),            -- 固定金額，計入時薪
('PHONE', '電話津貼', 'allowance', 0, 1, 1),               -- 固定金額，計入時薪
('PARKING', '停車津貼', 'allowance', 0, 1, 1),             -- 固定金額，計入時薪
('PERFORMANCE', '績效獎金', 'bonus', 1, 0, 1),             -- ⭐ 金額浮動，但計入時薪（影響成本分析）
('YEAR_END', '年終獎金', 'bonus', 1, 0, 0);                -- 金額浮動，不計入時薪（年底一次）

/**
 * ⚠️ 績效獎金設計說明（is_regular_payment = 1，金額浮動）：
 * 
 * 為什麼計入時薪？
 * - 績效獎金是每月發放的獎金，屬於「經常性給與」
 * - 影響真實的人力成本（客戶成本分析需要準確反映）
 * - 雖然金額每月不同，但應計入時薪以反映真實成本
 * 
 * 如何處理金額浮動？
 * - 管理員每月可更新 EmployeeSalaryItems 表中的 amount
 * - 更新後，該月的時薪會自動重新計算
 * - 客戶成本分析會使用「該月實際的時薪成本率」
 * 
 * 前端操作流程：
 * 1. 員工薪資設定頁面：設定績效獎金預設值（如：2000元）
 * 2. 每月初（或月底）：管理員批次更新績效獎金金額
 * 3. 系統使用更新後的金額計算該月時薪
 * 4. 客戶成本分析反映真實人力成本
 */
```

**欄位說明：**
```
is_fixed（金額固定性）：
  1 = 每月金額相同（如：交通津貼 1,000元）
  0 = 每月金額會變（如：績效獎金 2,000~5,000元浮動）

is_regular_payment（經常性給與）：⭐ 影響時薪計算
  1 = 每月都發放 → 計入時薪基準（勞基法要求）
  0 = 偶爾發放（如：年終獎金、三節獎金）→ 不計入時薪

範例：
- 績效獎金：is_fixed=0, is_regular_payment=1 
  → 雖然金額浮動，但每月都發，所以要計入時薪
  
- 年終獎金：is_fixed=0, is_regular_payment=0
  → 金額浮動，且只在年底發，不計入時薪
```

### 3. EmployeeSalaryItems（員工薪資項目）

```sql
CREATE TABLE EmployeeSalaryItems (
  employee_item_id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  item_type_id INTEGER NOT NULL,
  amount REAL NOT NULL,  -- 金額
  effective_date TEXT NOT NULL,  -- 生效日期（YYYY-MM-01）
  expiry_date TEXT,  -- 失效日期（YYYY-MM-末日，null=永久有效）
  notes TEXT,
  is_active BOOLEAN DEFAULT 1,
  created_at TEXT DEFAULT (datetime('now')),
  updated_at TEXT DEFAULT (datetime('now')),
  
  FOREIGN KEY (user_id) REFERENCES Users(user_id),
  FOREIGN KEY (item_type_id) REFERENCES SalaryItemTypes(item_type_id)
);

CREATE INDEX idx_employee_salary_items_user ON EmployeeSalaryItems(user_id);
CREATE INDEX idx_employee_salary_items_active ON EmployeeSalaryItems(is_active);
CREATE INDEX idx_employee_salary_items_date ON EmployeeSalaryItems(effective_date, expiry_date);  -- ⭐ 月份查詢專用

/**
 * ⚠️ 月度獨立調整設計（績效獎金等浮動項目）：
 * 
 * 設計理念：
 * - 調整只影響指定月份，不影響其他月份
 * - 每月可以有不同的金額
 * - 未調整的月份使用「永久有效」的預設值
 * 
 * 資料範例：
 * 
 * 員工A的績效獎金設定：
 * 1. employee_item_id=1, amount=2000, effective_date='2025-01-01', expiry_date=NULL
 *    → 預設值：從2025-01-01起永久有效，金額2000元
 * 
 * 2. employee_item_id=5, amount=3500, effective_date='2025-11-01', expiry_date='2025-11-30'
 *    → 11月調整：僅11月用3500元
 * 
 * 3. employee_item_id=8, amount=4000, effective_date='2025-12-01', expiry_date='2025-12-31'
 *    → 12月調整：僅12月用4000元
 * 
 * 查詢邏輯：
 * - 查詢11月薪資時：找到 employee_item_id=5（3500元）→ 優先使用
 * - 查詢10月薪資時：找到 employee_item_id=1（2000元）→ 使用預設值
 * - 查詢12月薪資時：找到 employee_item_id=8（4000元）→ 使用12月專屬值
 * 
 * 優先順序：
 * 1. 月份專屬設定（有 expiry_date 的）
 * 2. 預設值（expiry_date = NULL 的）
 */

-- 員工薪資項目範例
-- 員工A：全勤2000、交通1000、伙食1800
INSERT INTO EmployeeSalaryItems (user_id, item_type_id, amount, effective_date) VALUES
(1, 1, 2000, '2025-01-01'),  -- 全勤獎金
(1, 2, 1000, '2025-01-01'),  -- 交通津貼
(1, 3, 1800, '2025-01-01');  -- 伙食津貼
```

### 4. MonthlyPayroll（月度薪資表）

```sql
CREATE TABLE MonthlyPayroll (
  payroll_id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  year INTEGER NOT NULL,
  month INTEGER NOT NULL,
  
  -- 薪資組成（動態從 EmployeeSalaryItems 計算）
  base_salary REAL NOT NULL,  -- 底薪
  total_allowances REAL DEFAULT 0,  -- 津貼合計
  total_bonuses REAL DEFAULT 0,  -- 獎金合計
  
  -- 加班費（依勞基法計算）
  overtime_weekday_2h REAL DEFAULT 0,  -- 平日加班前2小時費用（1.34倍）
  overtime_weekday_beyond REAL DEFAULT 0,  -- 平日加班第3小時起（1.67倍）
  overtime_restday_2h REAL DEFAULT 0,  -- 休息日前2小時（1.34倍）
  overtime_restday_beyond REAL DEFAULT 0,  -- 休息日第3小時起（1.67倍）
  overtime_holiday REAL DEFAULT 0,  -- 國定假日/例假日（2.0倍）
  
  -- 扣款項目
  total_deductions REAL DEFAULT 0,  -- 總扣款
  
  -- 統計資訊
  total_work_hours REAL DEFAULT 0,  -- 總工時
  total_overtime_hours REAL DEFAULT 0,  -- 加班時數
  total_weighted_hours REAL DEFAULT 0,  -- 加權工時總計
  has_full_attendance BOOLEAN DEFAULT 1,  -- 是否全勤
  
  -- 總薪資
  gross_salary REAL NOT NULL,  -- 應發薪資（含所有加項）
  net_salary REAL NOT NULL,  -- 實發薪資
  
  -- 備註
  notes TEXT,
  created_at TEXT DEFAULT (datetime('now')),
  updated_at TEXT DEFAULT (datetime('now')),
  
  FOREIGN KEY (user_id) REFERENCES Users(user_id),
  UNIQUE(user_id, year, month)  -- 每人每月只有一筆薪資記錄
);

CREATE INDEX idx_payroll_user ON MonthlyPayroll(user_id);
CREATE INDEX idx_payroll_date ON MonthlyPayroll(year, month);
```

### 5. OvertimeRecords（加班記錄明細）

```sql
CREATE TABLE OvertimeRecords (
  overtime_id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  work_date TEXT NOT NULL,
  overtime_type TEXT NOT NULL,  -- 'weekday_2h', 'weekday_beyond', 'restday_2h', 'restday_beyond', 'holiday'
  hours REAL NOT NULL,
  rate_multiplier REAL NOT NULL,  -- 費率倍數（1.34, 1.67, 2.0）
  hourly_base REAL NOT NULL,  -- 時薪基準（base_salary / 240）
  overtime_pay REAL NOT NULL,  -- 加班費金額
  is_compensatory_leave BOOLEAN DEFAULT 0,  -- 是否選擇補休（1=補休, 0=加班費）
  payroll_id INTEGER,  -- 關聯到薪資記錄
  created_at TEXT DEFAULT (datetime('now')),
  
  FOREIGN KEY (user_id) REFERENCES Users(user_id),
  FOREIGN KEY (payroll_id) REFERENCES MonthlyPayroll(payroll_id)
);

CREATE INDEX idx_overtime_user_date ON OvertimeRecords(user_id, work_date);
CREATE INDEX idx_overtime_payroll ON OvertimeRecords(payroll_id);
```

### 6. YearEndBonus（年終獎金）⭐ 新增

**設計理由：** 年終獎金通常在次年1月發放，但歸屬上一年度，需獨立管理

```sql
CREATE TABLE YearEndBonus (
  bonus_id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  attribution_year INTEGER NOT NULL,     -- 歸屬年度（如：2025）
  amount REAL NOT NULL,                  -- 年終獎金金額
  payment_year INTEGER,                  -- 實際發放年度（如：2026）
  payment_month INTEGER,                 -- 實際發放月份（如：1）
  payment_date TEXT,                     -- 實際發放日期（如：2026-01-15）
  decision_date TEXT,                    -- 決定日期（如：2025-12-31）
  notes TEXT,
  recorded_by INTEGER NOT NULL,
  created_at TEXT DEFAULT (datetime('now')),
  updated_at TEXT DEFAULT (datetime('now')),
  is_deleted BOOLEAN DEFAULT 0,
  
  FOREIGN KEY (user_id) REFERENCES Users(user_id),
  FOREIGN KEY (recorded_by) REFERENCES Users(user_id),
  UNIQUE(user_id, attribution_year)  -- 每人每年度只有一筆年終
);

CREATE INDEX idx_yearend_user ON YearEndBonus(user_id);
CREATE INDEX idx_yearend_attribution ON YearEndBonus(attribution_year);
CREATE INDEX idx_yearend_payment ON YearEndBonus(payment_year, payment_month);
```

**說明：**
```
範例：2025年度年終獎金

2025年12月31日：決定發放
- attribution_year = 2025（歸屬2025年度）
- amount = 50,000元
- decision_date = 2025-12-31

2026年1月15日：實際發放
- payment_year = 2026
- payment_month = 1
- payment_date = 2026-01-15

客戶成本分析：
- 查詢「2025年客戶A成本」時
- 會按工時比例分攤「attribution_year = 2025」的年終獎金
- 即使實際發放在2026年1月
```

---

## 📐 薪資計算公式

### 1. 時薪基準計算（依勞基法）

```typescript
/**
 * 計算平日每小時工資額
 * 依據勞基法第 2 條第 3 款及第 24 條
 */
function calculateHourlyBase(monthlySalary: number): number {
  // 月薪制換算時數 = 30天 × 8小時 = 240小時
  const MONTHLY_STANDARD_HOURS = 240;
  
  // 平日每小時工資額 = 月薪 ÷ 240小時
  // 注意：月薪需包含所有「經常性給與」（底薪、全勤、津貼等）
  return monthlySalary / MONTHLY_STANDARD_HOURS;
}

/**
 * 範例：
 * 月薪 35,000 元（包含底薪、津貼等經常性給與）
 * 平日每小時工資額 = 35,000 ÷ 240 ≈ 146 元
 */
```

### 2. 加班費計算（依勞基法第24條）

```typescript
/**
 * 加班費計算
 */
function calculateOvertimePay(
  monthlySalary: number,
  overtimeHours: number,
  overtimeType: OvertimeType
): number {
  const hourlyBase = calculateHourlyBase(monthlySalary);
  
  let multiplier: number;
  
  switch (overtimeType) {
    case 'weekday_2h':  // 平日延長工時前2小時
      multiplier = 4/3;  // 1.34倍
      break;
    case 'weekday_beyond':  // 平日延長工時第3小時起
      multiplier = 5/3;  // 1.67倍
      break;
    case 'restday_2h':  // 休息日前2小時
      multiplier = 4/3;  // 1.34倍
      break;
    case 'restday_beyond':  // 休息日第3小時起
      multiplier = 5/3;  // 1.67倍
      break;
    case 'holiday':  // 國定假日/例假日
      multiplier = 2;  // 2.0倍
      break;
  }
  
  return hourlyBase * overtimeHours * multiplier;
}

/**
 * 範例：
 * 月薪 35,000 元（時薪基準 146元）
 * 平日加班 3 小時
 * - 前2小時：146 × 2 × 1.34 = 391元
 * - 第3小時：146 × 1 × 1.67 = 244元
 * - 合計：635元
 */
```

### 3. 全勤獎金規則

```typescript
/**
 * 全勤判定規則
 * 依據：公司內規（可調整）
 */
function checkFullAttendance(
  user_id: number,
  year: number,
  month: number
): boolean {
  // 查詢該月所有請假記錄
  const leaves = await db.prepare(`
    SELECT leave_type_id, hours
    FROM LeaveApplications
    WHERE user_id = ? 
      AND strftime('%Y', start_date) = ?
      AND strftime('%m', start_date) = ?
      AND is_deleted = 0
  `).bind(user_id, year, month).all();
  
  for (const leave of leaves.results) {
    // 以下情況會扣除全勤：
    // - 病假（leave_type_id = 2）
    // - 事假（leave_type_id = 3）
    
    if (leave.leave_type_id === 2 || leave.leave_type_id === 3) {
      return false;  // 不符合全勤
    }
    
    // 以下情況不影響全勤：
    // - 特休（leave_type_id = 1）
    // - 補休（leave_type_id = 6）✅ 關鍵！
    // - 婚假、喪假（leave_type_id = 4, 5）
  }
  
  // 檢查是否有曠職記錄
  const absences = await checkAbsenceRecords(user_id, year, month);
  if (absences > 0) {
    return false;
  }
  
  return true;  // 全勤
}
```

### 4. 月度薪資總計算

```typescript
/**
 * 計算員工月度薪資
 */
async function calculateMonthlyPayroll(
  user_id: number,
  year: number,
  month: number
): Promise<PayrollData> {
  
  // 1. 取得員工基本資料
  const user = await db.prepare(`
    SELECT * FROM Users WHERE user_id = ?
  `).bind(user_id).first();
  
  // 2. 計算時薪基準（月薪 ÷ 240小時）
  // 注意：需包含所有經常性給與（底薪、津貼、全勤等）
  const hourlyBase = calculateHourlyBase(user.base_salary);
  
  // 3. 查詢員工所有薪資項目（⚠️ 只算經常性給與，且過濾該月有效的）
  const targetMonth = `${year}-${String(month).padStart(2, '0')}`;
  const targetMonthStart = `${targetMonth}-01`;
  
  const salaryItems = await db.prepare(`
    SELECT sit.*, esi.amount, esi.effective_date, esi.expiry_date
    FROM EmployeeSalaryItems esi
    JOIN SalaryItemTypes sit ON esi.item_type_id = sit.item_type_id
    WHERE esi.user_id = ?
      AND esi.is_active = 1
      AND sit.is_regular_payment = 1  -- 經常性給與
      AND esi.effective_date <= ?     -- 生效日在目標月份之前或當月
      AND (esi.expiry_date IS NULL OR esi.expiry_date >= ?)  -- 未過期
    ORDER BY 
      CASE WHEN esi.expiry_date IS NOT NULL THEN 0 ELSE 1 END,  -- 月份專屬優先
      esi.effective_date DESC  -- 最新的優先
  `).bind(user_id, targetMonthStart, targetMonthStart).all();
  
  // 4. 去重：同一個項目類型只取一筆（優先月份專屬，其次預設值）
  const uniqueItems = new Map();
  for (const item of salaryItems.results) {
    if (!uniqueItems.has(item.item_type_id)) {
      uniqueItems.set(item.item_type_id, item);
    }
  }
  
  // 分類計算
  let total_allowances = 0;
  let total_bonuses = 0;
  let attendance_bonus = 0;
  
  for (const item of salaryItems.results) {
    if (item.category === 'allowance') {
      total_allowances += item.amount;
    } else if (item.category === 'bonus') {
      if (item.item_code === 'ATTENDANCE_BONUS') {
        attendance_bonus = item.amount;  // 先記錄，稍後判定是否給予
      } else {
        total_bonuses += item.amount;
      }
    }
  }
  
  // 4. 查詢該月所有加班記錄
  const overtimes = await db.prepare(`
    SELECT 
      t.work_date,
      t.hours,
      t.work_type_id,
      w.work_type_name,
      w.rate_multiplier
    FROM TimeLogs t
    JOIN WorkTypes w ON t.work_type_id = w.work_type_id
    WHERE t.user_id = ?
      AND strftime('%Y', t.work_date) = ?
      AND strftime('%m', t.work_date) = ?
      AND t.work_type_id > 1  -- 只算加班
      AND is_compensatory_leave = 0  -- 不選補休的才算加班費
      AND t.is_deleted = 0
  `).bind(user_id, year.toString(), month.toString().padStart(2, '0')).all();
  
  // 5. 分類計算加班費
  let overtime_weekday_2h = 0;
  let overtime_weekday_beyond = 0;
  let overtime_restday_2h = 0;
  let overtime_restday_beyond = 0;
  let overtime_holiday = 0;
  let total_overtime_hours = 0;
  
  for (const ot of overtimes.results) {
    total_overtime_hours += ot.hours;
    
    const overtimePay = calculateOvertimePay(
      user.base_salary,
      ot.hours,
      getOvertimeType(ot.work_type_id)
    );
    
    // 分類累計
    switch (ot.work_type_id) {
      case 2: overtime_weekday_2h += overtimePay; break;
      case 3: overtime_weekday_beyond += overtimePay; break;
      case 4: overtime_restday_2h += overtimePay; break;
      case 5: overtime_restday_beyond += overtimePay; break;
      case 6: overtime_holiday += overtimePay; break;
    }
  }
  
  // 6. 判定全勤
  const has_full_attendance = await checkFullAttendance(user_id, year, month);
  const final_attendance_bonus = has_full_attendance ? attendance_bonus : 0;
  
  // 7. 計算總薪資
  const gross_salary = 
    user.base_salary +
    total_allowances +
    total_bonuses +
    final_attendance_bonus +
    overtime_weekday_2h +
    overtime_weekday_beyond +
    overtime_restday_2h +
    overtime_restday_beyond +
    overtime_holiday;
  
  const net_salary = gross_salary - total_deductions;
  
  // 8. 儲存薪資記錄
  const payrollData = {
    user_id,
    year,
    month,
    base_salary: user.base_salary,
    total_allowances,
    total_bonuses: total_bonuses + final_attendance_bonus,
    overtime_weekday_2h,
    overtime_weekday_beyond,
    overtime_restday_2h,
    overtime_restday_beyond,
    overtime_holiday,
    total_deductions: 0,
    total_work_hours: await getTotalWorkHours(user_id, year, month),
    total_overtime_hours,
    total_weighted_hours: await getTotalWeightedHours(user_id, year, month),
    has_full_attendance,
    gross_salary,
    net_salary
  };
  
  await savePayrollRecord(payrollData);
  
  return payrollData;
}
```

---

## 🔌 API 端點

### 薪資項目類型管理

```
GET    /api/v1/admin/salary-item-types          查詢所有薪資項目類型
POST   /api/v1/admin/salary-item-types          新增薪資項目類型
PUT    /api/v1/admin/salary-item-types/:id      更新薪資項目類型
DELETE /api/v1/admin/salary-item-types/:id      刪除薪資項目類型
```

### 年終獎金管理 ⭐ 新增

```
GET    /api/v1/admin/year-end-bonus             查詢年終獎金列表
POST   /api/v1/admin/year-end-bonus             新增年終獎金
PUT    /api/v1/admin/year-end-bonus/:id         更新年終獎金
DELETE /api/v1/admin/year-end-bonus/:id         刪除年終獎金
GET    /api/v1/admin/year-end-bonus/summary     年終獎金統計
```

**新增年終獎金範例：**
```json
// POST /api/v1/admin/year-end-bonus
{
  "user_id": 1,
  "attribution_year": 2025,      // 歸屬年度
  "amount": 50000,
  "payment_date": "2026-01-15",  // 實際發放日期
  "notes": "2025年度績效優異"
}

// 回應
{
  "success": true,
  "data": {
    "bonus_id": 1,
    "user_id": 1,
    "username": "員工A",
    "attribution_year": 2025,
    "amount": 50000,
    "payment_date": "2026-01-15",
    "payment_year": 2026,
    "payment_month": 1
  }
}
```

**查詢年終統計範例：**
```json
// GET /api/v1/admin/year-end-bonus/summary?attribution_year=2025

{
  "success": true,
  "data": {
    "attribution_year": 2025,
    "total_bonus": 195000,
    "employee_count": 4,
    "average_bonus": 48750,
    "by_employee": [
      {
        "user_id": 1,
        "username": "員工A",
        "amount": 50000,
        "payment_status": "paid"
      },
      {
        "user_id": 2,
        "username": "員工B",
        "amount": 45000,
        "payment_status": "pending"
      }
    ]
  }
}
```

### 員工薪資設定

```
GET    /api/v1/admin/users/:id/salary            查詢員工薪資設定
PUT    /api/v1/admin/users/:id/salary            更新員工薪資設定（整批更新）
PUT    /api/v1/admin/users/:id/salary-items/:itemId  更新單筆薪資項目（績效獎金月度調整）⭐ 新增
POST   /api/v1/admin/salary-items/batch-update  批次更新薪資項目（所有員工的績效獎金）⭐ 新增
```

**更新單筆薪資項目（績效獎金月度調整）：**
```json
// PUT /api/v1/admin/users/1/salary-items/7
{
  "amount": 3500,  // 本月績效獎金調整為 3500元
  "effective_date": "2025-11-01"
}

// 回應
{
  "success": true,
  "data": {
    "employee_item_id": 7,
    "user_id": 1,
    "item_code": "PERFORMANCE",
    "item_name": "績效獎金",
    "old_amount": 2000,
    "new_amount": 3500,
    "effective_date": "2025-11-01",
    "impact": {
      "old_hourly_base": 166,
      "new_hourly_base": 172,  // 時薪增加（因績效獎金增加）
      "difference": 6
    }
  }
}
```

**批次更新績效獎金（所有員工，每人不同金額）：**
```json
// POST /api/v1/admin/salary-items/batch-update
{
  "item_code": "PERFORMANCE",  // 指定要更新的薪資項目
  "target_month": "2025-11",   // ⭐ 僅影響此月份
  "updates": [
    { "user_id": 1, "amount": 3500 },  // 員工A：本月3500元
    { "user_id": 2, "amount": 3000 },  // 員工B：本月3000元
    { "user_id": 3, "amount": 2500 }   // 員工C：本月2500元（每人不同）
  ]
}

// 系統處理邏輯：
// 1. 為每位員工創建「月份專屬」記錄
//    effective_date = '2025-11-01'
//    expiry_date = '2025-11-30'
// 2. 僅11月查詢時使用這些值
// 3. 12月查詢時恢復使用預設值

// 回應
{
  "success": true,
  "data": {
    "target_month": "2025-11",
    "total_updated": 3,
    "message": "已更新3位員工的11月績效獎金，僅影響11月薪資和成本分析"
  }
}
```

**實際效果：**
```
員工A的績效獎金：
- 預設值：2000元（effective_date='2025-01-01', expiry_date=NULL）
- 11月調整：3500元（effective_date='2025-11-01', expiry_date='2025-11-30'）
- 12月調整：4000元（effective_date='2025-12-01', expiry_date='2025-12-31'）

查詢10月薪資 → 使用2000元（預設值）
查詢11月薪資 → 使用3500元（11月專屬）✅
查詢12月薪資 → 使用4000元（12月專屬）✅
查詢明年1月 → 使用2000元（預設值）
```

**請求範例：**
```json
// PUT /api/v1/admin/users/1/salary
{
  "base_salary": 35000,
  "salary_items": [
    { "item_type_id": 1, "amount": 2000 },  // 全勤獎金
    { "item_type_id": 2, "amount": 1000 },  // 交通津貼
    { "item_type_id": 3, "amount": 1800 }   // 伙食津貼
  ]
}
```

**回應範例：**
```json
{
  "success": true,
  "data": {
    "user_id": 1,
    "username": "員工A",
    "base_salary": 35000,
    "hourly_base": 145.83,
    "salary_items": [
      { "item_name": "全勤獎金", "amount": 2000 },
      { "item_name": "交通津貼", "amount": 1000 },
      { "item_name": "伙食津貼", "amount": 1800 }
    ],
    "total_fixed_salary": 39800
  }
}
```

### 薪資計算與查詢

```
POST   /api/v1/admin/payroll/calculate          計算指定月份薪資
PUT    /api/v1/admin/payroll/:id/adjust         調整薪資項目金額（績效獎金等）⭐ 新增
GET    /api/v1/admin/payroll                    查詢薪資記錄
GET    /api/v1/admin/payroll/:id                查詢薪資詳情
GET    /api/v1/my/payroll                       查詢自己的薪資記錄
GET    /api/v1/my/payroll/:id                   查詢自己的薪資詳情
GET    /api/v1/reports/payroll-summary          薪資彙總報表
```

**調整薪資項目金額（用於績效獎金）：**
```json
// PUT /api/v1/admin/payroll/:payrollId/adjust
{
  "adjustments": [
    {
      "item_code": "PERFORMANCE",
      "amount": 3000  // 本月績效獎金 3000元（覆蓋預設值）
    }
  ]
}

// 回應
{
  "success": true,
  "data": {
    "payroll_id": 123,
    "user_id": 1,
    "username": "員工A",
    "adjusted_items": [
      {
        "item_code": "PERFORMANCE",
        "item_name": "績效獎金",
        "original_amount": 2000,  // 預設值
        "adjusted_amount": 3000,  // 調整後
        "difference": 1000
      }
    ],
    "gross_salary": 44315  // 重新計算後的總薪資
  }
}
```

### 年終獎金管理 ⭐ 新增

```
GET    /api/v1/admin/year-end-bonus             查詢年終獎金列表
POST   /api/v1/admin/year-end-bonus             新增年終獎金記錄
PUT    /api/v1/admin/year-end-bonus/:id         更新年終獎金
DELETE /api/v1/admin/year-end-bonus/:id         刪除年終獎金
GET    /api/v1/admin/year-end-bonus/summary     年終獎金彙總（依歸屬年度）
```

**計算薪資範例：**
```json
// POST /api/v1/admin/payroll/calculate
{
  "user_id": 1,  // 可選，不提供則計算所有員工
  "year": 2025,
  "month": 10
}

// 回應
{
  "success": true,
  "data": {
    "payroll_id": 123,
    "user_id": 1,
    "username": "員工A",
    "year": 2025,
    "month": 10,
    "base_salary": 35000,
    "total_allowances": 2800,
    "total_bonuses": 2000,
    "overtime_weekday_2h": 880,
    "overtime_weekday_beyond": 244,
    "gross_salary": 41352,
    "net_salary": 41352,
    "has_full_attendance": true,
    "total_overtime_hours": 8.5
  }
}
```

**新增年終獎金範例：** ⭐
```json
// POST /api/v1/admin/year-end-bonus
{
  "user_id": 1,
  "attribution_year": 2025,        // 歸屬2025年度
  "amount": 50000,
  "payment_year": 2026,            // 實際在2026年發放
  "payment_month": 1,
  "decision_date": "2025-12-31",
  "notes": "根據2025年績效發放"
}

// 回應
{
  "success": true,
  "data": {
    "bonus_id": 1,
    "user_id": 1,
    "username": "員工A",
    "attribution_year": 2025,
    "amount": 50000,
    "payment_year": 2026,
    "payment_month": 1,
    "decision_date": "2025-12-31"
  }
}
```

**查詢年終彙總範例：**
```json
// GET /api/v1/admin/year-end-bonus/summary?attribution_year=2025

{
  "success": true,
  "data": {
    "attribution_year": 2025,
    "total_amount": 180000,        // 所有員工合計
    "employee_count": 4,
    "average_bonus": 45000,
    "details": [
      {
        "user_id": 1,
        "username": "員工A",
        "amount": 50000,
        "payment_status": "paid",  // 已發放
        "payment_date": "2026-01-15"
      },
      {
        "user_id": 2,
        "username": "員工B",
        "amount": 45000,
        "payment_status": "pending"  // 尚未發放
      }
    ]
  }
}
```

---

## 🎨 前端組件

### EmployeeSalarySettingPage.vue

員工薪資設定頁面，支援靈活配置薪資項目。

### YearEndBonusPage.vue（年終獎金管理）⭐ 新增

**功能：** 獨立管理年終獎金，不影響平時成本計算

```vue
<template>
  <div class="year-end-bonus-page">
    <h2>年終獎金管理</h2>
    
    <!-- 年度選擇 -->
    <div class="year-selector">
      <label>歸屬年度：</label>
      <select v-model="selectedYear">
        <option v-for="y in years" :value="y">{{ y }}年</option>
      </select>
    </div>
    
    <!-- 統計卡片 -->
    <div class="summary-cards">
      <StatCard title="年終總額" :value="formatCurrency(summary.total_amount)" />
      <StatCard title="人數" :value="summary.employee_count + ' 人'" />
      <StatCard title="平均" :value="formatCurrency(summary.average_bonus)" />
    </div>
    
    <!-- 員工列表 -->
    <DataTable :columns="columns" :data="bonusList">
      <template #actions="{ row }">
        <StyledButton @click="editBonus(row)">編輯</StyledButton>
      </template>
    </DataTable>
    
    <!-- 新增/編輯表單 -->
    <Modal :show="showForm" title="設定年終獎金">
      <form @submit.prevent="submitBonus">
        <FormGroup label="員工">
          <select v-model="form.user_id" required>
            <option v-for="u in employees" :value="u.user_id">
              {{ u.name }}
            </option>
          </select>
        </FormGroup>
        
        <FormGroup label="歸屬年度">
          <input type="number" v-model="form.attribution_year" required />
          <p class="hint">例如：2025（即使在2026年1月發放）</p>
        </FormGroup>
        
        <FormGroup label="年終金額">
          <input type="number" v-model="form.amount" required />
        </FormGroup>
        
        <FormGroup label="實際發放日期">
          <input type="date" v-model="form.payment_date" />
          <p class="hint">預計何時發放（如：2026-01-15）</p>
        </FormGroup>
        
        <FormGroup label="備註">
          <textarea v-model="form.notes" 
            placeholder="如：根據2025年績效決定"></textarea>
        </FormGroup>
        
        <StyledButton type="submit">儲存</StyledButton>
      </form>
    </Modal>
    
    <!-- 說明文字 -->
    <div class="info-box">
      <h4>💡 年終獎金說明</h4>
      <ul>
        <li>年終獎金獨立管理，不影響平時的客戶成本分析</li>
        <li>歸屬年度：年終獎金計入哪一年的成本（如：2025）</li>
        <li>發放日期：實際發薪日（通常是次年1月）</li>
        <li>成本分攤：查詢客戶成本時，可勾選「包含年終」查看真實總成本</li>
        <li>分攤方式：按該員工為各客戶工作的工時比例分攤</li>
      </ul>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted, watch } from 'vue';
import { getYearEndBonusSummary, createYearEndBonus } from '@/api/salary';

const selectedYear = ref(new Date().getFullYear() - 1);  // 預設上一年
const summary = ref({});
const bonusList = ref([]);
const showForm = ref(false);
const form = ref({
  user_id: '',
  attribution_year: selectedYear.value,
  amount: 0,
  payment_date: '',
  notes: ''
});

const columns = [
  { key: 'username', label: '員工姓名' },
  { key: 'amount', label: '年終金額' },
  { key: 'payment_date', label: '發放日期' },
  { key: 'payment_status', label: '狀態' },
  { key: 'actions', label: '操作' }
];

watch(selectedYear, loadData);

onMounted(() => loadData());

async function loadData() {
  const response = await getYearEndBonusSummary(selectedYear.value);
  summary.value = response.data;
  bonusList.value = response.data.details || [];
}

async function submitBonus() {
  await createYearEndBonus(form.value);
  alert('年終獎金設定成功');
  showForm.value = false;
  loadData();
}
</script>
```

### PerformanceBonusAdjustmentPage.vue（績效獎金調整頁面）⭐ 新增

**功能：** 管理員每月調整績效獎金金額（計入時薪，影響成本分析）

```vue
<template>
  <div class="performance-bonus-page">
    <h2>績效獎金調整</h2>
    
    <div class="info-box">
      <h4>💡 重要說明</h4>
      <ul>
        <li>績效獎金屬於「經常性給與」，<strong>會計入時薪基準</strong></li>
        <li>調整績效獎金會影響該月的時薪成本率和客戶成本分析</li>
        <li>建議：每月初（或上月底）調整，確保成本計算準確</li>
      </ul>
    </div>
    
    <!-- 月份選擇 -->
    <div class="month-selector">
      <label>調整月份：</label>
      <input type="month" v-model="selectedMonth" />
      <StyledButton @click="loadEmployees">載入員工</StyledButton>
    </div>
    
    <!-- 員工績效獎金列表 -->
    <div v-if="employees.length > 0" class="employee-list">
      <table class="bonus-table">
        <thead>
          <tr>
            <th>員工姓名</th>
            <th>預設績效獎金</th>
            <th>本月調整為</th>
            <th>時薪影響</th>
            <th>狀態</th>
          </tr>
        </thead>
        <tbody>
          <tr v-for="emp in employees" :key="emp.user_id">
            <td>{{ emp.username }}</td>
            <td>{{ formatCurrency(emp.default_performance) }}</td>
            <td>
              <input 
                type="number" 
                v-model.number="emp.adjusted_performance"
                :placeholder="emp.default_performance"
                @input="calculateImpact(emp)"
                class="amount-input"
              />
            </td>
            <td>
              <span v-if="emp.hourly_impact" :class="emp.hourly_impact > 0 ? 'text-green' : 'text-red'">
                {{ emp.hourly_impact > 0 ? '+' : '' }}{{ emp.hourly_impact }}元/時
              </span>
              <span v-else class="text-gray">無變化</span>
            </td>
            <td>
              <span v-if="emp.adjusted_performance !== emp.default_performance" class="badge badge-warning">
                已調整
              </span>
              <span v-else class="badge badge-secondary">
                使用預設
              </span>
            </td>
          </tr>
        </tbody>
      </table>
      
      <!-- 批次操作 -->
      <div class="batch-actions">
        <StyledButton @click="batchUpdate" variant="primary">
          儲存所有調整
        </StyledButton>
        <StyledButton @click="resetAll" variant="ghost">
          全部恢復預設
        </StyledButton>
      </div>
      
      <!-- 影響預覽 -->
      <div class="impact-summary">
        <h4>調整影響預覽</h4>
        <p>
          共 {{ adjustedCount }} 位員工調整績效獎金<br>
          時薪成本率變化：平均 {{ averageImpact > 0 ? '+' : '' }}{{ averageImpact }}元/時<br>
          這會影響 {{ selectedMonth }} 的客戶成本分析報表
        </p>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue';
import { getEmployeeSalaries, batchUpdateSalaryItems } from '@/api/salary';

const selectedMonth = ref('2025-11');
const employees = ref([]);

const adjustedCount = computed(() => 
  employees.value.filter(e => e.adjusted_performance !== e.default_performance).length
);

const averageImpact = computed(() => {
  const impacts = employees.value.map(e => e.hourly_impact || 0);
  const sum = impacts.reduce((a, b) => a + b, 0);
  return Math.round(sum / impacts.length);
});

async function loadEmployees() {
  const response = await getEmployeeSalaries();
  employees.value = response.data.map(emp => {
    const perfItem = emp.salary_items.find(i => i.item_code === 'PERFORMANCE');
    return {
      user_id: emp.user_id,
      username: emp.username,
      base_salary: emp.base_salary,
      default_performance: perfItem?.amount || 0,
      adjusted_performance: perfItem?.amount || 0,
      current_hourly_base: emp.hourly_base,
      hourly_impact: 0
    };
  });
}

function calculateImpact(emp) {
  const diff = emp.adjusted_performance - emp.default_performance;
  const hourlyDiff = diff / 240;  // 影響時薪
  emp.hourly_impact = Math.round(hourlyDiff);
}

async function batchUpdate() {
  const updates = employees.value
    .filter(e => e.adjusted_performance !== e.default_performance)
    .map(e => ({
      user_id: e.user_id,
      amount: e.adjusted_performance
    }));
  
  if (updates.length === 0) {
    alert('沒有需要調整的項目');
    return;
  }
  
  await batchUpdateSalaryItems({
    item_code: 'PERFORMANCE',
    updates,
    effective_date: selectedMonth.value + '-01'
  });
  
  alert(`已更新${updates.length}位員工的績效獎金`);
  
  // 重新載入
  await loadEmployees();
}

function resetAll() {
  employees.value.forEach(emp => {
    emp.adjusted_performance = emp.default_performance;
    emp.hourly_impact = 0;
  });
}
</script>

<style scoped>
.info-box {
  background: #dbeafe;
  border-left: 4px solid #3b82f6;
  padding: 1rem;
  margin-bottom: 2rem;
}

.bonus-table {
  width: 100%;
  border-collapse: collapse;
}

.bonus-table th,
.bonus-table td {
  padding: 0.75rem;
  border: 1px solid #e5e7eb;
  text-align: left;
}

.amount-input {
  width: 120px;
  text-align: right;
  padding: 0.5rem;
  border: 1px solid #d1d5db;
  border-radius: 0.375rem;
}

.impact-summary {
  margin-top: 2rem;
  padding: 1rem;
  background: #f3f4f6;
  border-radius: 0.5rem;
}
</style>
```

**操作流程範例：**
```
每月1日（或上月底）：

步驟1：管理員進入「績效獎金調整」頁面
  選擇月份：2025-11
  點擊「載入員工」

步驟2：看到所有員工列表
  員工A：預設 2000元 → 調整為 3500元（時薪 +6元/時）
  員工B：預設 2000元 → 調整為 3000元（時薪 +4元/時）
  員工C：預設 2000元 → 保持不變

步驟3：點擊「儲存所有調整」
  系統批次更新 EmployeeSalaryItems 表
  員工A的績效獎金 amount 從 2000 → 3500

步驟4：之後查詢11月客戶成本時
  員工A的時薪成本率會使用調整後的值（包含3500元績效獎金）
  客戶成本分析反映真實人力成本 ✅
```

### PayrollReportPage.vue

薪資報表頁面，顯示月度薪資明細和統計。

### YearEndBonusManagementPage.vue（年終獎金管理）⭐ 新增

**功能：** 管理員設定年終獎金

```vue
<template>
  <div class="yearend-bonus-page">
    <h2>年終獎金管理</h2>
    
    <div class="year-selector">
      <label>歸屬年度：</label>
      <select v-model="selectedYear">
        <option value="2025">2025年</option>
        <option value="2024">2024年</option>
      </select>
      <StyledButton @click="loadBonusData">查詢</StyledButton>
    </div>
    
    <!-- 彙總資訊 -->
    <div class="summary-cards">
      <StatCard title="年終總額" :value="formatCurrency(summary.total_amount)" />
      <StatCard title="員工人數" :value="summary.employee_count + '人'" />
      <StatCard title="平均金額" :value="formatCurrency(summary.average_bonus)" />
    </div>
    
    <!-- 員工年終設定 -->
    <DataTable :columns="columns" :data="bonusData">
      <template #amount="{ row }">
        <input 
          v-model.number="row.amount" 
          type="number"
          @change="updateBonus(row)"
          placeholder="輸入金額"
        />
      </template>
      
      <template #payment_date="{ row }">
        <input 
          v-model="row.payment_date" 
          type="date"
          @change="updateBonus(row)"
        />
      </template>
    </DataTable>
    
    <div class="actions">
      <StyledButton @click="saveAll" variant="primary">儲存所有變更</StyledButton>
    </div>
    
    <div class="notice">
      <p><strong>💡 使用說明：</strong></p>
      <ul>
        <li>歸屬年度：選擇這筆年終是算在哪一年的成本（如：2025）</li>
        <li>發放時間：實際發薪日期（可以是次年1月）</li>
        <li>成本分攤：系統會按各客戶的工時比例自動分攤年終獎金</li>
      </ul>
      
      <p><strong>⚠️ 範例：</strong></p>
      <p>
        2025年12月決定發年終 → 歸屬年度選「2025」<br>
        2026年1月15日實際發放 → 發放日期填「2026-01-15」<br>
        查詢「2025年客戶成本」→ 會包含年終分攤 ✅
      </p>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import { getYearEndBonusSummary, updateYearEndBonus } from '@/api/salary';

const selectedYear = ref(2025);
const bonusData = ref([]);
const summary = ref({});

async function loadBonusData() {
  const response = await getYearEndBonusSummary(selectedYear.value);
  summary.value = response.data;
  bonusData.value = response.data.details;
}

async function updateBonus(row) {
  await updateYearEndBonus(row.bonus_id, {
    amount: row.amount,
    payment_date: row.payment_date
  });
}

onMounted(() => {
  loadBonusData();
});
</script>
```

---

### SalaryItemTypeManagementPage.vue（薪資項目設定）

**功能：** 管理員新增/編輯薪資項目類型

```vue
<template>
  <div class="salary-item-management">
    <h2>薪資項目設定</h2>
    
    <StyledButton @click="showForm = true">新增薪資項目</StyledButton>
    
    <!-- 新增/編輯表單 -->
    <Modal :show="showForm" title="新增薪資項目">
      <form @submit.prevent="submitForm">
        <FormGroup label="項目代碼">
          <input v-model="form.item_code" placeholder="如：PERFORMANCE" required />
        </FormGroup>
        
        <FormGroup label="項目名稱">
          <input v-model="form.item_name" placeholder="如：績效獎金" required />
        </FormGroup>
        
        <FormGroup label="類別">
          <select v-model="form.category" required>
            <option value="allowance">津貼</option>
            <option value="bonus">獎金</option>
            <option value="deduction">扣款</option>
          </select>
        </FormGroup>
        
        <!-- 金額固定性 -->
        <FormGroup label="金額固定性">
          <label>
            <input type="checkbox" v-model="form.is_fixed" />
            每月金額固定（如：交通津貼每月1000元）
          </label>
          <p class="hint">不勾選 = 金額會變動（如：績效獎金2000~5000元浮動）</p>
        </FormGroup>
        
        <!-- ⭐ 經常性給與（影響時薪計算）-->
        <FormGroup label="經常性給與（重要！）">
          <label>
            <input type="checkbox" v-model="form.is_regular_payment" />
            <strong>每月都發放（計入時薪基準）</strong>
          </label>
          <p class="hint warning">
            ⚠️ 勾選後會計入時薪計算（影響加班費）<br>
            不勾選 = 偶爾發放（如：年終獎金、三節獎金）
          </p>
          <div class="examples">
            <p><strong>應該勾選：</strong>全勤獎金、績效獎金（每月都發）、各種津貼</p>
            <p><strong>不應勾選：</strong>年終獎金、端午獎金、中秋獎金（年度性）</p>
          </div>
        </FormGroup>
        
        <FormGroup label="是否影響勞健保">
          <label>
            <input type="checkbox" v-model="form.affects_labor_insurance" />
            計入勞健保投保金額
          </label>
        </FormGroup>
        
        <StyledButton type="submit">儲存</StyledButton>
      </form>
    </Modal>
    
    <!-- 項目列表 -->
    <DataTable :columns="columns" :data="items">
      <template #is_regular_payment="{ row }">
        <span v-if="row.is_regular_payment" class="badge badge-success">
          經常性（計入時薪）
        </span>
        <span v-else class="badge badge-secondary">
          非經常性
        </span>
      </template>
    </DataTable>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import { getSalaryItemTypes, createSalaryItemType } from '@/api/salary';

const showForm = ref(false);
const items = ref([]);
const form = ref({
  item_code: '',
  item_name: '',
  category: 'allowance',
  is_fixed: true,
  is_regular_payment: true,  // ⭐ 預設勾選（大部分項目都是經常性）
  affects_labor_insurance: true
});

const columns = [
  { key: 'item_name', label: '項目名稱' },
  { key: 'category', label: '類別' },
  { key: 'is_fixed', label: '金額固定' },
  { key: 'is_regular_payment', label: '經常性給與' },
  { key: 'actions', label: '操作' }
];

onMounted(async () => {
  const response = await getSalaryItemTypes();
  items.value = response.data;
});

async function submitForm() {
  await createSalaryItemType(form.value);
  alert('薪資項目新增成功');
  showForm.value = false;
  // 重新載入列表...
}
</script>
```

---

## 📊 報表輸出

### 1. 月度薪資明細

包含：
- 底薪
- 各項津貼/獎金明細
- 加班費明細（分類顯示）
- 扣款明細
- 應發/實發薪資

### 2. 年度薪資統計

包含：
- 全年薪資總額
- 月度趨勢圖
- 加班費統計
- 成本分析

---

## ⚠️ 注意事項

1. **補休不影響全勤**：補休假別（leave_type_id = 12）不計入全勤扣除條件
2. **加班費計算**：嚴格遵守勞基法倍率（1.34、1.67、2.0、2.67等分段計算）
3. **時薪基準**：固定使用 240 小時計算（30天 × 8小時），符合月薪制換算標準
4. **經常性給與**：⭐ 時薪計算使用 `is_regular_payment = 1` 篩選，包含：
   - 底薪（必定算）
   - 每月都發的津貼（交通、伙食、電話等）
   - 每月都發的獎金（全勤、績效等）
   - **不包含**：年終獎金、三節獎金（偶爾發放）
5. **靈活性**：薪資項目可自由新增，管理員在新增時勾選「是否為經常性給與」
6. **績效獎金處理**：如果每月都發（金額浮動也可），應勾選「經常性給與」以正確計算時薪

---

## 🧪 測試案例

### 關鍵業務邏輯測試 ⭐

```typescript
/**
 * 測試1：請病假應該扣除全勤獎金
 * 對應需求：業務審查報告 第五章場景4
 */
test('請病假應該扣除全勤獎金', async () => {
  const userId = 1;
  
  // 1. 員工申請病假
  await applyLeave({
    user_id: userId,
    leave_type_id: 2,  // 病假
    start_date: '2025-11-10',
    end_date: '2025-11-10',
    days: 1
  });
  
  // 2. 計算11月薪資
  const payroll = await calculateMonthlyPayroll(userId, 2025, 11);
  
  // 3. 驗證全勤獎金為0
  expect(payroll.has_full_attendance).toBe(false);
  expect(payroll.total_bonuses).toBe(0);  // 全勤獎金應為0
  
  console.log('✓ 病假正確扣除全勤獎金');
});

/**
 * 測試2：請補休不應該扣除全勤獎金
 * 對應需求：業務審查報告 第三章、第四章
 */
test('請補休不應該扣除全勤獎金', async () => {
  const userId = 1;
  
  // 1. 員工使用補休請假
  await applyLeave({
    user_id: userId,
    leave_type_id: 12,  // 補休
    start_date: '2025-11-10',
    end_date: '2025-11-10',
    days: 1
  });
  
  // 2. 計算11月薪資
  const payroll = await calculateMonthlyPayroll(userId, 2025, 11);
  
  // 3. 驗證全勤獎金正常發放
  expect(payroll.has_full_attendance).toBe(true);
  expect(payroll.total_bonuses).toBeGreaterThan(0);  // 全勤獎金應正常發放
  
  console.log('✓ 補休不影響全勤獎金');
});

/**
 * 測試3：時薪計算應包含經常性給與
 * 對應需求：業務審查報告 第三章 3.4節
 */
test('時薪計算應包含所有經常性給與', async () => {
  const userId = 1;
  
  // 1. 設定員工薪資
  await setEmployeeSalary(userId, {
    base_salary: 35000,
    salary_items: [
      { item_type_id: 1, amount: 2000 },  // 全勤獎金（經常性）
      { item_type_id: 2, amount: 1000 },  // 交通津貼（經常性）
      { item_type_id: 7, amount: 3000 }   // 績效獎金（經常性，雖然金額浮動）
    ]
  });
  
  // 2. 計算時薪成本率
  const hourlyCostRate = await calculateFullHourlyCostRate(userId, 2025, 11);
  
  // 3. 驗證時薪包含所有經常性給與
  const expectedMonthlySalary = 35000 + 2000 + 1000 + 3000;  // 41,000元
  const expectedHourlyRate = expectedMonthlySalary / 240;  // 約170.83元
  
  expect(hourlyCostRate).toBeCloseTo(expectedHourlyRate, 2);
  
  console.log('✓ 時薪正確包含所有經常性給與');
});

/**
 * 測試4：國定假日加班費特殊計算
 * 對應需求：業務審查報告 第三章 範例4
 */
test('國定假日加班3小時應給付8小時工資', async () => {
  const userId = 1;
  const monthlySalary = 35000;
  const hourlyBase = monthlySalary / 240;  // 約146元
  
  // 1. 員工國慶日加班3小時
  await createTimeLog({
    user_id: userId,
    work_date: '2025-10-10',  // 國慶日
    work_type_id: 7,  // 國定假日8小時內
    hours: 3,
    client_id: '12345678'
  });
  
  // 2. 計算加班費
  const overtimePay = await calculateHolidayOvertimePay(userId, 3, 7);
  
  // 3. 驗證給付8小時工資（不是3小時）
  const expected = hourlyBase * 8 * 2.0;  // 8小時 × 2.0倍
  expect(overtimePay).toBeCloseTo(expected, 2);
  
  // 4. 驗證補休產生8小時（不是3小時）
  const compLeave = await getCompensatoryLeaveBalance(userId);
  expect(compLeave.total_hours).toBe(8.0);  // 應產生8小時補休
  
  // 5. 驗證加權工時為8小時（不是6小時）
  const timelog = await getTimeLog(userId, '2025-10-10');
  expect(timelog.weighted_hours).toBe(8.0);  // 加權工時應為8
  
  console.log('✓ 國定假日特殊計算正確（統一8小時）');
});

/**
 * 測試5：年終獎金按工時比例分攤到客戶
 * 對應需求：業務審查報告 第七章問題7
 */
test('年終獎金應按工時比例分攤到各客戶', async () => {
  const userId = 1;
  
  // 1. 設定年終獎金
  await createYearEndBonus({
    user_id: userId,
    attribution_year: 2025,
    amount: 50000
  });
  
  // 2. 查詢客戶A成本（含年終）
  const clientCost = await calculateClientCost(
    '12345678',  // 客戶A
    '2025-01-01',
    '2025-12-31',
    true  // 包含年終獎金分攤
  );
  
  // 3. 驗證年終分攤計算
  // 假設員工A全年為客戶A工作240小時，總工時1920小時
  // 占比：240 / 1920 = 12.5%
  // 分攤：50,000 × 12.5% = 6,250元
  
  expect(clientCost.cost_breakdown.year_end_bonus).toBeCloseTo(6250, 0);
  
  console.log('✓ 年終獎金按工時比例正確分攤');
});

/**
 * 測試6：補休FIFO使用順序
 * 對應需求：業務審查報告 第三章 3.2節
 */
test('補休應按FIFO順序使用', async () => {
  const userId = 1;
  
  // 1. 產生3筆補休（不同日期）
  await generateCompLeave(userId, 4.0, 'log_1', 1.34, '2025-10-05');  // 10/5產生4h
  await generateCompLeave(userId, 3.0, 'log_2', 1.67, '2025-10-12');  // 10/12產生3h
  await generateCompLeave(userId, 2.0, 'log_3', 1.34, '2025-10-18');  // 10/18產生2h
  
  // 2. 使用4小時補休
  await useCompensatoryLeave(userId, 4.0, '2025-10-25');
  
  // 3. 驗證使用順序（FIFO）
  const remaining = await getCompensatoryLeaveBalance(userId);
  
  // 應該：
  // - 10/5的4h全部用完（剩0h）
  // - 10/12的3h剩3h（未動）
  // - 10/18的2h剩2h（未動）
  
  const details = remaining.details;
  expect(details.find(d => d.earned_date === '2025-10-05').hours_remaining).toBe(0);
  expect(details.find(d => d.earned_date === '2025-10-12').hours_remaining).toBe(3);
  expect(details.find(d => d.earned_date === '2025-10-18').hours_remaining).toBe(2);
  
  console.log('✓ 補休FIFO順序正確');
});

/**
 * 測試7：性別限制驗證
 * 對應需求：業務審查報告 第二章 4節
 */
test('男性員工申請產假應被拒絕', async () => {
  const maleUser = { user_id: 1, gender: '男' };
  
  const data = {
    leave_type_id: 5,  // 產假（限女性）
    start_date: '2025-11-20',
    end_date: '2026-01-15',
    days: 56
  };
  
  // 應該拋出錯誤
  await expect(applyLeave(data, maleUser))
    .rejects.toMatchObject({
      code: 'GENDER_RESTRICTION_VIOLATED',
      message: expect.stringContaining('產假僅限女性員工申請')
    });
  
  console.log('✓ 性別限制驗證正確');
});

/**
 * 測試8：收據號碼併發安全
 * 對應需求：業務審查報告 第七章問題4
 */
test('多人同時開收據應自動分配不同號碼', async () => {
  // 模擬2個請求同時執行
  const [receipt1, receipt2] = await Promise.all([
    generateReceiptNumber('202511'),
    generateReceiptNumber('202511')
  ]);
  
  // 驗證號碼不同
  expect(receipt1).not.toBe(receipt2);
  expect(receipt1).toMatch(/^202511-\d{3}$/);
  expect(receipt2).toMatch(/^202511-\d{3}$/);
  
  console.log(`✓ 併發安全：${receipt1}, ${receipt2}`);
});

/**
 * 測試9：階段必須按順序完成
 * 對應需求：業務審查報告 第二章 5節
 */
test('不可跳過階段直接完成後續階段', async () => {
  const taskId = 123;
  const stage3Id = 3;
  
  // 嘗試直接開始階段3（階段2未完成）
  await expect(startStage(taskId, stage3Id, user))
    .rejects.toMatchObject({
      code: 'STAGE_ORDER_VIOLATION',
      message: expect.stringContaining('請先完成')
    });
  
  console.log('✓ 階段順序驗證正確');
});

/**
 * 測試10：工時0.5倍數驗證
 */
test('工時必須是0.5的倍數', async () => {
  const data = {
    work_date: '2025-11-01',
    hours: 2.3,  // 非0.5倍數
    work_type_id: 1
  };
  
  await expect(createTimeLog(data, user))
    .rejects.toMatchObject({
      code: 'HOURS_PRECISION_ERROR',
      message: expect.stringContaining('0.5的倍數')
    });
  
  console.log('✓ 工時精度驗證正確');
});
```

---

**相關文檔：**
- [假期管理-完整規格](./假期管理-完整規格.md)
- [工時管理-完整規格](./工時管理-完整規格.md)
- [管理成本-完整規格](./管理成本-完整規格.md)

