# 共用規範

**所有功能開發的統一標準**

---

## 🔌 API 統一標準

### 響應格式
```json
// 成功
{
  "success": true,
  "data": { ... }
}

// 錯誤
{
  "success": false,
  "error": {
    "code": "ERROR_CODE",
    "message": "錯誤訊息"
  }
}

// 分頁
{
  "success": true,
  "data": [ ... ],
  "pagination": {
    "total": 150,
    "limit": 50,
    "offset": 0
  }
}
```

### HTTP 狀態碼
```
200 - 成功（查詢、更新、刪除）
201 - 創建成功
400 - 請求錯誤
401 - 未登入
403 - 無權限
404 - 資源不存在
409 - 資源衝突（重複）
422 - 驗證錯誤
500 - 伺服器錯誤
```

### 錯誤碼統一對照表 ⭐

**設計原則：**
- 使用字串代碼（易讀、易維護）
- 分類編號（通用/業務/系統）
- 前後端共用同一份清單

**完整錯誤碼清單：**

```typescript
// ==================== 通用錯誤 (100-199) ====================
VALIDATION_ERROR              // 100 - 資料驗證失敗
UNAUTHORIZED                  // 101 - 未登入
FORBIDDEN                     // 102 - 無權限
NOT_FOUND                     // 103 - 資源不存在
CONFLICT                      // 104 - 資源衝突（重複）
BAD_REQUEST                   // 105 - 請求格式錯誤

// ==================== 工時管理 (200-219) ====================
HOURS_PRECISION_ERROR         // 200 - 工時必須是0.5的倍數
DAILY_HOURS_EXCEEDED          // 201 - 超過每日工時上限（12小時）
WORK_TYPE_HOURS_MISMATCH      // 202 - 工作類型與工時不符（如：國定假日8h內不可超過8h）
TIMELOG_NOT_OWNER             // 203 - 只能修改自己的工時

// ==================== 假期管理 (220-239) ====================
GENDER_RESTRICTION_VIOLATED   // 220 - 性別限制違反（如：男性申請產假）
INSUFFICIENT_LEAVE_BALANCE    // 221 - 假期餘額不足
LEAVE_OVERLAP                 // 222 - 假期重疊
LEAVE_DATE_INVALID            // 223 - 假期日期無效（結束日早於開始日）

// ==================== 任務管理 (240-259) ====================
STAGE_ORDER_VIOLATION         // 240 - 階段順序違反（必須按順序完成）
STAGE_NOT_IN_PROGRESS         // 241 - 階段狀態錯誤（只能完成進行中的階段）
TASK_NOT_OWNER                // 242 - 只能操作自己的任務
TEMPLATE_NOT_FOUND            // 243 - 任務模板不存在

// ==================== 客戶管理 (260-279) ====================
CLIENT_ID_INVALID             // 260 - 統一編號格式錯誤（必須8位數字）
CLIENT_ALREADY_EXISTS         // 261 - 統一編號已存在
CLIENT_HAS_ACTIVE_SERVICES    // 262 - 客戶有啟用中的服務，無法刪除

// ==================== 收據收款 (280-299) ====================
RECEIPT_NUMBER_CONFLICT       // 280 - 收據號碼衝突
RECEIPT_NUMBER_FORMAT_ERROR   // 281 - 收據號碼格式錯誤（應為YYYYMM-NNN）
RECEIPT_SEQUENCE_EXCEEDED     // 282 - 收據流水號已達上限（999）
PAYMENT_AMOUNT_EXCEEDED       // 283 - 收款金額超過應收金額
RECEIPT_ALREADY_PAID          // 284 - 收據已全額收款

// ==================== 薪資管理 (300-319) ====================
SALARY_ITEM_NOT_REGULAR       // 300 - 非經常性給與不可計入時薪
YEAR_END_BONUS_DUPLICATE      // 301 - 該年度年終獎金已存在
PAYROLL_ALREADY_CALCULATED    // 302 - 該月薪資已計算

// ==================== 系統設定 (320-339) ====================
DANGEROUS_SETTING_NOT_CONFIRMED  // 320 - 危險設定未確認（需勾選「我了解風險」）
READONLY_SETTING                 // 321 - 唯讀設定（受勞基法限制，不可修改）
CRON_JOB_ALREADY_EXECUTED       // 322 - 定時任務已執行（冪等性檢查）
CRON_JOB_FAILED                 // 323 - 定時任務執行失敗

// ==================== 系統錯誤 (500+) ====================
INTERNAL_ERROR                // 500 - 伺服器內部錯誤
DATABASE_ERROR                // 501 - 資料庫錯誤
SQL_INJECTION_DETECTED        // 502 - 偵測到SQL注入攻擊
TRANSACTION_FAILED            // 503 - 交易失敗
```

**使用範例：**

```typescript
// 後端拋出錯誤
if (hours % 0.5 !== 0) {
  throw new ValidationError(
    '工時必須是0.5的倍數（如：0.5、1.0、1.5、2.0...）',
    'HOURS_PRECISION_ERROR'  // ⭐ 錯誤碼
  );
}

// API 回應
{
  "success": false,
  "error": {
    "code": "HOURS_PRECISION_ERROR",
    "message": "工時必須是0.5的倍數（如：0.5、1.0、1.5、2.0...）",
    "field": "hours"
  }
}

// 前端處理
try {
  await createTimeLog(data);
} catch (error) {
  if (error.code === 'HOURS_PRECISION_ERROR') {
    // 特殊處理：自動修正為最接近的0.5倍數
    data.hours = Math.round(data.hours * 2) / 2;
    retry();
  } else {
    // 一般錯誤：顯示訊息
    alert(error.message);
  }
}
```

**前後端共用錯誤碼：**

```typescript
// shared/error-codes.ts（前後端共用）
export const ERROR_CODES = {
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  HOURS_PRECISION_ERROR: 'HOURS_PRECISION_ERROR',
  GENDER_RESTRICTION_VIOLATED: 'GENDER_RESTRICTION_VIOLATED',
  // ... 所有錯誤碼
} as const;

// 後端使用
import { ERROR_CODES } from '@/shared/error-codes';
throw new ValidationError('...', ERROR_CODES.HOURS_PRECISION_ERROR);

// 前端使用
import { ERROR_CODES } from '@/shared/error-codes';
if (error.code === ERROR_CODES.HOURS_PRECISION_ERROR) { ... }
```

---

## 🔒 權限控制

### 兩種角色
```typescript
// 管理員
user.is_admin === 1  → 所有功能、所有資料

// 員工  
user.is_admin === 0  → 基本功能、自己的資料
```

### 前端路由保護
```typescript
// 管理員專屬頁面
{ 
  path: '/admin/*', 
  meta: { requireAdmin: true } 
}

// 路由守衛
router.beforeEach((to, from, next) => {
  if (to.meta.requireAdmin && !user.is_admin) {
    return next('/403');
  }
  next();
});
```

### 後端 API 保護
```typescript
// 管理員專屬 API
app.post('/api/v1/admin/*', requireAdmin, handler);

// 員工 API（Service層自動過濾資料）
app.get('/api/v1/timelogs', authMiddleware, handler);
```

### 資料範圍控制
```typescript
// Service 層
async getTimeLogs(filters, user) {
  if (!user.is_admin) {
    filters.user_id = user.user_id;  // 員工只看自己
  }
  return await this.repository.findAll(filters);
}
```

---

## 💾 資料庫規範

### 表名：PascalCase
```
Users, Clients, TimeLogs, LeaveApplications
```

### 欄位名：snake_case
```sql
user_id, company_name, created_at, is_deleted
```

### 標準欄位（所有表）⭐ 完整版

```sql
-- 所有重要表格都應該有這些欄位
created_at TEXT DEFAULT (datetime('now')),
updated_at TEXT DEFAULT (datetime('now')),
is_deleted BOOLEAN DEFAULT 0,
deleted_at TEXT,                        -- ⭐ 刪除時間
deleted_by INTEGER,                     -- ⭐ 刪除人員

FOREIGN KEY (deleted_by) REFERENCES Users(user_id)
```

**欄位說明：**
```
created_at:  記錄創建時間（自動填入）
updated_at:  記錄更新時間（每次UPDATE時更新）
is_deleted:  軟刪除標記（0=正常，1=已刪除）
deleted_at:  刪除時間（記錄何時刪除，用於復原參考）⭐
deleted_by:  刪除人員（記錄誰刪除的，用於審計）⭐
```

### 軟刪除（完整版）

```sql
-- 刪除時
UPDATE Clients SET 
  is_deleted = 1, 
  deleted_at = datetime('now'),   -- ⭐ 記錄刪除時間
  deleted_by = ?                  -- ⭐ 記錄刪除人員
WHERE client_id = ?

-- 查詢時（排除已刪除）
SELECT * FROM Clients WHERE is_deleted = 0

-- 查詢刪除記錄（審計用）
SELECT 
  client_id,
  company_name,
  deleted_at,
  u.name as deleted_by_name
FROM Clients
JOIN Users u ON Clients.deleted_by = u.user_id
WHERE is_deleted = 1
ORDER BY deleted_at DESC

-- 復原刪除
UPDATE Clients SET 
  is_deleted = 0,
  deleted_at = NULL,
  deleted_by = NULL
WHERE client_id = ?
```

**軟刪除的好處：**
- ✅ 可復原誤刪的資料
- ✅ 保留歷史記錄（審計追蹤）
- ✅ 關聯資料不會破裂
- ✅ 可查詢「誰在何時刪除了什麼」

---

## 🎨 前端規範

### 組件命名：PascalCase
```
ClientList.vue
TaskBoard.vue
StyledButton.vue
```

### Props：camelCase（定義），kebab-case（使用）
```vue
<script setup>
defineProps({
  clientId: String,
  showActions: Boolean
});
</script>

<template>
  <ChildComponent 
    :client-id="id"
    :show-actions="true"
  />
</template>
```

### 統一組件
```
StyledButton    - 所有按鈕
StyledInput     - 所有輸入框
Modal           - 所有彈窗
DataTable       - 所有表格
Pagination      - 所有分頁
```

---

## 🔧 後端規範

### 三層架構
```
Route 層    - 接收請求、驗證權限、調用 Service
  ↓
Service 層  - 業務邏輯、驗證、權限過濾
  ↓
Repository 層 - 執行 SQL、返回資料
```

### SQL 注入防護（極其重要！）

**❌ 錯誤示例（絕對禁止）：**
```typescript
// 字符串拼接 - 易受 SQL 注入攻擊
const sql = `SELECT * FROM Clients WHERE company_name = '${name}'`;
const result = await db.query(sql);

// 攻擊示例：
// name = "' OR '1'='1"
// 實際執行：SELECT * FROM Clients WHERE company_name = '' OR '1'='1'
// 結果：返回所有客戶！
```

**✅ 正確示例（必須使用）：**
```typescript
// 參數化查詢 - 安全
const sql = `SELECT * FROM Clients WHERE company_name = ?`;
const result = await db.prepare(sql).bind(name).all();

// 多個參數
const sql = `
  SELECT * FROM Clients 
  WHERE company_name LIKE ? 
    AND assignee_user_id = ?
    AND is_deleted = 0
`;
const result = await db.prepare(sql)
  .bind(`%${searchTerm}%`, userId)
  .all();

// INSERT 示例
const sql = `
  INSERT INTO Clients (client_id, company_name, assignee_user_id)
  VALUES (?, ?, ?)
`;
await db.prepare(sql)
  .bind(clientId, companyName, assigneeUserId)
  .run();

// UPDATE 示例
const sql = `
  UPDATE Clients 
  SET company_name = ?, phone = ?, updated_at = datetime('now')
  WHERE client_id = ?
`;
await db.prepare(sql)
  .bind(companyName, phone, clientId)
  .run();
```

**Repository 層標準模板：**
```typescript
class ClientRepository {
  private db: D1Database;
  
  // 查詢列表
  async findAll(filters: any) {
    let sql = `
      SELECT * FROM Clients 
      WHERE is_deleted = 0
    `;
    const params = [];
    
    // 動態條件（仍使用參數化）
    if (filters.company_name) {
      sql += ` AND company_name LIKE ?`;
      params.push(`%${filters.company_name}%`);
    }
    
    if (filters.assignee_user_id) {
      sql += ` AND assignee_user_id = ?`;
      params.push(filters.assignee_user_id);
    }
    
    sql += ` ORDER BY created_at DESC LIMIT ? OFFSET ?`;
    params.push(filters.limit || 50, filters.offset || 0);
    
    return await this.db.prepare(sql).bind(...params).all();
  }
  
  // 查詢單個
  async findById(clientId: string) {
    const sql = `
      SELECT * FROM Clients 
      WHERE client_id = ? AND is_deleted = 0
    `;
    return await this.db.prepare(sql).bind(clientId).first();
  }
  
  // 創建
  async create(data: any) {
    const sql = `
      INSERT INTO Clients (
        client_id, company_name, assignee_user_id, 
        phone, email, remarks
      ) VALUES (?, ?, ?, ?, ?, ?)
    `;
    await this.db.prepare(sql).bind(
      data.client_id,
      data.company_name,
      data.assignee_user_id,
      data.phone || null,
      data.email || null,
      data.remarks || null
    ).run();
    
    return await this.findById(data.client_id);
  }
  
  // 更新
  async update(clientId: string, data: any) {
    const sql = `
      UPDATE Clients 
      SET company_name = ?,
          phone = ?,
          email = ?,
          remarks = ?,
          updated_at = datetime('now')
      WHERE client_id = ?
    `;
    await this.db.prepare(sql).bind(
      data.company_name,
      data.phone,
      data.email,
      data.remarks,
      clientId
    ).run();
    
    return await this.findById(clientId);
  }
  
  // 軟刪除
  async delete(clientId: string) {
    const sql = `
      UPDATE Clients 
      SET is_deleted = 1,
          deleted_at = datetime('now')
      WHERE client_id = ?
    `;
    await this.db.prepare(sql).bind(clientId).run();
  }
}
```

**核心原則：**
1. ✅ **永遠使用參數化查詢（? 占位符）**
2. ✅ **永遠使用 .bind() 綁定參數**
3. ❌ **絕對不要字符串拼接 SQL**
4. ❌ **絕對不要信任用戶輸入**

### CRUD 流程
```
Create:
1. 驗證必填欄位
2. 檢查唯一性
3. 插入資料
4. 返回結果

Read:
1. 權限過濾（員工看自己）
2. 應用搜尋條件
3. 應用分頁
4. 返回結果

Update:
1. 檢查資源存在
2. 驗證權限
3. 更新資料
4. 返回結果

Delete:
1. 檢查資源存在
2. 驗證權限（通常僅管理員）
3. 軟刪除（is_deleted = 1）
4. 返回結果
```

---

## ✅ 開發檢查清單

每個功能實現後，確認：

- [ ] API 響應格式符合標準
- [ ] HTTP 狀態碼正確
- [ ] 錯誤處理完整
- [ ] 權限控制正確（管理員/員工）
- [ ] 資料範圍過濾正確（員工只看自己）
- [ ] 軟刪除（不實際刪除）
- [ ] 所有表都有 created_at, is_deleted
- [ ] 使用參數化查詢（防 SQL 注入）
- [ ] 前端使用共用組件
- [ ] 測試通過

---

## 📊 系統統計（v3.2）

### 資料表總計

| 類別 | 數量 |
|------|------|
| 核心業務 | 6 |
| 工時管理 | 4 |
| 假期管理 | 7 |
| 任務管理 | 3 |
| 知識管理 | 4 |
| 外部內容 | 2 |
| 業務規則 | 2 |
| **薪資管理** | **6** |
| **管理成本** | **2** |
| **收據收款** | **4** |
| **附件系統** | **1** |
| **總計** | **45** |

### API 端點總計

| 類別 | 數量 |
|------|------|
| 認證與用戶 | 12 |
| 客戶管理 | 8 |
| 工時管理 | 12 |
| 假期管理 | 14 |
| 任務管理 | 16 |
| 知識管理 | 10 |
| 外部內容 | 8 |
| 業務規則 | 6 |
| 服務管理 | 6 |
| **薪資管理** | **13** |
| **管理成本** | **6** |
| **收據收款** | **10** |
| **附件系統** | **4** |
| **報表分析** | **6** |
| **總計** | **147** |

### 功能模組總計

**14個主要模組：**
1. 認證與用戶管理
2. 客戶管理
3. 工時管理
4. 假期管理
5. 任務管理
6. 知識管理
7. 外部內容管理
8. 業務規則管理
9. 服務管理
10. **薪資管理**（新增）
11. **管理成本**（新增）
12. **收據收款**（新增）
13. **附件系統**（新增）
14. **報表分析**（新增）

---

**這是所有開發指南都要遵循的統一標準。**

