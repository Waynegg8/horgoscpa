# 系統進階功能

**給 AI：** API版本管理、測試、日志、性能優化、缓存策略的完整說明

---

## 📦 API 版本演進策略

### 版本命名規範

```
/api/v1/*  - 第一版 API
/api/v2/*  - 第二版 API（重大更新）

版本號規則：
- 主版本號（v1, v2）- 不兼容的變更
- 次版本號在 API 路徑中不體現（向後兼容的新功能）
```

### 版本升級策略

```typescript
// 1. 新版本與舊版本並行運行
app.get('/api/v1/clients', v1ClientsHandler);
app.get('/api/v2/clients', v2ClientsHandler);

// 2. 在響應頭中標示版本
c.header('X-API-Version', 'v1');
c.header('X-API-Deprecated', 'This API version will be deprecated on 2026-01-01');

// 3. 版本判斷中間件
async function apiVersionMiddleware(c, next) {
  const requestedVersion = c.req.path.split('/')[2];  // 從 /api/v1/ 提取 v1
  
  if (requestedVersion === 'v1' && new Date() > new Date('2026-01-01')) {
    return c.json({
      success: false,
      error: {
        code: 'VERSION_DEPRECATED',
        message: 'API v1 已停止服務，請升級至 v2'
      }
    }, 410);
  }
  
  await next();
}
```

### 向後兼容性保證

```typescript
// 新增字段（向後兼容）✅
// v1 回應
{
  "client_id": "123",
  "company_name": "測試公司"
}

// v2 回應（新增字段）
{
  "client_id": "123",
  "company_name": "測試公司",
  "industry": "會計服務",  // 新字段
  "rating": "A"            // 新字段
}

// 字段重命名（不兼容）❌ → 需要新版本
// v1: { "company_name": "..." }
// v2: { "name": "..." }  // 需要升級到 v2
```

### 棄用通知機制

```typescript
// 1. 提前 6 個月通知
const deprecationDate = new Date('2026-01-01');
const now = new Date();

if (now > deprecationDate.setMonth(deprecationDate.getMonth() - 6)) {
  c.header('Warning', '299 - "API v1 will be deprecated on 2026-01-01"');
}

// 2. 日誌記錄使用情況
logger.info('Deprecated API called', {
  version: 'v1',
  endpoint: '/api/v1/clients',
  user_id: user.user_id,
  client_ip: c.req.header('CF-Connecting-IP')
});

// 3. 發送通知給管理員
if (deprecatedAPIUsageCount > 1000) {
  await sendAdminNotification({
    type: 'deprecated_api_usage',
    message: 'API v1 仍有大量使用，需加速遷移'
  });
}
```

---

## 🧪 完整測試體系

### 1. 單元測試（Vitest）

```typescript
// tests/unit/services/ClientService.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { ClientService } from '@/services/ClientService';

describe('ClientService', () => {
  let clientService: ClientService;
  let mockDb: any;
  
  beforeEach(() => {
    mockDb = {
      prepare: vi.fn(),
      // ... mock DB
    };
    clientService = new ClientService(mockDb);
  });
  
  it('應該正確過濾員工權限', async () => {
    const user = { user_id: 1, is_admin: false };
    const filters = {};
    
    const result = await clientService.getClients(filters, user);
    
    // 驗證員工只能看到自己的客戶
    expect(mockDb.prepare).toHaveBeenCalledWith(
      expect.stringContaining('assignee_user_id = ?')
    );
  });
  
  it('應該拒絕員工新增其他人的客戶', async () => {
    const user = { user_id: 1, is_admin: false };
    const data = { assignee_user_id: 2 };
    
    await expect(
      clientService.createClient(data, user)
    ).rejects.toThrow('權限不足');
  });
  
  it('應該正確計算補休時數（FIFO）', async () => {
    const availableLeaves = [
      { compe_leave_id: 1, hours_remaining: 4.0, earned_date: '2025-10-01' },
      { compe_leave_id: 2, hours_remaining: 8.0, earned_date: '2025-10-15' }
    ];
    
    const result = await useCompensatoryLeave(1, 6.0, '2025-10-28');
    
    // 應該先用完第一筆（4小時），然後用第二筆（2小時）
    expect(result.used_compensatory_leaves).toHaveLength(2);
    expect(result.used_compensatory_leaves[0].hours_used).toBe(4.0);
    expect(result.used_compensatory_leaves[1].hours_used).toBe(2.0);
  });
});
```

### 2. API 集成測試

```typescript
// tests/integration/api/clients.test.ts
import { describe, it, expect } from 'vitest';
import { app } from '@/index';

describe('GET /api/v1/clients', () => {
  it('應該返回 401 當未登入', async () => {
    const res = await app.request('/api/v1/clients');
    expect(res.status).toBe(401);
  });
  
  it('應該返回客戶列表當已登入', async () => {
    const token = await getTestToken({ user_id: 1, is_admin: true });
    
    const res = await app.request('/api/v1/clients', {
      headers: { 'Cookie': `token=${token}` }
    });
    
    expect(res.status).toBe(200);
    const data = await res.json();
    expect(data.success).toBe(true);
    expect(Array.isArray(data.data)).toBe(true);
  });
  
  it('應該正確處理 N+1 查詢（使用 JOIN）', async () => {
    const queryCount = getQueryCount();
    
    const token = await getTestToken({ user_id: 1, is_admin: true });
    const res = await app.request('/api/v1/clients', {
      headers: { 'Cookie': `token=${token}` }
    });
    
    // 應該只有一次查詢（JOIN 優化）
    expect(getQueryCount() - queryCount).toBe(1);
  });
});
```

### 3. E2E 測試（Playwright）

```typescript
// tests/e2e/client-management.spec.ts
import { test, expect } from '@playwright/test';

test.describe('客戶管理流程', () => {
  test.beforeEach(async ({ page }) => {
    // 登入
    await page.goto('/login');
    await page.fill('[name="username"]', 'admin');
    await page.fill('[name="password"]', 'password');
    await page.click('[data-test="login-button"]');
    await page.waitForURL('/dashboard');
  });
  
  test('應該成功新增客戶', async ({ page }) => {
    // 進入客戶管理頁面
    await page.goto('/clients');
    
    // 點擊新增按鈕
    await page.click('[data-test="add-client"]');
    
    // 填寫表單
    await page.fill('[name="client_id"]', '12345678');
    await page.fill('[name="company_name"]', '測試公司 E2E');
    await page.selectOption('[name="assignee_user_id"]', '1');
    
    // 提交
    await page.click('[data-test="submit"]');
    
    // 驗證成功提示
    await expect(page.locator('.toast.success')).toBeVisible();
    await expect(page.locator('.toast.success')).toContainText('新增成功');
    
    // 驗證列表中出現新客戶
    await expect(page.locator('.client-list')).toContainText('測試公司 E2E');
  });
  
  test('應該顯示加載狀態', async ({ page }) => {
    await page.goto('/clients');
    
    // 應該看到加載指示器
    const loader = page.locator('[data-test="loading-spinner"]');
    await expect(loader).toBeVisible();
    
    // 加載完成後消失
    await expect(loader).not.toBeVisible();
  });
  
  test('應該正確顯示錯誤訊息', async ({ page }) => {
    await page.goto('/clients');
    await page.click('[data-test="add-client"]');
    
    // 不填寫必填欄位直接提交
    await page.click('[data-test="submit"]');
    
    // 應該顯示錯誤訊息
    const errorMessage = page.locator('[data-test="error-message"]');
    await expect(errorMessage).toBeVisible();
    await expect(errorMessage).toContainText('公司名稱為必填');
  });
});
```

### 測試覆蓋率目標

```
核心業務邏輯：   90%+
API 端點：       80%+
前端組件：       70%+
整體覆蓋率：     75%+
```

---

## 📋 結構化日誌系統

### 日誌級別

```typescript
enum LogLevel {
  DEBUG = 'debug',
  INFO = 'info',
  WARN = 'warn',
  ERROR = 'error',
  FATAL = 'fatal'
}
```

### 日誌格式

```typescript
interface LogEntry {
  timestamp: string;         // ISO 8601
  level: LogLevel;
  message: string;
  context?: {
    user_id?: number;
    client_id?: string;
    request_id?: string;
    ip_address?: string;
    user_agent?: string;
  };
  error?: {
    name: string;
    message: string;
    stack?: string;
  };
  metadata?: any;
}
```

### Logger 實現

```typescript
class Logger {
  private context: any = {};
  
  constructor(defaultContext = {}) {
    this.context = defaultContext;
  }
  
  private log(level: LogLevel, message: string, metadata?: any) {
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      context: this.context,
      metadata
    };
    
    console.log(JSON.stringify(entry));
    
    // 發送到日誌服務（Cloudflare Logpush、Sentry等）
    if (level === 'error' || level === 'fatal') {
      this.sendToErrorTracking(entry);
    }
  }
  
  debug(message: string, metadata?: any) {
    this.log(LogLevel.DEBUG, message, metadata);
  }
  
  info(message: string, metadata?: any) {
    this.log(LogLevel.INFO, message, metadata);
  }
  
  warn(message: string, metadata?: any) {
    this.log(LogLevel.WARN, message, metadata);
  }
  
  error(message: string, error?: Error, metadata?: any) {
    this.log(LogLevel.ERROR, message, {
      ...metadata,
      error: error ? {
        name: error.name,
        message: error.message,
        stack: error.stack
      } : undefined
    });
  }
  
  fatal(message: string, error?: Error, metadata?: any) {
    this.log(LogLevel.FATAL, message, {
      ...metadata,
      error: error ? {
        name: error.name,
        message: error.message,
        stack: error.stack
      } : undefined
    });
  }
  
  private async sendToErrorTracking(entry: LogEntry) {
    // 發送到 Sentry
    if (typeof Sentry !== 'undefined') {
      Sentry.captureException(new Error(entry.message), {
        level: entry.level as any,
        contexts: {
          custom: entry.context
        }
      });
    }
  }
}

// 使用示例
const logger = new Logger({ service: 'timesheet-api' });

logger.info('Client created', {
  client_id: '12345678',
  company_name: '測試公司',
  duration_ms: 150
});

logger.error('Database query failed', error, {
  query: 'SELECT * FROM Clients',
  params: ['12345678']
});
```

### 慢查詢監控

```typescript
async function queryWithLogging(sql: string, params: any[]) {
  const startTime = Date.now();
  
  try {
    const result = await db.prepare(sql).bind(...params).all();
    const duration = Date.now() - startTime;
    
    if (duration > 1000) {
      logger.warn('Slow query detected', {
        sql,
        params,
        duration_ms: duration
      });
    }
    
    return result;
  } catch (error) {
    logger.error('Query failed', error, { sql, params });
    throw error;
  }
}
```

---

## ⚡ 多層緩存策略

### 1. CDN 緩存（Cloudflare）

```typescript
// 靜態資源緩存
app.get('/assets/*', (c) => {
  c.header('Cache-Control', 'public, max-age=31536000, immutable');
  return c.file(path);
});

// API 響應緩存（不常變的數據）
app.get('/api/v1/leave-types', async (c) => {
  c.header('Cache-Control', 'public, max-age=3600');  // 1小時
  return c.json(await getLeaveTypes());
});
```

### 2. Workers KV 緩存

```typescript
class CacheService {
  constructor(private kv: KVNamespace) {}
  
  async get<T>(key: string): Promise<T | null> {
    const cached = await this.kv.get(key, 'json');
    if (cached) {
      logger.debug('Cache hit', { key });
      return cached as T;
    }
    logger.debug('Cache miss', { key });
    return null;
  }
  
  async set<T>(key: string, value: T, expirationTtl?: number) {
    await this.kv.put(key, JSON.stringify(value), { expirationTtl });
    logger.debug('Cache set', { key, ttl: expirationTtl });
  }
  
  async delete(key: string) {
    await this.kv.delete(key);
    logger.debug('Cache deleted', { key });
  }
}

// 使用示例
const cache = new CacheService(env.CACHE_KV);

async function getLeaveBalance(userId: number) {
  const cacheKey = `leave_balance:${userId}`;
  
  // 嘗試從緩存獲取
  let balance = await cache.get<any>(cacheKey);
  
  if (!balance) {
    // 緩存未命中，從數據庫查詢
    balance = await calculateLeaveBalance(userId);
    
    // 寫入緩存（1小時過期）
    await cache.set(cacheKey, balance, 3600);
  }
  
  return balance;
}
```

### 3. 緩存失效策略

```typescript
// 數據更新時清除緩存
async function updateClient(clientId: string, data: any) {
  await db.prepare(`UPDATE Clients SET ... WHERE client_id = ?`).bind(clientId).run();
  
  // 清除相關緩存
  await cache.delete(`client:${clientId}`);
  await cache.delete(`clients:list:*`);  // 清除所有列表緩存
}

// 時間失效（TTL）
await cache.set('data', value, 3600);  // 1小時後自動過期

// 主動失效
async function clearAllClientCaches() {
  const keys = await getAllCacheKeys('client:*');
  for (const key of keys) {
    await cache.delete(key);
  }
}
```

---

## 🚀 前端性能優化

### 1. 代碼分割

```javascript
// vite.config.js
export default {
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          'vendor': ['vue', 'vue-router'],
          'ui': ['tailwindcss'],
          'charts': ['echarts'],
        }
      }
    }
  }
}

// 路由懶加載
const routes = [
  {
    path: '/clients',
    component: () => import('./pages/ClientsPage.vue')
  }
];
```

### 2. 虛擬滾動

```vue
<template>
  <virtual-scroller
    :items="clients"
    :item-height="60"
    class="client-list"
  >
    <template #default="{ item }">
      <ClientRow :client="item" />
    </template>
  </virtual-scroller>
</template>
```

### 3. 圖片優化

```html
<!-- 懶加載 -->
<img loading="lazy" src="..." />

<!-- 響應式圖片 -->
<img 
  srcset="image-320w.jpg 320w, image-640w.jpg 640w, image-1280w.jpg 1280w"
  sizes="(max-width: 640px) 100vw, 50vw"
  src="image-640w.jpg"
/>
```

---

**這個文檔涵蓋了系統的進階功能設計。**

