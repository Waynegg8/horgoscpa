# 工時管理 - 完整開發規格

**給 AI：** 實現工時管理功能的完整技術規格

---

## 💾 資料表

### TimeLogs
```sql
CREATE TABLE TimeLogs (
  log_id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  work_date TEXT NOT NULL,              -- YYYY-MM-DD
  client_id TEXT,                       -- 客戶（工作時）
  service_id INTEGER,                   -- 服務項目
  work_type_id INTEGER NOT NULL,        -- 工作類型
  hours REAL NOT NULL,                  -- 實際工時
  weighted_hours REAL,                  -- 加權工時（自動計算）
  leave_type_id INTEGER,                -- 假別（請假時）
  notes TEXT,
  created_at TEXT DEFAULT (datetime('now')),
  updated_at TEXT DEFAULT (datetime('now')),
  is_deleted BOOLEAN DEFAULT 0,
  deleted_at TEXT,                       -- ⭐ 刪除時間
  deleted_by INTEGER,                    -- ⭐ 刪除人員
  
  FOREIGN KEY (user_id) REFERENCES Users(user_id),
  FOREIGN KEY (client_id) REFERENCES Clients(client_id),
  FOREIGN KEY (service_id) REFERENCES Services(service_id),
  FOREIGN KEY (work_type_id) REFERENCES WorkTypes(work_type_id),
  FOREIGN KEY (leave_type_id) REFERENCES LeaveTypes(leave_type_id),
  FOREIGN KEY (deleted_by) REFERENCES Users(user_id)
);

CREATE INDEX idx_timelogs_user_date ON TimeLogs(user_id, work_date);
CREATE INDEX idx_timelogs_client ON TimeLogs(client_id);
CREATE INDEX idx_timelogs_client_date ON TimeLogs(client_id, work_date);  -- ⭐ 客戶成本分析專用
CREATE INDEX idx_timelogs_date ON TimeLogs(work_date);  -- ⭐ 日期範圍查詢專用
```

**索引使用說明：**
```
idx_timelogs_user_date:
  用途：員工個人工時查詢
  查詢：WHERE user_id = ? AND work_date BETWEEN ? AND ?
  
idx_timelogs_client:
  用途：客戶工時列表
  查詢：WHERE client_id = ?
  
idx_timelogs_client_date: ⭐ 新增
  用途：客戶成本分析（最常用）
  查詢：WHERE client_id = ? AND work_date BETWEEN ? AND ?
  效能提升：約50-80%（避免全表掃描）
  
idx_timelogs_date: ⭐ 新增
  用途：月度報表、日期範圍統計
  查詢：WHERE work_date BETWEEN ? AND ?
```

### WorkTypes（工作類型）
```sql
CREATE TABLE WorkTypes (
  work_type_id INTEGER PRIMARY KEY AUTOINCREMENT,
  type_name TEXT UNIQUE NOT NULL,
  rate_multiplier REAL NOT NULL,  -- 費率倍數
  is_overtime BOOLEAN DEFAULT 0,
  generates_comp_leave BOOLEAN DEFAULT 0,  -- 是否產生補休
  sort_order INTEGER DEFAULT 0
);

-- 預設資料（共11種工作類型）
INSERT INTO WorkTypes VALUES
  (1, '正常工時', 1.0, 0, 0, 0),
  (2, '平日加班（前2小時）', 1.34, 1, 1, 1),
  (3, '平日加班（後2小時）', 1.67, 1, 1, 2),
  (4, '休息日加班（前2小時）', 1.34, 1, 1, 3),
  (5, '休息日加班（第3-8小時）', 1.67, 1, 1, 4),
  (6, '休息日加班（第9-12小時）', 2.67, 1, 1, 5),
  (7, '國定假日加班（8小時內）', 2.0, 1, 1, 6),
  (8, '國定假日加班（第9-10小時）', 1.34, 1, 1, 7),
  (9, '國定假日加班（第11-12小時）', 1.67, 1, 1, 8),
  (10, '例假日加班（8小時內）', 2.0, 1, 1, 9),
  (11, '例假日加班（第9-12小時）', 2.0, 1, 1, 10);
```


### CompensatoryLeave（補休餘額）
```sql
CREATE TABLE CompensatoryLeave (
  compe_leave_id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  hours_earned REAL NOT NULL,           -- 累積的補休時數
  hours_remaining REAL NOT NULL,        -- 剩餘補休時數
  earned_date TEXT NOT NULL,            -- 累積日期（用於 FIFO）
  expiry_date TEXT NOT NULL,            -- 到期日（當月有效，次月1日歸0）
  source_timelog_id INTEGER,            -- 來源工時記錄
  status TEXT DEFAULT 'active',         -- active, expired, used, converted
  converted_to_payment BOOLEAN DEFAULT 0,  -- 是否已轉加班費
  conversion_date TEXT,                 -- 轉換日期
  conversion_rate REAL,                 -- 轉換時的費率
  created_at TEXT DEFAULT (datetime('now')),
  is_deleted BOOLEAN DEFAULT 0,
  
  FOREIGN KEY (user_id) REFERENCES Users(user_id),
  FOREIGN KEY (source_timelog_id) REFERENCES TimeLogs(log_id)
);

CREATE INDEX idx_compe_leave_user ON CompensatoryLeave(user_id);
CREATE INDEX idx_compe_leave_status ON CompensatoryLeave(status);
CREATE INDEX idx_compe_leave_expiry ON CompensatoryLeave(expiry_date);
CREATE INDEX idx_compe_leave_earned_date ON CompensatoryLeave(earned_date);
```

### CompensatoryLeaveUsage（補休使用記錄）
```sql
CREATE TABLE CompensatoryLeaveUsage (
  usage_id INTEGER PRIMARY KEY AUTOINCREMENT,
  compe_leave_id INTEGER NOT NULL,
  leave_application_id INTEGER,         -- 關聯請假申請
  timelog_id INTEGER,                   -- 關聯工時記錄（請假）
  hours_used REAL NOT NULL,
  used_date TEXT NOT NULL,
  created_at TEXT DEFAULT (datetime('now')),
  
  FOREIGN KEY (compe_leave_id) REFERENCES CompensatoryLeave(compe_leave_id),
  FOREIGN KEY (leave_application_id) REFERENCES LeaveApplications(leave_id),
  FOREIGN KEY (timelog_id) REFERENCES TimeLogs(log_id)
);

CREATE INDEX idx_compe_usage_leave ON CompensatoryLeaveUsage(compe_leave_id);
CREATE INDEX idx_compe_usage_date ON CompensatoryLeaveUsage(used_date);
```

---

## 🔌 API 端點

### 1. 查詢工時記錄
```
GET /api/v1/timelogs
Query: ?start_date=2025-11-01&end_date=2025-11-30&user_id=1
權限：所有人（員工自動過濾）
```

### 2. 新增工時
```
POST /api/v1/timelogs
權限：所有人（只能新增自己的）
```

**請求 Body（工作）：**
```json
{
  "work_date": "2025-11-01",
  "client_id": "12345678",
  "service_id": 1,
  "work_type_id": 1,
  "hours": 8.5,
  "notes": "整理傳票"
}
```

**請求 Body（請假）：**
```json
{
  "work_date": "2025-11-02",
  "leave_type_id": 1,
  "hours": 8,
  "notes": "特休"
}
```

### 3. 計算加權工時
```
POST /api/v1/weighted-hours/calculate
```

**請求：**
```json
{
  "user_id": 1,
  "start_date": "2025-11-01",
  "end_date": "2025-11-30"
}

### 4. 補休管理 API
```
GET  /api/v1/compensatory-leave           查詢補休餘額
POST /api/v1/compensatory-leave/use      使用補休
POST /api/v1/compensatory-leave/convert  轉換為加班費
GET  /api/v1/compensatory-leave/history  查詢使用歷史
```

**查詢補休餘額：**
```json
GET /api/v1/compensatory-leave?user_id=1

// 回應
{
  "success": true,
  "data": {
    "user_id": 1,
    "total_hours": 16.5,
    "details": [
      {
        "compe_leave_id": 1,
        "hours_remaining": 8.0,
        "earned_date": "2025-10-15",
        "expiry_date": "2025-10-31",
        "status": "active",
        "days_until_expiry": 3
      },
      {
        "compe_leave_id": 2,
        "hours_remaining": 8.5,
        "earned_date": "2025-10-20",
        "expiry_date": "2025-10-31",
        "status": "active",
        "days_until_expiry": 3
      }
    ],
    "expiring_soon": [
      {
        "compe_leave_id": 1,
        "hours_remaining": 8.0,
        "expiry_date": "2025-10-31"
      }
    ]
  }
}
```

**使用補休（FIFO）：**
```json
POST /api/v1/compensatory-leave/use
{
  "user_id": 1,
  "hours": 4.0,
  "use_date": "2025-10-28",
  "leave_application_id": 123
}

// 回應
{
  "success": true,
  "data": {
    "used_compensatory_leaves": [
      {
        "compe_leave_id": 1,
        "hours_used": 4.0,
        "hours_remaining": 4.0
      }
    ],
    "total_hours_used": 4.0,
    "remaining_total": 12.5
  }
}
```

**轉換為加班費：**
```json
POST /api/v1/compensatory-leave/convert
{
  "compe_leave_ids": [1, 2],
  "conversion_rate": 1.34  // 當前加班費率
}

// 回應
{
  "success": true,
  "data": {
    "total_hours_converted": 16.5,
    "conversion_rate": 1.34,
    "payment_amount": 22.11,  // 16.5 * 1.34
    "converted_leaves": [
      { "compe_leave_id": 1, "hours": 8.0 },
      { "compe_leave_id": 2, "hours": 8.5 }
    ]
  }
}
```

**響應：**
```json
{
  "success": true,
  "data": {
    "total_hours": 160,
    "weighted_hours": 185.5,
    "breakdown": {
      "normal": 152,
      "overtime_weekday": 8
    }
  }
}
```

---

## 🎨 前端組件

### TimesheetPage.vue（Excel風格）
```vue
<template>
  <div class="timesheet-page">
    <h1>工時表 - {{ currentMonth }}</h1>
    
    <!-- 週選擇器 -->
    <div class="week-selector">
      <button @click="prevWeek">←</button>
      <span>{{ weekRange }}</span>
      <button @click="nextWeek">→</button>
    </div>

    <!-- Excel 風格表格 -->
    <table class="timesheet-grid">
      <thead>
        <tr>
          <th>日期</th>
          <th>客戶</th>
          <th>服務</th>
          <th>工時</th>
          <th>類型</th>
          <th>備註</th>
        </tr>
      </thead>
      <tbody>
        <tr v-for="day in weekDays" :key="day">
          <td>
            {{ day }}
            <!-- ⭐ 補班日標記 -->
            <span v-if="isMakeupWorkday(day)" class="makeup-badge" title="補班日（正常上班日）">
              📅 補班
            </span>
          </td>
          <td>
            <select v-model="logs[day].client_id">
              <option v-for="c in clients" :value="c.client_id">
                {{ c.company_name }}
              </option>
            </select>
          </td>
          <td>
            <select v-model="logs[day].service_id">
              <option v-for="s in services" :value="s.service_id">
                {{ s.service_name }}
              </option>
            </select>
          </td>
          <td>
            <input 
              v-model.number="logs[day].hours" 
              type="number"
              step="0.5"
              min="0"
              max="12"
              @blur="validateHours(day)"
            />
          </td>
          <td>
            <!-- ⭐ 工作類型（補班日會自動過濾選項）-->
            <select v-model="logs[day].work_type_id">
              <option 
                v-for="type in getAvailableWorkTypes(day)" 
                :key="type.id"
                :value="type.id"
              >
                {{ type.name }}
              </option>
            </select>
          </td>
          <td>
            <input v-model="logs[day].notes" />
          </td>
        </tr>
      </tbody>
    </table>

    <div class="summary">
      本週總工時：{{ weekTotal }} 小時
      加權工時：{{ weekWeighted }} 小時
    </div>

    <StyledButton @click="saveAll">儲存</StyledButton>
  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue';
import { getClients, getServices, createTimeLog, getHolidays } from '@/api';

const logs = ref({});
const clients = ref([]);
const services = ref([]);
const holidays = ref([]);  // ⭐ 國定假日+補班日

const weekTotal = computed(() => {
  return Object.values(logs.value).reduce((sum, log) => sum + (log.hours || 0), 0);
});

onMounted(async () => {
  // ⭐ 載入本月的國定假日和補班日
  holidays.value = await getHolidays({
    start_date: currentMonthStart,
    end_date: currentMonthEnd
  });
});

// ⭐ 檢查是否為補班日
function isMakeupWorkday(date) {
  const holiday = holidays.value.find(h => h.holiday_date === date);
  return holiday?.is_makeup_workday || false;
}

// ⭐ 取得可用的工作類型選項（補班日會過濾）
function getAvailableWorkTypes(date) {
  const allTypes = [
    { id: 1, name: '正常工時' },
    { id: 2, name: '平日加班（前2小時）' },
    { id: 3, name: '平日加班（後2小時）' },
    { id: 4, name: '休息日加班（前2小時）' },
    { id: 5, name: '休息日加班（第3-8小時）' },
    { id: 6, name: '休息日加班（第9-12小時）' },
    { id: 7, name: '國定假日加班（8小時內）' },
    // ... 其他類型
  ];
  
  if (isMakeupWorkday(date)) {
    // ⭐ 補班日：只顯示正常工時和平日加班
    return allTypes.filter(t => [1, 2, 3].includes(t.id));
  }
  
  return allTypes;  // 一般日期：顯示所有選項
}

// ⭐ 驗證工時（前端）
function validateHours(day) {
  const hours = logs.value[day]?.hours;
  
  if (!hours) return true;
  
  // 檢查是否為0.5的倍數
  if (hours % 0.5 !== 0) {
    alert('工時必須是0.5的倍數（如：0.5、1.0、1.5、2.0...）');
    logs.value[day].hours = Math.round(hours * 2) / 2;  // 自動修正為最接近的0.5倍數
    return false;
  }
  
  // 檢查範圍
  if (hours < 0) {
    alert('工時不可為負數');
    logs.value[day].hours = 0;
    return false;
  }
  
  if (hours > 12) {
    alert('每日工時上限為12小時（勞基法規定）');
    logs.value[day].hours = 12;
    return false;
  }
  
  return true;
}

async function saveAll() {
  // 驗證所有工時
  for (const day in logs.value) {
    if (!validateHours(day)) {
      return;  // 驗證失敗，停止儲存
    }
  }
  
  // 儲存邏輯...
}
</script>
```

---

## 🔧 後端實現

### TimeLogService
```typescript
class TimeLogService {
  async getTimeLogs(filters, user) {
    // 員工只能看自己
    if (!user.is_admin) {
      filters.user_id = user.user_id;
    }
    
    return await this.repository.findAll(filters);
  }
  
  async createTimeLog(data, user) {
    // 員工只能新增自己的
    if (!user.is_admin && data.user_id !== user.user_id) {
      throw new ForbiddenError('只能新增自己的工時');
    }
    
    // 驗證工時範圍
    if (data.hours < 0 || data.hours > 12) {
      throw new ValidationError('工時必須在 0-12 之間');
    }
    
    // 驗證工時精度（必須是0.5的倍數）
    if (data.hours % 0.5 !== 0) {
      throw new ValidationError('工時必須是0.5的倍數（如：0.5、1.0、1.5、2.0...）');
    }
    
    // ⭐ 檢查是否為補班日（防止誤選休息日加班）
    const holiday = await this.db.prepare(`
      SELECT is_makeup_workday FROM Holidays WHERE holiday_date = ?
    `).bind(data.work_date).first();
    
    if (holiday?.is_makeup_workday) {
      // 補班日不可選「休息日加班」類型（4, 5, 6）
      const isRestDayOvertimeType = [4, 5, 6].includes(data.work_type_id);
      
      if (isRestDayOvertimeType) {
        throw new ValidationError(
          '今天是補班日（正常上班日），請選擇「正常工時」或「平日加班」類型',
          'WORK_TYPE_HOURS_MISMATCH'
        );
      }
    }
    
    // ⚠️ 國定假日/例假日「8小時內」類型：最多只能填8小時
    if ((data.work_type_id === 7 || data.work_type_id === 10) && data.hours > 8) {
      throw new ValidationError(
        '工作類型「國定假日8小時內」或「例假日8小時內」的工時不可超過8小時，' +
        '超過部分請分別選擇「第9-10小時」或「第11-12小時」類型'
      );
    }
    
    // 計算加權工時（⚠️ 國定假日/例假日特殊處理）
    const workType = await this.getWorkType(data.work_type_id);
    
    // 國定假日（work_type_id = 7）或例假日（work_type_id = 10）8小時內
    if (data.work_type_id === 7 || data.work_type_id === 10) {
      // ⚠️ 特殊：加權工時統一為 8 小時（不是實際工時 × 2.0）
      data.weighted_hours = 8.0;
    } else {
      // 一般情況：實際工時 × 費率倍數
      data.weighted_hours = data.hours * workType.rate_multiplier;
    }
    
    // 創建
    const log = await this.repository.create(data);
    
    // ⭐ 自動移除工時缺填提醒
    await this.dismissMissingTimesheetNotification(user.user_id, data.work_date);
    
    // 如果是加班，產生補休
    if (data.work_type_id > 1) {
      // ⚠️ 國定假日/例假日 8小時內：產生8小時補休
      let compHours = data.hours;  // 預設：實際工時
      
      if (data.work_type_id === 7 || data.work_type_id === 10) {
        compHours = 8.0;  // 統一產生8小時補休（已經限制不會超過8小時）
      }
      
      await this.generateCompLeave(
        user.user_id, 
        compHours, 
        log.log_id,  // 來源工時記錄ID
        workType.rate_multiplier  // 儲存原始費率
      );
    }
    
    return log;
  }
  
  /**
   * 產生補休記錄
   * ⚠️ 國定假日/例假日8小時內：統一產生8小時補休
   */
  async generateCompLeave(
    userId: number, 
    hours: number, 
    sourceTimelogId: number,
    conversionRate: number
  ) {
    const earnedDate = new Date().toISOString().split('T')[0];
    const expiryDate = this.calculateExpiryDate(earnedDate);
    
    await this.db.prepare(`
      INSERT INTO CompensatoryLeave (
        user_id, hours_earned, hours_remaining, earned_date, 
        expiry_date, source_timelog_id, conversion_rate, status
      ) VALUES (?, ?, ?, ?, ?, ?, ?, 'active')
    `).bind(
      userId, 
      hours, 
      hours, 
      earnedDate, 
      expiryDate,
      sourceTimelogId,
      conversionRate  // ⚠️ 儲存原始費率，避免後續回溯查詢
    ).run();
  }
  
  /**
   * 自動移除工時缺填提醒
   * ⚠️ 當員工填寫工時後，自動移除該日期的提醒（員工+管理員的提醒都移除）
   */
  async dismissMissingTimesheetNotification(userId: number, workDate: string) {
    // 移除該員工自己的提醒
    await this.db.prepare(`
      UPDATE Notifications
      SET is_deleted = 1
      WHERE user_id = ?
        AND type = 'missing_timesheet'
        AND related_date = ?
        AND auto_dismiss = 1
    `).bind(userId, workDate).run();
    
    // 移除管理員關於該員工的提醒
    await this.db.prepare(`
      UPDATE Notifications
      SET is_deleted = 1
      WHERE type = 'missing_timesheet'
        AND related_date = ?
        AND related_user_id = ?
        AND auto_dismiss = 1
    `).bind(workDate, userId).run();
  }
  
  /**
   * 計算國定假日加班費（特殊處理）
   * ⚠️ 重要：8小時內統一給付8小時工資
   */
  async calculateHolidayOvertimePay(userId: number, hours: number, workTypeId: number): number {
    const user = await this.getUserSalary(userId);
    const hourlyBase = user.monthly_salary / 240;
    
    // 國定假日加班（8小時內）- work_type_id = 7
    if (workTypeId === 7) {
      // 不論實際工作幾小時，統一給付 8 小時 × 2.0 倍
      return hourlyBase * 8 * 2.0;
    }
    
    // 國定假日加班（第9-10小時）- work_type_id = 8
    if (workTypeId === 8) {
      return hourlyBase * hours * 1.34;
    }
    
    // 國定假日加班（第11-12小時）- work_type_id = 9
    if (workTypeId === 9) {
      return hourlyBase * hours * 1.67;
    }
    
    // 其他類型：實際時數 × 費率
    const rate = await this.getOvertimeRate(workTypeId);
    return hourlyBase * hours * rate.rate_multiplier;
  }
  
  async calculateWeightedHours(userId, startDate, endDate) {
    const logs = await this.repository.findByDateRange(userId, startDate, endDate);
    
    let totalHours = 0;
    let weightedHours = 0;
    
    for (const log of logs) {
      totalHours += log.hours;
      weightedHours += log.weighted_hours;
    }
    
    return { totalHours, weightedHours };
  }
}
```

---

## ✅ 業務規則

### 工時限制
- **每天最多 12 小時**（勞基法規定）⭐
- 工時可以是小數（如 3.5 小時）
- **最小單位 0.5 小時**（必須是0.5的倍數）⭐
- 前後端都需驗證（防止輸入2.3、8.7等非法值）

### 補班日特殊規則 ⭐
- **補班日視為正常上班日**（如：春節前的週六補班）
- 可填寫：正常工時、平日加班
- 不可填寫：休息日加班（會被系統拒絕）
- 前端UI會顯示「📅 補班日」標記
- 範例：
  ```
  2025-02-08（週六，春節補班日）：
  ✅ 可選：正常工時、平日加班（前2h）、平日加班（後2h）
  ❌ 不可選：休息日加班（前2h）、休息日加班（3-8h）
  ```

### 工作類型詳細說明（共11種）

**1. 正常工時（1.0倍）**
- 說明：一般上班時間（每日8小時內）
- 費率：1.0 倍
- 產生補休：❌ 不產生

**2. 平日加班（前2小時，1.34倍）**
- 說明：平日第 9-10 小時的延長工時
- 費率：1.34 倍
- 產生補休：✅ 產生補休（1:1）

**3. 平日加班（後2小時，1.67倍）**
- 說明：平日第 11-12 小時的延長工時
- 費率：1.67 倍
- 產生補休：✅ 產生補休（1:1）

**4. 休息日加班（前2小時，1.34倍）**
- 說明：休息日（通常週六）工作的前2小時
- 費率：1.34 倍
- 產生補休：✅ 產生補休（1:1）

**5. 休息日加班（第3-8小時，1.67倍）**
- 說明：休息日工作的第3-8小時
- 費率：1.67 倍
- 產生補休：✅ 產生補休（1:1）

**6. 休息日加班（第9-12小時，2.67倍）**
- 說明：休息日工作的第9-12小時
- 費率：2.67 倍
- 產生補休：✅ 產生補休（1:1）

**7. 國定假日加班（8小時內，雙倍薪）**
- 說明：國定假日（如端午、中秋、國慶）出勤工作
- 費率：加發 1 日工資（雙倍薪，即使只上 1 小時也算 1 日）
- 產生補休：✅ 產生補休 **8小時**（統一產生，不論實際工作幾小時）⭐
- 加權工時：統一為 **8小時**（不是實際工時 × 2.0）⭐
- ⚠️ **特殊計算：** 8小時內統一給付8小時工資、8小時補休、8小時加權工時

**8. 國定假日加班（第9-10小時，1.34倍）**
- 說明：國定假日工作超過8小時的第9-10小時
- 費率：1.34 倍
- 產生補休：✅ 產生補休（1:1）

**9. 國定假日加班（第11-12小時，1.67倍）**
- 說明：國定假日工作的第11-12小時
- 費率：1.67 倍
- 產生補休：✅ 產生補休（1:1）

**10. 例假日加班（8小時內，雙倍薪+強制補休）**
- 說明：例假日（通常週日）出勤工作
- 費率：加發 1 日工資 + 強制補休 1 天
- 產生補休：✅ 強制產生補休 **8小時**（統一產生，不論實際工作幾小時）⭐
- 加權工時：統一為 **8小時**（不是實際工時 × 2.0）⭐
- ⚠️ **原則上禁止**，僅限天災、事變或突發事件
- ⚠️ **特殊計算：** 與國定假日相同，統一8小時工資、8小時補休、8小時加權工時

**11. 例假日加班（第9-12小時，2.0倍）**
- 說明：例假日工作超過8小時的第9-12小時
- 費率：2.0 倍
- 產生補休：✅ 產生補休（1:1）
- ⚠️ **原則上禁止**

### 加權工時計算
```
一般情況：
  加權工時 = 實際工時 × 費率倍數

  範例：
  正常工時 8小時 × 1.0 = 8小時
  平日加班 2小時 × 1.34 = 2.68小時
  休息日加班 4小時（前2h×1.34+後2h×1.67）= 6.02小時

國定假日/例假日（8小時內）：⚠️ 特殊規則
  加權工時 = 8小時（統一計算，不論實際工作幾小時）

  範例：
  國定假日加班 3小時 → 加權工時 8小時（不是6小時）⭐
  國定假日加班 0.5小時 → 加權工時 8小時 ⭐
  例假日加班 5小時 → 加權工時 8小時 ⭐

國定假日/例假日（超過8小時）：
  加權工時 = 8 + 超過部分的加權計算
  
  範例：
  國定假日加班 10小時 
  = 8小時（前8h統一）+ 2 × 1.34（第9-10h）
  = 8 + 2.68 = 10.68 加權工時

完整範例：
  正常工時 8小時 × 1.0 = 8小時
  平日加班 2小時 × 1.34 = 2.68小時
  國定假日加班 3小時 = 8小時（特殊規則）⭐
  總計：8 + 2.68 + 8 = 18.68 加權工時
```

### 補休產生（⚠️ 重要修正：國定假日/例假日特殊規則）
```
一般加班（平日、休息日）：
  補休產生 = 實際加班時數 × 1（1:1對應）
  
  範例：
  平日加班 2小時 → 產生補休 2小時
  休息日加班 4小時 → 產生補休 4小時

國定假日/例假日（8小時內）：⚠️ 特殊規則
  補休產生 = 8小時（統一產生，不論實際工作幾小時）
  
  範例：
  國定假日加班 3小時 → 產生補休 8小時（不是3小時）⭐
  國定假日加班 0.5小時 → 產生補休 8小時 ⭐
  例假日加班 5小時 → 產生補休 8小時 ⭐

國定假日/例假日（超過8小時）：
  補休產生 = 實際加班時數（恢復1:1對應）
  
  範例：
  國定假日加班 10小時 → 產生補休 10小時
  （第9-10小時按一般規則）

⚠️ 關鍵原則：
- 國定假日/例假日「8小時內」：加班費、補休、加權工時都統一按8小時
- 這確保了「補休 = 加班費」的價值對等（都是8小時工資）
```

### 補休管理規則（重要！）

#### 1. 補休有效期：當月有效，次月1日歸0（可設定）

```typescript
/**
 * 補休產生時自動計算到期日
 * ⚠️ 從 Settings 表讀取規則（可由管理員調整）
 */
async function calculateExpiryDate(earnedDate: string): Promise<string> {
  const date = new Date(earnedDate);
  
  // 讀取補休有效期規則
  const rule = await db.prepare(`
    SELECT setting_value FROM Settings WHERE setting_key = 'comp_leave_expiry_rule'
  `).first();
  
  const expiryRule = rule?.setting_value || 'current_month';  // 預設：當月有效
  
  let expiryDate: Date;
  
  switch (expiryRule) {
    case 'current_month':  // 當月有效（預設）
      expiryDate = new Date(date.getFullYear(), date.getMonth() + 1, 0);
      break;
    
    case 'next_month':  // 次月有效
      expiryDate = new Date(date.getFullYear(), date.getMonth() + 2, 0);
      break;
    
    case '3_months':  // 3個月有效
      expiryDate = new Date(date.getFullYear(), date.getMonth() + 3, 0);
      break;
    
    case '6_months':  // 半年有效
      expiryDate = new Date(date.getFullYear(), date.getMonth() + 6, 0);
      break;
    
    default:
      expiryDate = new Date(date.getFullYear(), date.getMonth() + 1, 0);
  }
  
  return expiryDate.toISOString().split('T')[0];
}

/**
 * 範例（當 expiryRule = 'current_month'）：
 * 2025-10-15 累積的補休 → 2025-10-31 到期（當月底）
 * 2025-10-31 累積的補休 → 2025-10-31 到期（當月底）
 * 2025-11-01 累積的補休 → 2025-11-30 到期（當月底）
 * 
 * 範例（當 expiryRule = 'next_month'）：
 * 2025-10-15 累積的補休 → 2025-11-30 到期（次月底）
 * 2025-11-01 累積的補休 → 2025-12-31 到期（次月底）
 */
```

#### 2. 到期處理：當月有效，次月1日自動轉換為加班費
```typescript
// 每月 1 日 00:00 執行（Cron Job）
async function monthlyCompensatoryLeaveExpiration() {
  const today = new Date();
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);
  const yesterdayStr = yesterday.toISOString().split('T')[0];
  
  // 查詢昨天（上月最後一天）到期的補休
  const expiredLeaves = await db.prepare(`
    SELECT * FROM CompensatoryLeave
    WHERE expiry_date = ?
      AND status = 'active'
      AND hours_remaining > 0
  `).bind(yesterdayStr).all();
  
  for (const leave of expiredLeaves.results) {
    // 獲取當前費率
    const rate = await getCurrentOvertimeRate(leave.work_type_id);
    
    // 轉換為加班費
    await db.prepare(`
      UPDATE CompensatoryLeave
      SET status = 'converted',
          converted_to_payment = 1,
          conversion_date = datetime('now'),
          conversion_rate = ?
      WHERE compe_leave_id = ?
    `).bind(rate.rate_multiplier, leave.compe_leave_id).run();
    
    // 記錄到薪資系統（或生成報表）
    await recordOvertimePayment({
      user_id: leave.user_id,
      hours: leave.hours_remaining,
      rate: rate.rate_multiplier,
      amount: leave.hours_remaining * rate.rate_multiplier,
      source: 'expired_compensatory_leave',
      compe_leave_id: leave.compe_leave_id
    });
    
    // 通知員工
    await sendNotification({
      user_id: leave.user_id,
      type: 'comp_leave_converted',
      message: `您在 ${leave.earned_date} 累積的 ${leave.hours_remaining} 小時補休已到期，已自動轉換為加班費（費率 ${rate.rate_multiplier}）`
    });
  }
  
  console.log(`已處理 ${expiredLeaves.results.length} 筆過期補休`);
}
```

#### 3. FIFO（先進先出）使用規則
```typescript
// 使用補休時，自動按累積日期排序使用
class CompensatoryLeaveService {
  async useCompensatoryLeave(userId: number, hoursToUse: number, useDate: string, leaveApplicationId?: number) {
    // 1. 查詢可用補休（按累積日期排序 - FIFO）
    const availableLeaves = await this.db.prepare(`
      SELECT * FROM CompensatoryLeave
      WHERE user_id = ?
        AND status = 'active'
        AND hours_remaining > 0
        AND expiry_date >= date('now')
      ORDER BY earned_date ASC
    `).bind(userId).all();
    
    if (availableLeaves.results.length === 0) {
      throw new ValidationError('沒有可用的補休');
    }
    
    // 2. 計算總可用時數
    const totalAvailable = availableLeaves.results.reduce(
      (sum, leave) => sum + leave.hours_remaining, 
      0
    );
    
    if (totalAvailable < hoursToUse) {
      throw new ValidationError(
        `補休時數不足。可用：${totalAvailable} 小時，需求：${hoursToUse} 小時`
      );
    }
    
    // 3. 按 FIFO 順序扣除
    let remainingToUse = hoursToUse;
    const usedLeaves = [];
    
    for (const leave of availableLeaves.results) {
      if (remainingToUse <= 0) break;
      
      const hoursToUseFromThis = Math.min(leave.hours_remaining, remainingToUse);
      
      // 更新補休餘額
      await this.db.prepare(`
        UPDATE CompensatoryLeave
        SET hours_remaining = hours_remaining - ?,
            status = CASE 
              WHEN hours_remaining - ? <= 0 THEN 'used'
              ELSE 'active'
            END
        WHERE compe_leave_id = ?
      `).bind(hoursToUseFromThis, hoursToUseFromThis, leave.compe_leave_id).run();
      
      // 記錄使用歷史
      await this.db.prepare(`
        INSERT INTO CompensatoryLeaveUsage (
          compe_leave_id,
          leave_application_id,
          hours_used,
          used_date
        ) VALUES (?, ?, ?, ?)
      `).bind(
        leave.compe_leave_id,
        leaveApplicationId || null,
        hoursToUseFromThis,
        useDate
      ).run();
      
      usedLeaves.push({
        compe_leave_id: leave.compe_leave_id,
        hours_used: hoursToUseFromThis,
        hours_remaining: leave.hours_remaining - hoursToUseFromThis
      });
      
      remainingToUse -= hoursToUseFromThis;
    }
    
    return {
      used_compensatory_leaves: usedLeaves,
      total_hours_used: hoursToUse,
      remaining_total: totalAvailable - hoursToUse
    };
  }
}
```

#### 4. 補休使用追踪
```typescript
// 查詢補休使用歷史
async function getCompensatoryLeaveHistory(userId: number, startDate: string, endDate: string) {
  const history = await db.prepare(`
    SELECT 
      cl.compe_leave_id,
      cl.hours_earned,
      cl.earned_date,
      cl.expiry_date,
      cl.status,
      clu.usage_id,
      clu.hours_used,
      clu.used_date,
      la.leave_id,
      la.leave_type_id,
      lt.type_name as leave_type_name
    FROM CompensatoryLeave cl
    LEFT JOIN CompensatoryLeaveUsage clu ON cl.compe_leave_id = clu.compe_leave_id
    LEFT JOIN LeaveApplications la ON clu.leave_application_id = la.leave_id
    LEFT JOIN LeaveTypes lt ON la.leave_type_id = lt.leave_type_id
    WHERE cl.user_id = ?
      AND cl.earned_date BETWEEN ? AND ?
    ORDER BY cl.earned_date DESC, clu.used_date DESC
  `).bind(userId, startDate, endDate).all();
  
  return history.results;
}
```

#### 5. 工時填寫提醒（每天08:30執行）
```typescript
/**
 * Cron Job: 每天 08:30 執行（週一到週五）
 * 配置：crons = ["30 8 * * 1-5"]
 * 
 * 功能：檢查員工昨天是否有填工時
 * 通知：員工本人 + 管理員
 * 期限：直到員工補填為止
 */
async function checkMissingTimesheets(db: D1Database) {
  const yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);
  const yesterdayStr = yesterday.toISOString().split('T')[0];
  const dayOfWeek = yesterday.getDay();
  
  // 排除週末（0=週日, 6=週六）
  if (dayOfWeek === 0 || dayOfWeek === 6) {
    console.log('週末，跳過工時檢查');
    return;
  }
  
  // 檢查是否為國定假日
  const isHoliday = await db.prepare(`
    SELECT * FROM Holidays WHERE holiday_date = ?
  `).bind(yesterdayStr).first();
  
  if (isHoliday) {
    console.log(`${yesterdayStr} 為國定假日，跳過工時檢查`);
    return;
  }
  
  // 查詢所有員工
  const users = await db.prepare(`
    SELECT user_id, name FROM Users WHERE is_deleted = 0
  `).all();
  
  const missingUsers = [];
  
  for (const user of users.results) {
    // 檢查是否有工時記錄
    const timelog = await db.prepare(`
      SELECT * FROM TimeLogs
      WHERE user_id = ? AND work_date = ? AND is_deleted = 0
    `).bind(user.user_id, yesterdayStr).first();
    
    // 檢查是否有請假記錄
    const leave = await db.prepare(`
      SELECT * FROM LeaveApplications
      WHERE user_id = ?
        AND start_date <= ?
        AND end_date >= ?
    `).bind(user.user_id, yesterdayStr, yesterdayStr).first();
    
    // 如果沒工時也沒請假 → 需要提醒
    if (!timelog && !leave) {
      // 檢查是否已經有提醒（避免重複）
      const existingNotif = await db.prepare(`
        SELECT * FROM Notifications
        WHERE user_id = ?
          AND type = 'missing_timesheet'
          AND related_date = ?
          AND dismissed_at IS NULL
      `).bind(user.user_id, yesterdayStr).first();
      
      if (!existingNotif) {
        // 創建提醒給員工本人
        await db.prepare(`
          INSERT INTO Notifications (
            user_id, type, message, related_date, action_url, auto_dismiss
          ) VALUES (?, 'missing_timesheet', ?, ?, ?, 0)
        `).bind(
          user.user_id,
          `提醒：${yesterdayStr} 工時尚未填寫`,
          yesterdayStr,
          `/timesheets/new?date=${yesterdayStr}`
        ).run();
        
        missingUsers.push({ user_id: user.user_id, name: user.name });
      }
    }
  }
  
  // 如果有員工未填，通知所有管理員
  if (missingUsers.length > 0) {
    const admins = await db.prepare(`
      SELECT user_id FROM Users WHERE is_admin = 1 AND is_deleted = 0
    `).all();
    
    const userNames = missingUsers.map(u => u.name).join('、');
    
    for (const admin of admins.results) {
      // 檢查是否已有此日期的彙總提醒
      const existingAdminNotif = await db.prepare(`
        SELECT * FROM Notifications
        WHERE user_id = ?
          AND type = 'admin_missing_timesheet_summary'
          AND related_date = ?
          AND dismissed_at IS NULL
      `).bind(admin.user_id, yesterdayStr).first();
      
      if (!existingAdminNotif) {
        await db.prepare(`
          INSERT INTO Notifications (
            user_id, type, message, related_date, action_url, auto_dismiss
          ) VALUES (?, 'admin_missing_timesheet_summary', ?, ?, ?, 0)
        `).bind(
          admin.user_id,
          `${missingUsers.length}位員工尚未填寫${yesterdayStr}工時：${userNames}`,
          yesterdayStr,
          `/admin/timesheets?date=${yesterdayStr}`
        ).run();
      }
    }
  }
  
  console.log(`工時檢查完成：${missingUsers.length} 位員工未填寫 ${yesterdayStr} 工時`);
}

/**
 * 自動消除通知（當員工補填工時後）
 * 
 * 觸發時機：員工新增工時記錄時
 */
async function dismissTimesheetNotification(userId: number, workDate: string) {
  await db.prepare(`
    UPDATE Notifications
    SET dismissed_at = datetime('now')
    WHERE user_id = ?
      AND type = 'missing_timesheet'
      AND related_date = ?
      AND dismissed_at IS NULL
  `).bind(userId, workDate).run();
  
  // 同時更新管理員的彙總提醒（重新計算）
  await updateAdminTimesheetSummary(workDate);
}
```

#### 6. 補休到期提醒
```typescript
// 每天執行，提醒即將到期的補休（月底前5天）
async function sendCompLeaveExpiryReminders() {
  const fiveDaysLater = new Date();
  fiveDaysLater.setDate(fiveDaysLater.getDate() + 5);
  const fiveDaysLaterStr = fiveDaysLater.toISOString().split('T')[0];
  
  const expiringLeaves = await db.prepare(`
    SELECT 
      cl.*,
      u.name
    FROM CompensatoryLeave cl
    JOIN Users u ON cl.user_id = u.user_id
    WHERE cl.expiry_date <= ?
      AND cl.status = 'active'
      AND cl.hours_remaining > 0
  `).bind(fiveDaysLaterStr).all();
  
  for (const leave of expiringLeaves.results) {
    // 檢查是否已有提醒
    const existingNotif = await db.prepare(`
      SELECT * FROM Notifications
      WHERE user_id = ?
        AND type = 'comp_leave_expiring'
        AND related_date = ?
        AND dismissed_at IS NULL
    `).bind(leave.user_id, leave.expiry_date).first();
    
    if (!existingNotif) {
      await db.prepare(`
        INSERT INTO Notifications (
          user_id, type, message, related_date, action_url, auto_dismiss
        ) VALUES (?, 'comp_leave_expiring', ?, ?, ?, 1)
      `).bind(
        leave.user_id,
        `您有 ${leave.hours_remaining} 小時補休將於 ${leave.expiry_date} 到期，請儘快使用`,
        leave.expiry_date,
        `/leaves/apply?type=compensatory`,
        1  // 到期後可自動消除
      ).run();
    }
  }
}
```

### 請假處理
```
在工時表填寫請假：
1. client_id = NULL
2. leave_type_id = 選擇的假別
3. hours = 請假時數
4. 自動扣除假期餘額

補休請假流程：
1. 查詢可用補休（FIFO排序）
2. 優先使用最早的補休
3. 記錄使用歷史
4. 更新補休餘額
```

---

## 🧪 測試案例

```typescript
// 測試1：新增工時成功
test('應該成功新增工時', async () => {
  const data = {
    work_date: '2025-11-01',
    client_id: '12345678',
    hours: 8
  };
  const result = await createTimeLog(data, user);
  expect(result.hours).toBe(8);
});

// 測試2：員工只能看自己
test('員工只能看自己的工時', async () => {
  const user = { user_id: 2, is_admin: false };
  const logs = await getTimeLogs({}, user);
  logs.forEach(log => {
    expect(log.user_id).toBe(2);
  });
});

// 測試3：加權工時計算正確
test('應該正確計算加權工時', async () => {
  const result = await calculateWeightedHours(1, '2025-11-01', '2025-11-30');
  expect(result.weightedHours).toBeGreaterThan(result.totalHours);
});
```

---

**這個文檔包含工時管理的所有技術細節。**

