# 重构任务核心准则

## 触发
用户输入："开始重构"时执行

## 标准工作流程（每步严格执行）
1. 读取 progress.md 获取当前步骤X
2. 读取 steps/X.md 获取详细任务
3. 执行任务（5个强制动作，缺一不可）：
   
   **动作1: 读取代码**
   - 必须执行read_file
   - 不得说"太长"、"类似"而跳过
   - 必须读取steps/X.md指定的完整行数
   
   **动作2: 记录到catalog**
   - 必须复制完整代码片段（不是摘要）
   - 必须标记发现的组件位置
   - 必须记录API调用和字段名
   - 必须对照standards/验证字段正确性
   
   **动作3: 立即重构**
   - 发现可复用组件 → 立即提取到new-code/components/
   - 立即写入/追加new-code/pages/
   - 必须使用已提取的组件（不重复写）
   - 必须保留所有功能（不能简化掉）
   
   **动作4: 立即对比验证**
   - 列出旧代码这100行的所有功能点
   - 逐一检查新代码是否都实现
   - 写入catalog/页面.md的对比记录
   - 如有遗漏立即补充
   
   **动作5: 回溯检查**
   - 本段与之前段落的实现方式有差异吗？
   - 哪种方式更好？（评估标准：通用性、简洁性、可维护性）
   - 需要统一 → 修改之前的new-code/代码
   - 记录修改到logs/回溯.txt

4. 写日志到 logs/X.txt
5. 更新 progress.md: 当前步骤=X+1
6. 输出: ✅ X/总数 → X+1

## 绝对禁止事项

### 禁止偷懒
- ❌ 禁止跳过read_file（声称"已经知道"）
- ❌ 禁止只读不记录
- ❌ 禁止只记录不重构
- ❌ 禁止只重构不对比
- ❌ 禁止跳过回溯检查

### 禁止批量思维
- ❌ 禁止说"与XX页面类似"
- ❌ 禁止说"参考XX的方式"
- ❌ 禁止复制粘贴代码然后批量替换
- ❌ 禁止假设所有页面结构相同
- ❌ 必须实际read_file每个文件
- ❌ 必须记录每个文件的具体差异

### 禁止遗漏
- ❌ 禁止省略任何功能点
- ❌ 禁止说"次要功能可以省略"
- ❌ 禁止简化掉边缘情况处理
- ❌ 必须100%功能迁移

### 禁止总结
- ❌ 禁止写解释、说明、总结（除了最后一行状态）
- ❌ 禁止输出"我已经完成了..."
- ❌ 只输出: ✅ X/总数 → X+1

## 字段名验证（强制）
每次发现字段名时：
1. 对照 standards/db-schema.json
2. 确认拼写正确（user_id不是userId）
3. 在catalog中标记: user_id ✓已验证
4. 如不在schema中 → 停下来确认是否新字段

## API验证（强制）
每次发现API调用时：
1. 对照 standards/api-endpoints.json
2. 确认端点存在
3. 在catalog中标记: GET /api/tasks ✓已验证
4. 如不在列表中 → 停下来确认是否新端点

## 回溯修改机制（关键）

### 何时触发回溯
1. 发现navbar有两种不同实现
2. 发现modal关闭逻辑不统一
3. 发现API调用方式不一致
4. 发现任何应该统一但没统一的地方

### 回溯步骤
1. **评估**: 哪种方式更好？
   - 方式A: (描述优缺点)
   - 方式B: (描述优缺点)
   - 决定: 采用方式B
   
2. **修改**: 
   - 修改 new-code/components/navbar.html
   - 检查所有引用navbar的页面
   - 修改 new-code/pages/所有相关文件
   
3. **记录**: 
   追加到 logs/回溯.txt:
   ```
   步骤X: 统一navbar实现
   原因: 发现两种不同的关闭方式
   改为: 统一使用事件委托
   影响文件:
   - new-code/components/navbar.html
   - new-code/pages/dashboard.html
   - new-code/pages/tasks.html
   ```
   
4. **更新catalog**: 
   在相关页面的catalog/中添加注释：
   ```
   navbar: ✓已统一（步骤X回溯修改）
   ```

## 组件提取原则

### 何时提取组件
- 完全相同的HTML结构
- 类似的功能但参数不同
- 出现2次以上的模式

### 如何提取
1. 从catalog/复制原始代码
2. 识别可参数化的部分
3. 创建通用组件
4. 创建使用文档（注释在组件文件中）

### 组件命名
- navbar.html - 导航栏
- table-data.html - 数据表格
- modal-form.html - 表单弹窗
- button-primary.html - 主按钮
（具体根据实际发现的组件）

## 对比验证标准

### 必须验证的功能点
- 所有按钮/链接的点击事件
- 所有表单的提交逻辑
- 所有API调用
- 所有数据渲染
- 所有条件判断分支
- 所有错误处理

### 验证方法
旧代码有：
```javascript
button.onclick = () => {
  if (validate()) {
    save();
    refresh();
  }
}
```

新代码必须有：
- [ ] 按钮点击事件 ✓
- [ ] validate()调用 ✓  
- [ ] save()调用 ✓
- [ ] refresh()调用 ✓
- [ ] 条件判断 ✓

## 输出格式（严格限制）
正常步骤：
```
✅ 5/总数 → 6
```

检查点（每10步）：
```
✅ 10/总数 → 11
⚠️ 建议换新对话
```

自检失败时（内部处理）：
```
[内部] 对比失败: 缺少refresh()调用
[内部] 补充到new-code/pages/dashboard.html 行X
[内部] 重新验证: ✓通过
```
（然后输出正常的 ✅）

## 特殊情况处理

### 遇到不确定的代码
- 不要猜测
- 记录到 catalog/疑问.md
- 标记为 ⚠️待确认
- 继续下一步

### 遇到全局变量
- 必须记录到catalog
- 必须追踪所有使用位置
- 重构时改为模块化

### 遇到复杂逻辑
- 完整复制到new-code（不简化）
- 添加注释说明来源
- 标记为可优化（但不在本次重构中优化）

